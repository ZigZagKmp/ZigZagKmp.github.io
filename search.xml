<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Probability and Statistics 3</title>
    <url>/2023/10/16/Probability-and-Statistics-3/</url>
    <content><![CDATA[<h2 id="chapter-1-background-in-probability">Chapter 1 Background in
Probability</h2>
<h3 id="integration">1.4 Integration</h3>
<ol type="1">
<li><p>Judgement : an integration should satisfies :</p>
<ol type="i">
<li><p><span class="math inline">\(\varphi\ge 0\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int\varphi d\mu\ge 0\)</span></p></li>
<li><p><span class="math inline">\(\int a\varphi d\mu=a\int \varphi
d\mu\)</span></p></li>
<li><p><span class="math inline">\(\int (\varphi+\psi)d\mu=\int \varphi
d\mu+\int \psi d\mu\)</span></p></li>
</ol></li>
<li><p>Basic Properties of integration</p>
<ol start="4" type="i">
<li><p><span class="math inline">\(\varphi\le \psi\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int \varphi d\mu\le \int \psi
d\mu\)</span></p></li>
<li><p><span class="math inline">\(\varphi=\psi\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int \varphi d\mu=\int \psi d\mu\)</span></p></li>
<li><p><span class="math inline">\(\left|\int \varphi d\mu\right|\le
\int |\varphi|d\mu\)</span></p></li>
</ol></li>
<li><p>Bounded Function</p>
<ol type="1">
<li><p>Def [ <strong><em>Bounded Function</em></strong> ] : <span
class="math inline">\(\exists M&lt;\infty,|f(x)|\le M\)</span> , and
<span class="math inline">\(\exists E\subseteq \Omega ,
\mu(E)&lt;\infty,f(E^c)=0\)</span> .</p></li>
<li><p>Def [ <strong><em>Integration for Bounded Function</em></strong>
] : Let <span class="math inline">\(\Phi_s\)</span> be the set of simple
functions . If <span class="math inline">\(f\)</span> is a bounded
function, <span class="math display">\[
\int fd\mu:=\sup_{\varphi\in \Phi_s , \varphi\le f}\int \varphi d\mu
=\inf_{\psi\in \Phi_s , \psi\ge f}\int \psi d\mu
\]</span></p>
<blockquote>
<p><span class="math inline">\(\varphi \le f,\psi\ge f\)</span> : <span
class="math inline">\(\mu\)</span>-a.e.</p>
</blockquote>
<blockquote>
<p>Intuition : Like Darboux's upper sum and lower sum</p>
</blockquote></li>
<li><p>Proof of <span class="math inline">\(\sup\limits_{\varphi\in
\Phi_s , \varphi\le f}\int \varphi d\mu =\inf\limits_{\psi\in \Phi_s ,
\psi\ge f}\int \psi d\mu\)</span></p>
<ol type="1">
<li><p>By Prop (iv) , <span class="math inline">\(\varphi\le f\le
\psi\)</span> , so <span class="math inline">\(\int \varphi d\mu\le \int
\psi d\mu\)</span></p></li>
<li><p>Prove <span class="math inline">\(\sup\limits_{\varphi\in \Phi_s
, \varphi\le f}\int \varphi d\mu \ge \inf\limits_{\psi\in \Phi_s ,
\psi\ge f}\int \psi d\mu\)</span></p>
<p>Since <span class="math inline">\(|f|\le M\)</span> , let <span
class="math inline">\(E_k:=\{x\in E|\frac{(k-1)M}{n}&lt;f(x)\le
\frac{kM}{n}\}\)</span> , <span class="math inline">\(-n\le k\le
n\)</span> .</p>
<p>Let <span class="math inline">\(\varphi_n=\sum\limits_{k=-n}^n
\frac{(k-1)M}{n}\mathbb 1_{E_k}\)</span> , <span
class="math inline">\(\psi_n=\sum\limits_{k=-n}^n \frac{kM}{n}\mathbb
1_{E_k}\)</span></p>
<p>Therefore , <span class="math inline">\(\int
(\psi_n-\varphi_n)d\mu=\frac{M}{n}\mu(E)\)</span> , <span
class="math display">\[
\sup\limits_{\varphi\in \Phi_s , \varphi\le f}\int \varphi d\mu \ge\int
\varphi_nd\mu =-\frac{M}{n}\mu(E)+\int \psi_n d\mu \ge
-\frac{M\mu(E)}{n}+\inf\limits_{\psi\in \Phi_s , \psi\ge f}\int \psi
d\mu
\]</span> When <span class="math inline">\(n\to +\infty\)</span> , <span
class="math inline">\(-\frac{M\mu(E)}{n}\to 0\)</span> , so <span
class="math inline">\(\sup\limits_{\varphi\in \Phi_s , \varphi\le f}\int
\varphi d\mu =\inf\limits_{\psi\in \Phi_s , \psi\ge f}\int \psi
d\mu\)</span> .</p>
<figure>
<img src="/images/posts/PS3_fig1.png" alt="diagram of the proof" />
<figcaption aria-hidden="true">diagram of the proof</figcaption>
</figure></li>
</ol></li>
<li><p>Proof of (i)(ii)(iii)</p>
<ol type="i">
<li><p>: Let <span class="math inline">\(\varphi=0\)</span> ,
trivial</p></li>
<li><p>: For <span class="math inline">\(a&gt;0\)</span> , <span
class="math inline">\(a\varphi\le af\iff \varphi\le f\)</span> <span
class="math display">\[
\int afd\mu =\sup_{a\varphi\le af}\int a\varphi d\mu =\sup_{\varphi\le
f}\int a\varphi d\mu=a\sup_{\varphi\le f}\int \varphi d\mu=a\int fd\mu
\]</span></p></li>
<li><p>: Firstly prove <span class="math inline">\(\int (f+g)d\mu\le
\int fd\mu +\int gd\mu\)</span> .</p></li>
</ol>
<p>Let <span class="math inline">\(\Phi_s&#39;=\{\psi|\exists
\psi_1,\psi_2,\psi=\psi_1+\psi_2,\psi_1\ge f,\psi_2\ge g\}\)</span> , so
<span class="math inline">\(\Phi_s&#39;\subseteq \{\psi|\psi\ge
f+g\}\)</span> . <span class="math display">\[
\begin{aligned}
\int(f+g)d\mu&amp;=\inf_{\psi\ge f+g} \psi d\mu\\
&amp;\le \inf_{\psi=\psi_1+\psi_2\in \Phi_s&#39;} (\psi_1+\psi_2)d\mu\\\
&amp;=\inf_{\psi_1\ge f,\psi_2\ge g} \int \psi_1d\mu+\int \psi_2d\mu\\
&amp;=\inf_{\psi_1\ge f} \int \psi_1d\mu+\inf_{\psi_2\ge g}\int
\psi_2d\mu\\
&amp;=\int fd\mu+\int gd\mu
\end{aligned}
\]</span> Use (ii) , let <span class="math inline">\(a=-1\)</span> , so
<span class="math inline">\(\int -(f+g)d\mu\le \int (-f)d\mu+\int
(-g)d\mu\)</span> , so <span class="math inline">\(\int (f+g)d\mu\ge
\int fd\mu+\int gd\mu\)</span> .</p></li>
</ol></li>
<li><p>Non-Negative Function</p>
<ol type="1">
<li><p>Compare with bounded function</p>
<ul>
<li>can exists <span class="math inline">\(x\)</span> , <span
class="math inline">\(f(x)\to\infty\)</span></li>
<li>the smallest <span class="math inline">\(E\)</span> s.t. <span
class="math inline">\(f(E^c)=0\)</span> , may be <span
class="math inline">\(\mu(E)\to\infty\)</span></li>
</ul></li>
<li><p>Notation :</p>
<ul>
<li><p><span class="math display">\[
\int_E fd\mu:=\int f\cdot \mathbb 1_{E}d\mu
\]</span></p></li>
<li><p><span class="math display">\[
a\land b:=\min\{a,b\}
\]</span></p></li>
<li><p>Def [ <strong><em>Integration for non-negative
function</em></strong> ] For non-negative function <span
class="math inline">\(f\)</span> , <span class="math display">\[
\int fd\mu=\sup\left\{\small\int hd\mu\mid 0\le h\le f,h\text{ bounded
function}\right\}
\]</span></p>
<blockquote>
<p><span class="math inline">\(h\)</span> is bounded function , so <span
class="math inline">\(\int hd\mu\)</span> is bounded , but <span
class="math inline">\(\sup \int hd\mu\)</span> can be unbounded .</p>
</blockquote></li>
</ul></li>
<li><p>Lemma :</p>
<p>If <span class="math inline">\(E_n\uparrow \Omega ,
\mu(E_n)&lt;\infty\)</span> , then <span class="math display">\[
\int_{E_n}f\land nd\mu\uparrow \int fd\mu
\]</span></p>
<blockquote>
<p>This lemma needs <span class="math inline">\(\mu\)</span> be a <span
class="math inline">\(\sigma\)</span>-finite measure.</p>
</blockquote>
<blockquote>
<p><span class="math inline">\((f\land n)\cdot \mathbb 1_E\in \{h|0\le
h\le f,h\text{ bounded function}\}\)</span></p>
</blockquote>
<p><strong>Proof</strong></p>
<p>It's easy to find that <span
class="math inline">\(\lim\limits_{n\to\infty}\int_{E_n}f\land n\
d\mu=\sup\limits_{n\ge 1}\int_{E_n}f\land n\ d\mu\le \int fd\mu\)</span>
.</p>
<p>We only need to prove that <span class="math inline">\(\forall
h,|h|&lt;M,0\le h\le f\)</span> , <span
class="math inline">\(\lim\limits_{n\to\infty}\int_{E_n}f\land n\
d\mu\ge \int fd\mu\)</span> .</p>
<p><span class="math inline">\(\forall n&gt;M\)</span> , <span
class="math inline">\(\int_{E_n} f\land n\ d\mu\ge \int_{E_n}hd\mu=\int
hd\mu-\int_{E_n^c}hd\mu\)</span> .</p>
<p>And <span class="math inline">\(\int_{E_n^c} hd\mu\le M\mu(E_n^c\cap
\{x|h(x)&gt;0\})\)</span> .</p>
<p>Since <span class="math inline">\(n\to \infty , \mu(E_n^c\cap
\{x|h(x)&gt;0\})\to 0\)</span> <span class="math inline">\((*)\)</span>
.</p>
<p>Therefore , <span class="math inline">\(\liminf\limits_{n\to \infty}
\int_{E_n} f\land n\ d\mu\ge \int hd\mu\)</span> .</p>
<p><strong>To prove <span
class="math inline">\((*)\)</span></strong></p>
<p>Let <span class="math inline">\(a_n=\mu(E_n^c\cap
\{x|h(x)&gt;0\})\)</span> , we only need to prove that <span
class="math inline">\(\lim_{n\to \infty} a_n=0\)</span> .</p>
<p>Way 1 : <span class="math inline">\(a_n\)</span> non-increasing ,
<span class="math inline">\(a_n\ge 0\)</span> , so <span
class="math inline">\(\lim_{n\to\infty} a_n=c\)</span></p>
<p>If <span class="math inline">\(c&gt;0\)</span> , then <span
class="math inline">\(\exists \tilde \Omega\subseteq \Omega ,
\mu(\tilde\Omega)=c\)</span> , <span class="math inline">\(\forall
n,\tilde\Omega\cap E_n=\varnothing\)</span> .</p>
<p>Therefore , <span class="math inline">\(\tilde \Omega\cap
\bigcup_{n=1}^{\infty}E_n=\varnothing\)</span> , so <span
class="math inline">\(\tilde \Omega\cap\Omega=\varnothing\)</span> ,
contradicts .</p>
<p>Way 2 : By definition , <span class="math inline">\(E_1^c\supset
E_2^c \supset\cdots\)</span> , so <span
class="math inline">\(E_n^c=\bigcap_{m=1}^n E_m^c\)</span> .</p>
<p><span
class="math inline">\(\lim_{n\to\infty}a_n=\mu(\bigcap_{m=1}^{\infty}E_m^c\cap\{x|h(x)&gt;0\})=\mu(\Omega^c\cap\{x|h(x)&gt;0\})=0\)</span></p></li>
<li><p>Proof of (i)(ii)(iii)</p>
<ol type="i">
<li><p>trivial (non-negative)</p></li>
<li><p><span class="math inline">\(a&gt;0\)</span> , so <span
class="math inline">\(ah\le af\iff h\le f\)</span> <span
class="math display">\[
\begin{aligned}
\int af\ d\mu&amp;=\sup\{\int ah\ d\mu|0\le ah\le af,ah\text{ bounded
function}\}\\
&amp;=\sup\{a\int h\ d\mu|0\le h\le f,h\text{ bounded function}\}\\
&amp;=a\int fd\mu
\end{aligned}
\]</span></p></li>
<li><p>Firstly prove <span class="math inline">\(\int (f+g)d\mu\ge \int
fd\mu+\int gd\mu\)</span></p></li>
</ol>
<p>Consider bounded function <span class="math inline">\(k,h\)</span> ,
<span class="math inline">\(f\ge h,g\ge k\)</span> , so ,</p>
<p><span class="math inline">\(\int (f+g)d\mu\ge \sup_{0\le h\le f}\int
hd\mu+\sup_{0\le k\le g}\int gd\mu=\int fd\mu+\int gd\mu\)</span></p>
<p>Secondly prove <span class="math inline">\(\int(f+g)d\mu\le \int
fd\mu+\int gd\mu\)</span></p>
<p>Use Lemma , <span class="math inline">\((f+g)\land n\le (f\land
n)+(g\land n)\)</span> .</p>
<p>Therefore , <span class="math inline">\(\int_{E_n}(f+g)\land n\
d\mu\le \int_{E_n}f\land n\ d\mu+\int_{E_n} g\land n\ d\mu\)</span>
.</p>
<p>As <span class="math inline">\(n\to\infty\)</span> , <span
class="math inline">\(\int (f+g)d\mu\le \int fd\mu+\int
gd\mu\)</span></p></li>
</ol></li>
<li><p>General Function</p>
<ol type="1">
<li><p>Def [ <strong><em>Integralable</em></strong> ] : <span
class="math inline">\(f\)</span> is
<strong><em>integralable</em></strong> if <span
class="math inline">\(\int |f|d\mu&lt;\infty\)</span></p></li>
<li><p>Def [ <strong><em>Integration for General Function</em></strong>
] : If <span class="math inline">\(f\)</span> is integralable ,
define</p>
<p><span class="math inline">\(f^+(x):=f(x)\cdot\mathbb 1(f(x)\ge
0)\)</span> , <span class="math inline">\(f^-(x):=|f(x)|\cdot \mathbb
1(f(x)&lt;0)\)</span></p>
<p>Therefore , <span class="math inline">\(f(x)=f^+(x)-f^-(x)\)</span> ,
and <span class="math inline">\(f^+,f^-\)</span> non-negative <span
class="math display">\[
\int fd\mu:=\int f^+d\mu-\int f^-d\mu
\]</span></p>
<blockquote>
<p>Note : If <span class="math inline">\(f\)</span> is not integralable
, then <span class="math inline">\(\int f^+d\mu\)</span> , <span
class="math inline">\(\int f^-d\mu\)</span> can both be <span
class="math inline">\(\infty\)</span> , <span
class="math inline">\(\infty-\infty\)</span> not well-defined.</p>
</blockquote></li>
</ol></li>
<li><p>Lebesgue Integration</p>
<ol type="1">
<li><p>When <span class="math inline">\(\mu\)</span> is Lebesgue measure
: <span class="math inline">\(\mu((a,b])=b-a\)</span> .</p>
<p><span class="math inline">\(\int fd\mu\)</span> is Lebesgue
Integration of <span class="math inline">\(f\)</span> .</p></li>
<li><p>Compare with Riemann Integration</p>
<figure>
<img src="/images/posts/PS3_fig2.png"
alt="Riemann Integration and Lebesgue Integration" />
<figcaption aria-hidden="true">Riemann Integration and Lebesgue
Integration</figcaption>
</figure>
<p>Lebesgue is more powerful</p>
<p>E.g. Dirichlet function <span class="math inline">\(\mathbb
1_{\mathbb Q}\)</span> , <span class="math inline">\(\int_{[0,1]}\mathbb
1_{\mathbb Q}\)</span></p>
<ul>
<li>Riemann integration : not integralable , <span
class="math inline">\(\mu(\{x:\mathbb 1_{\mathbb Q}\text{ incontinuous
at }x\})&gt;0\)</span></li>
<li>Lebesgue integration : integralable : <span
class="math inline">\(\int_{[0,1]}\mathbb 1_{\mathbb Q}=\mu(\mathbb
Q\cap [0,1])=0\)</span></li>
</ul></li>
</ol></li>
<li><p>Formal Definition of PDF</p>
<ol type="1">
<li><p>Def [ <strong><em>Absolutely Continuous</em></strong> ] : <span
class="math inline">\(\nu\)</span> is <strong><em>absolutely
continuous</em></strong> w.r.t <span class="math inline">\(\mu\)</span>
( denote as <span class="math inline">\(\nu\ll \mu\)</span> ) if</p>
<p><span class="math inline">\(\forall A\in \mathcal F\)</span> , <span
class="math inline">\(\mu(A)=0\Rightarrow \nu(A)=0\)</span></p></li>
<li><p>Thm [ Radon-Nikodym ] : measurable space <span
class="math inline">\((\Omega,\mathcal F)\)</span> with <span
class="math inline">\(\sigma\)</span>-finite measure <span
class="math inline">\(\nu,\mu\)</span> , <span
class="math inline">\(\nu\ll\mu\)</span></p>
<p>Then <span class="math inline">\(\exists g\ge 0,\forall E\in \mathcal
F,\int_Egd\mu=\nu(E)\)</span></p>
<p><span class="math inline">\(g\)</span> is called Radon-Nikodym
derivative</p></li>
<li><p>Prop : If <span class="math inline">\(\exists g,h\)</span> ,
<span class="math inline">\(\int_Egd\mu=\int_Ehd\mu=\nu(E)\)</span> ,
then <span class="math inline">\(g\equiv h\)</span> a.e.</p></li>
<li><p>Def [ <strong><em>PDF</em></strong> ] : When <span
class="math inline">\(\nu\)</span> is a distribution measure , <span
class="math inline">\(\mu\)</span> is Lebesgue measure , <span
class="math inline">\(g\)</span> is the <strong><em>probability density
function</em></strong> for <span class="math inline">\(\nu\)</span>
.</p>
<blockquote>
<p>Observation : <span class="math inline">\(\nu(E)=P(X\in E)=\int
gd\mu\)</span></p>
</blockquote></li>
<li><p>Prop : <span class="math inline">\(g\)</span> is <span
class="math inline">\(\mathcal F\)</span>-measurable , i.e. <span
class="math inline">\(g\)</span> is a measurable map <span
class="math inline">\((\Omega,\mathcal F)\to(\mathbb R,\mathcal
R)\)</span> .</p></li>
</ol></li>
</ol>
<h3 id="properties-of-integration">1.5 Properties of Integration</h3>
<ol type="1">
<li><p>Jenson's Inequality</p>
<ol type="1">
<li><p>Def [ <strong><em>convex</em></strong> ] : <span
class="math inline">\(\varphi\)</span> is a convex , if <span
class="math inline">\(\forall \lambda\in (0,1) ,
\lambda\varphi(x)+(1-\lambda)\varphi(y)\ge \varphi(\lambda
x+(1-\lambda)y)\)</span></p></li>
<li><p>THM [ <strong><em>Jenson's Inequality</em></strong> ] : If <span
class="math inline">\(\varphi\)</span> is a convex , <span
class="math inline">\(\varphi\circ f\)</span> is integralable , <span
class="math inline">\(\mu\)</span> is a probability measure , <span
class="math display">\[
\varphi\left(\int fd\mu\right)\le \int (\varphi \circ f)d\mu
\]</span></p></li>
<li><p>Proof :</p>
<p>For convex <span class="math inline">\(\varphi\)</span> , we can find
a line <span class="math inline">\(L(x)=ax+b\)</span> , s.t. <span
class="math inline">\(\varphi(x)\ge ax+b\)</span> , and equal iff <span
class="math inline">\(x=\int fd\mu\)</span> . <span
class="math display">\[
\begin{aligned}
\int (\varphi \circ f)d\mu&amp;\ge \int (ax+b)\circ fd\mu\\
&amp;=a\int fd\mu+\int bd\mu\\
&amp;=a\int fd\mu+b\mu(\Omega)\\
&amp;=a\int fd\mu+b\\
&amp;=L\left(\int fd\mu\right)\\
&amp;=\varphi\left(\int fd\mu\right)
\end{aligned}
\]</span></p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>概率与统计</category>
      </categories>
      <tags>
        <tag>概率论-概率密度函数</tag>
        <tag>实分析-Lebesgue积分</tag>
        <tag>实分析-积分性质</tag>
      </tags>
  </entry>
  <entry>
    <title>ZKP and MPC 3</title>
    <url>/2023/10/16/ZKP-and-MPC-3/</url>
    <content><![CDATA[<h2 id="lec02-zero-knowledge-proof-under-composition">Lec02
Zero-Knowledge Proof under Composition</h2>
<h3 id="sequential-composition">2.3 Sequential Composition</h3>
<blockquote>
<p><span class="math inline">\(V^*\)</span> : should be viewed as a
black box , input <span
class="math inline">\((input,randomness,messages)\)</span> , output
response</p>
</blockquote>
<blockquote>
<p>If guess wrong at <span class="math inline">\(m_i\)</span> , we can
rewind <span class="math inline">\(V^*\)</span> to the time when it
receives <span class="math inline">\(m_i\)</span> , using the same input
, randomness , first <span class="math inline">\(i-1\)</span>
messages</p>
</blockquote>
<ol type="1">
<li><p>Def [ <strong><em>Zero-Knowledge Proof with Auxiliary
Input</em></strong> ] :</p>
<p><span class="math inline">\((P,V)\)</span> is an
<strong><em>interactive zero-knowledge proof with auxiliary
input</em></strong> for <span class="math inline">\(L\)</span> if</p>
<ul>
<li><p><span class="math inline">\(V\)</span> is an efficient algorithm
( poly-time )</p></li>
<li><p><strong><em>Completeness</em></strong> : <span
class="math inline">\(\forall x\in L,\forall y,z\in \{0,1\}^*\)</span>
<span class="math display">\[
\Pr\{\braket{P(y),V(z)}(x)=1\}=1
\]</span></p></li>
<li><p><strong><em>Soundness with error <span
class="math inline">\(\epsilon\)</span></em></strong> : <span
class="math inline">\(\forall x\notin L,\forall y,z\in
\{0,1\}^*\)</span> <span class="math display">\[
\forall P^*,\Pr\{\braket{P^*(y),V(z)}(x)=1\}&lt;\epsilon
\]</span></p></li>
<li><p><strong><em>Zero-Knowledge</em></strong> : <span
class="math inline">\(\forall V^*\)</span> in P.P.T. , <span
class="math inline">\(\exists\)</span> expected poly-time algorithm
<span class="math inline">\(M^*\)</span> , <span
class="math inline">\(\forall x\in L,\forall y,z\in \{0,1\}^*\)</span> ,
<span class="math display">\[
M^*(x,z)\sim View_{V^*(z)}^{P(y)}(x)
\]</span></p></li>
</ul>
<blockquote>
<p><span class="math inline">\(y\)</span> is indeed redundant since
<span class="math inline">\(P\)</span> is not computationally
bounded</p>
</blockquote>
<blockquote>
<p>Alternating Form of Zero-Knowledge : <span
class="math inline">\(\forall V^*,\exists M^*,\forall x\in L,\forall
y,z\in \{0,1\}^*\)</span> <span class="math display">\[
M^*(x,z)\sim \braket{P(y),V^*(z)}(x)
\]</span></p>
</blockquote></li>
<li><p>Lemma [ <strong><em>Composition Lemma</em></strong> ] :</p>
<p><span class="math inline">\((P,V)\)</span> : zero-knowledge proof
with auxiliary input for <span class="math inline">\(L\)</span> , <span
class="math inline">\(q\)</span> is a polynomial of <span
class="math inline">\(\kappa\)</span></p>
<p><span class="math inline">\((P_q,V_q)\)</span> : An IP runs <span
class="math inline">\((P,V)\)</span> <span
class="math inline">\(q\)</span> times</p>
<p>Claim : <span class="math inline">\((P_q,V_q)\)</span> are still
zero-knowledge .</p></li>
<li><p>Proof of Composition Lemma</p>
<blockquote>
<p>Only Proof for perfect zero-knowledge</p>
<p>Using Alternating Form of Zero-Knowledge</p>
</blockquote>
<h4 id="construction">Construction</h4>
<ol type="1">
<li><p><span class="math inline">\(M^*\)</span> inputs <span
class="math inline">\((x,z)\)</span> , <span
class="math inline">\(st_0=\varnothing\)</span> .</p></li>
<li><p>For <span class="math inline">\(i=1,2,\cdots q\)</span> :</p>
<ol type="1">
<li><p>Construct <span class="math inline">\(V_i^*\)</span> : <span
class="math inline">\(V_i^*(x,st_{i-1},z)=\begin{cases}V^*(x,z)&amp;i=1\\V^*(st_{i-1})&amp;i\ge
2\end{cases}\)</span> , output state of <span
class="math inline">\(V^*\)</span> as <span
class="math inline">\(st_i\)</span></p>
<blockquote>
<p>Note : for <span class="math inline">\(i\ge 2\)</span> , <span
class="math inline">\(x,z\)</span> are contained in <span
class="math inline">\(st_{i-1}\)</span> , so we do not need to input
them.</p>
</blockquote></li>
<li><p>By zero-knowledge , <span class="math inline">\(\exists
M_i^*(x,st_{i-1}|z)\)</span> that can simulate the output of <span
class="math inline">\(V_i^*\)</span>.</p></li>
<li><p><span class="math inline">\(M^*\)</span> runs <span
class="math inline">\(M_i^*(x,st_{i-1}|z)\)</span> to obtain <span
class="math inline">\(st_i\)</span>.</p></li>
</ol></li>
<li><p><span class="math inline">\(M^*\)</span> invokes <span
class="math inline">\(V^*\)</span> with <span
class="math inline">\(st_q\)</span> to obtain final output.</p></li>
</ol>
<h4 id="proof-of-mxzequiv-braketpyvzx">Proof of <span
class="math inline">\(M^*(x,z)\equiv
\braket{P(y),V^*(z)}(x)\)</span></h4>
<ol start="0" type="1">
<li><p><span class="math inline">\(Hyb_0\)</span> : Real Execution <span
class="math inline">\(\braket{P(y),V^*(z)}(x)\)</span></p></li>
<li><p><span class="math inline">\(Hyb_1\)</span> :</p>
<ol type="1">
<li>Run <span class="math inline">\(P(y)\)</span> and <span
class="math inline">\(V^*(z)\)</span> until the last phase .</li>
<li>Record the state of <span class="math inline">\(V^*\)</span> as
<span class="math inline">\(st_{q-1}\)</span> .</li>
<li>Invoke <span class="math inline">\(M_q^*(x,st_{q-1}|z)\)</span> to
obtain <span class="math inline">\(st_q\)</span> .</li>
<li>Invoke <span class="math inline">\(V^*\)</span> with <span
class="math inline">\(st_q\)</span> to obtain final output .</li>
</ol>
<p><strong>Proof of <span class="math inline">\(Hyb_0\equiv
Hyb_1\)</span></strong> :</p>
<p>Fix state <span class="math inline">\(st_{q-1}\)</span> . For <span
class="math inline">\(Hyb_0\)</span> , its distribution is the same
as</p>
<ol type="1">
<li>Run <span class="math inline">\(V_q^*(x,st_{q-1},z)\)</span> to
obtain <span class="math inline">\(st_q\)</span></li>
<li>Run <span class="math inline">\(V^*\)</span> with <span
class="math inline">\(st_q\)</span> to obtain final output</li>
</ol>
<p>By zk , given <span class="math inline">\(x,st_{q-1},z\)</span> ,
<span class="math inline">\(V_q^*(x,st_{q-1},z)\equiv
M_q^*(x,st_{q-1}|z)\)</span>.</p>
<p>Therefore , <span class="math inline">\(Hyb_0\equiv
Hyb_1\)</span>.</p></li>
<li><p><span class="math inline">\(Hyb_i\)</span> : Change to <span
class="math inline">\(M^*\)</span> after the first <span
class="math inline">\(q-i\)</span> phases</p>
<p><span class="math inline">\(Hyb_{i-1}\)</span> : using <span
class="math inline">\(V^*_{q-i+1}\)</span> , <span
class="math inline">\(Hyb_i\)</span> : using <span
class="math inline">\(M^*_{q-i+1}\)</span></p>
<p>Therefore , <span class="math inline">\(Hyb_{i-1}\equiv
Hyb_i\)</span></p></li>
<li><p><span class="math inline">\(Hyb_{q+1}\)</span> : The execution of
<span class="math inline">\(M^*\)</span> .</p></li>
</ol></li>
</ol>
<h2 id="lec03-commitment-scheme-zk-proof-for-general-np">Lec03
Commitment Scheme , zk-proof for general NP</h2>
<h3 id="important">3.0 Important</h3>
<p><strong><em>In the next lecture , we re-defined commitment in a more
simple way .</em></strong></p>
<h3 id="commitment">3.1 Commitment</h3>
<blockquote>
<p>Intuition :</p>
<p>Binding : make some choice , then won't change it . (change will be
rejected)</p>
<p>Hiding : like "safe" , until open it , not knowing the choice .
(uniform distribution)</p>
</blockquote>
<ol type="1">
<li><p>Def [ <strong><em>Commitment</em></strong> ] : Three P.P.T.
algorithms</p>
<ul>
<li><span class="math inline">\(Gen(1^\kappa)\to pp\)</span> ( public
parameter )</li>
<li><span class="math inline">\(Commit_{pp}(m,r)\to
(c,aux)\)</span></li>
<li><span
class="math inline">\(Verify_{pp}(m,c,aux)\to\{Accept,Reject\}\)</span></li>
</ul>
<p>Satisfying properties :</p>
<ul>
<li><strong><em>Hiding</em></strong> : <span
class="math inline">\(\forall m,m&#39;\)</span> , the following
distributions are identical/statistically
indistinguishable/computationally indistinguishable</li>
</ul>
<p><span class="math display">\[
Dist\{pp\gets Gen(1^\kappa),(c,aux)\gets Commit_{pp}(m,r) : (pp,c)\}
\]</span></p>
<p><span class="math display">\[
Dist\{pp\gets Gen(1^\kappa),(c,aux)\gets Commit_{pp}(m&#39;,r) :
(pp,c)\}
\]</span></p>
<ul>
<li><p><strong><em>Binding</em></strong> : <span
class="math inline">\(\forall m\neq m&#39;\)</span> , <span
class="math inline">\(\forall pp\gets Gen(1^\kappa)\)</span> ,</p>
<p><strong><em>Perfect Binding</em></strong> : <span
class="math display">\[
\{c|(c,aux)\gets Commit_{pp}(m,r)\}\cap\{c|(c,aux)\gets
Commit_{pp}(m&#39;,r)\}=\varnothing
\]</span> <strong><em>Computationally Binding</em></strong> : <span
class="math inline">\(\forall P^*\)</span> in P.P.T.</p></li>
</ul></li>
</ol>
<p><span class="math display">\[
\small{\Pr\{pp\gets Gen(1^\kappa) , (c,m,aux,m&#39;,aux&#39;)\gets
P^*(pp) :
Verify_{pp}(c,m,aux)=Verify(c,m&#39;,aux&#39;)=Accept\}&lt;\epsilon}
\]</span></p>
<ol start="2" type="1">
<li><p>Open Commitment ( implement <span
class="math inline">\(Verify_{pp}\)</span> )</p>
<p>One general way : let <span class="math inline">\(aux=r\)</span></p>
<p>Verify checks whether <span
class="math inline">\((c,aux)=Commit_{pp}(m,r=aux)\)</span></p>
<blockquote>
<p>There exists faster Verify for some specific problems.</p>
</blockquote></li>
<li><p>Note : hiding and binding are incompatible</p>
<p>hiding : <span class="math inline">\(c\)</span> can from different
<span class="math inline">\(m\)</span></p>
<p>binding : <span class="math inline">\(c\)</span> cannot from
different <span class="math inline">\(m\)</span></p></li>
</ol>
<h3 id="perfect-binding-computationally-hiding-commitment">3.2 Perfect
Binding &amp; Computationally Hiding Commitment</h3>
<ol type="1">
<li><p>DDH assumption</p>
<p><span class="math inline">\(G=\braket g\)</span> , <span
class="math inline">\(|g|=p\)</span> , <span class="math inline">\(p\sim
\kappa\)</span> , The following distributions are computationally
indistinguishable <span class="math display">\[
Dist\{a,b\gets \mathbb Z_p :(g,g^a,g^b,g^{ab})\}
\]</span></p>
<p><span class="math display">\[
Dist\{a,b,c\gets\mathbb Z_p:(g,g^a,g^b,g^c)\}
\]</span></p></li>
<li><p>Construction</p>
<p>Suppose that <span class="math inline">\(m\in G\)</span> <span
class="math display">\[
Gen(1^\kappa)\to(G,p,g)
\]</span></p>
<p><span class="math display">\[
Commit_{pp}(m,(a,b))\to c=(g^a,g^b,mg^{ab}),aux=(a,b)
\]</span></p>
<p><span class="math display">\[
Verify_{pp}(c,m,aux):\text{check }c_1=g^a\land c_2=g^b\land c_3=g^{ab}
\]</span></p></li>
<li><p>Perfect Binding</p>
<p>For <span class="math inline">\(c=(c_1,c_2,c_3)\)</span> , <span
class="math inline">\(\exists \ \)</span> unique <span
class="math inline">\(a,b\)</span> , s.t. <span
class="math inline">\(c_1=g^a,c_2=g^b\)</span> .</p>
<p>Therefore , <span class="math inline">\(m=\frac{c_3}{g^{ab}}\)</span>
, which is uniquely determined</p></li>
<li><p>Computationally Hiding [Prove by Hybrid Proof]</p>
<p>We want to prove that <span class="math display">\[
\{a,b\gets \mathbb Z_p:(g^a,g^b,mg^{ab})\}\sim \{a,b\gets \mathbb
Z_p:(g^a,g^b,m&#39;g^{ab})\}
\]</span></p>
<ol start="0" type="1">
<li><span class="math inline">\(Hyb_0\)</span> : <span
class="math inline">\(a,b\gets \mathbb Z_p
:(g^a,g^b,mg^{ab})\)</span></li>
<li><span class="math inline">\(Hyb_1\)</span> : <span
class="math inline">\(a,b,c\gets \mathbb
Z_p:(g^a,g^b,mg^c)\)</span></li>
<li><span class="math inline">\(Hyb_2\)</span> : <span
class="math inline">\(a,b,c\gets \mathbb
Z_p:(g^a,g^b,m&#39;g^c)\)</span>\</li>
<li><span class="math inline">\(Hyb_3\)</span> : <span
class="math inline">\(a,b,c\gets \mathbb
Z_p:(g^a,g^b,m&#39;g^{ab})\)</span></li>
</ol>
<p><span class="math display">\[
Hyb_0\sim Hyb_1\equiv Hyb_2\sim Hyb_3
\]</span></p></li>
</ol>
<h3 id="computationally-binding-perfect-hiding-commitment">3.3
Computationally Binding &amp; Perfect Hiding Commitment</h3>
<ol type="1">
<li><p>Discrete Log Assumption</p>
<p><span class="math inline">\(G=\braket{g}\)</span> , <span
class="math inline">\(|g|=p\)</span> . <span
class="math inline">\(\forall A\)</span> in P.P.T. , <span
class="math display">\[
\Pr\{a\gets \mathbb Z_p:A(G,p,g,g^a)=a\}&lt;\epsilon
\]</span></p></li>
<li><p>Construction</p>
<p>Suppose that <span class="math inline">\(m\in \mathbb Z_p\)</span>
<span class="math display">\[
Gen(1^\kappa)\to (G,p,g,h=g^a)
\]</span> <span class="math inline">\(a\gets \mathbb Z_p\)</span> , and
we need to "forget" <span class="math inline">\(a\)</span> . <span
class="math display">\[
Commit_{pp}(m,r):r\gets \mathbb Z_p,c=g^rh^m,aux=r
\]</span></p>
<p><span class="math display">\[
Verify_{pp}(c,m,aux):\text{ check } c=g^{aux}h^m
\]</span></p></li>
<li><p>Perfect Hiding</p>
<p><span class="math inline">\(c=g^rh^m\)</span> , which is the same
distribution as <span class="math inline">\(g^r\)</span> , since <span
class="math inline">\(r\)</span> is random .</p></li>
<li><p>Computationally Binding</p>
<p>Suppose that we have P.P.T. <span class="math inline">\(A\)</span>
that <span class="math inline">\(A(G,p,g,h)\to
(c,m,aux,m&#39;,aux&#39;)\)</span> , s.t. <span class="math display">\[
c=g^{aux}h^m=g^{aux&#39;}h^{m&#39;}
\]</span> Therefore : <span class="math display">\[
aux+am=aux&#39;+am&#39;
\]</span> Therefore : <span class="math display">\[
a=\frac{aux-aux&#39;}{m&#39;-m}
\]</span> which contradicts with Discrete Log assumption</p></li>
<li><p>How to generate <span class="math inline">\(h=g^a\)</span></p>
<ul>
<li><p>Generate by Sender ? NO</p>
<p>knows <span class="math inline">\(a\)</span> , then <span
class="math inline">\(c=g^{r+am}\)</span> . Sender can choose proper
<span class="math inline">\(r\)</span> to reconstruct <span
class="math inline">\(m\)</span> .</p></li>
<li><p>Generate by Receiver ? YES</p>
<p>knows <span class="math inline">\(a\)</span> not affect
hiding</p></li>
</ul>
<blockquote>
<p>perfect binding + computationally hiding : Sender runs Gen</p>
<p>computationally binding + perfect hiding : Receiver runs Gen</p>
</blockquote></li>
</ol>
<h3 id="general-np-problem">3.4 General NP Problem</h3>
<ol type="1">
<li><p>NP , NPC</p>
<ol type="1">
<li><p>Def [ <strong><em>NP</em></strong> ] : <span
class="math inline">\(L\in NP\)</span> if <span
class="math inline">\(\exists\ \)</span> poly-time algorithm <span
class="math inline">\(D\)</span> ,</p>
<p><span class="math inline">\(x\in L\Leftrightarrow \exists w\ ,\
D(x,w)=1\)</span></p>
<p><span class="math inline">\(w\)</span> is called the proof .</p></li>
<li><p>Def [ <strong><em>NP-Complete</em></strong> ] : <span
class="math inline">\(L&#39;\in NP-Complete\)</span> if <span
class="math inline">\(\forall L\in NP\)</span> , <span
class="math inline">\(\exists\ \)</span> poly-time algorithm <span
class="math inline">\(Q\)</span> , s.t.</p>
<p><span class="math inline">\(Q(x,w)=(x&#39;,w&#39;)\)</span> , and
<span class="math inline">\(x\in L\equiv x&#39;\in L&#39;\)</span> .</p>
<p>i.e. all NP problems can be poly-reducible to NP-Complete
Problem</p></li>
</ol></li>
<li><p>Graph Hamiltonicity</p>
<ol type="1">
<li><p>Def [ <strong><em>Hamiltonian</em></strong> ] : A graph <span
class="math inline">\(G\)</span> is
<strong><em>Hamiltonian</em></strong> , if there exists a cycle visiting
each node exactly once.</p></li>
<li><p>Construct zk-proof for Graph Hamiltonicity</p>
<ol type="1">
<li><p>Like GI :</p>
<p>Step 1 : send <span class="math inline">\(\tilde G\)</span> , where
<span class="math inline">\(G\sim \tilde G\)</span></p>
<p>Step 2 : give a cycle of <span class="math inline">\(\tilde
G\)</span> to prove its Hamiltonian</p>
<p>Traditional ways : we cannot realize both</p></li>
<li><p>Protocol with commitment</p></li>
</ol>
<p>Commitment of a graph <span class="math inline">\(G\)</span> : <span
class="math inline">\(\forall i,j\in [n]\)</span> , <span
class="math display">\[
(c_{i,j},aux_{i,j})\gets\begin{cases}
Commit_{pp}(1,r)&amp;(i,j)\in E\\
Commit_{pp}(0,r)&amp;(i,j)\notin E
\end{cases}
\]</span></p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 46%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\pi\gets
S_n\)</span> , <span class="math inline">\(\tilde
G:=\pi(G)\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">Commit <span
class="math inline">\(\tilde G\)</span> :</td>
<td style="text-align: center;">---<span
class="math inline">\(c_{i,j}\)</span>--&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;--<span
class="math inline">\(b\)</span>---</td>
<td style="text-align: center;"><span class="math inline">\(b\gets
\{0,1\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">If <span
class="math inline">\(b=0\)</span></td>
<td style="text-align: center;">---<span
class="math inline">\(\pi,m_{i,j},aux_{i,j}\)</span>--&gt;</td>
<td style="text-align: center;">Checks <span
class="math inline">\(\tilde G=\pi(G)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">If <span
class="math inline">\(b=1\)</span></td>
<td style="text-align: center;">---cycle for <span
class="math inline">\(\tilde G\)</span> , <span
class="math inline">\(m_{i,j},aux_{i,j}\)</span> in cycle---&gt;</td>
<td style="text-align: center;">Checks cycle and edges existence</td>
</tr>
</tbody>
</table></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>零知识证明和多方安全计算</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>密码学-证明复合</tag>
        <tag>密码学-证明复合引理</tag>
        <tag>密码学-承诺</tag>
        <tag>密码学-密码学假设-DDH假设</tag>
        <tag>密码学-密码学假设-离散对数假设</tag>
        <tag>密码学-承诺实现零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 5</title>
    <url>/2023/10/16/Algorithm-Design-5/</url>
    <content><![CDATA[<h2 id="chapter-3-dynamic-programming">Chapter 3 Dynamic
Programming</h2>
<h3 id="treewidth-cond.">3.4.2 Treewidth cond.</h3>
<p>Extension : [ Roberson , Seymour ] [ <strong><em>Graph Minor
THM</em></strong> ]</p>
<blockquote>
<p>1983 - 2004 , 20 papers , 500 pages</p>
</blockquote>
<ol type="1">
<li><p>Def [ <strong><em>Minor</em></strong> ] : a minor of <span
class="math inline">\(G\)</span> can be obtained by contracting edges
and deletion of nodes/edges from <span
class="math inline">\(G\)</span></p>
<p>contract edge : <span class="math inline">\(e=\{u,v\}\)</span> ,
contract it : then merge <span class="math inline">\({u,v}\)</span> as a
new vertex .</p></li>
<li><p>Def [ <strong><em>Minor-closed</em></strong> ] : A graph family
<span class="math inline">\(\mathcal F\)</span> of graph is
<strong><em>minor-closed</em></strong> if <span
class="math inline">\(\forall G\in \mathcal F\)</span> , the minor of
<span class="math inline">\(G\in \mathcal F\)</span></p>
<p>E.g. : <span class="math inline">\(\mathcal
F=\{\text{forests}\}\)</span> , <span class="math inline">\(\mathcal
F=\{\text{planar graph}\}\)</span> , <span
class="math inline">\(\mathcal F=\{\text{graphs with }tw\le k\}\)</span>
are all minor-closed</p></li>
<li><p>Thm [ <strong><em>Wagner-Kuratowski THM</em></strong> ] : planar
graph <span class="math inline">\(\Leftrightarrow\)</span> no <span
class="math inline">\(K_{3,3} , K_5\)</span> as minors</p>
<p>Likewise : forests <span
class="math inline">\(\Leftrightarrow\)</span> no <span
class="math inline">\(K_3\)</span> as minors</p></li>
<li><p>Thm [ <strong><em>Graph Minor THM</em></strong> ] : a
minor-closed family <span class="math inline">\(\Leftrightarrow\)</span>
no <span class="math inline">\(H\)</span> as minors , <span
class="math inline">\(H\)</span> is a finite graph set</p></li>
<li><p>Application : Fixed Parameter Tractable</p></li>
</ol>
<h3 id="shortest-path-bellman-ford">3.5 Shortest Path
(Bellman-Ford)</h3>
<ol type="1">
<li><p>Description</p>
<p>directed graph <span class="math inline">\(G=(V,E)\)</span> , <span
class="math inline">\(w_e\in \mathbb R\)</span> , <span
class="math inline">\(G\)</span> has no negative cycle . ( not
necessarily <span class="math inline">\(w_e\ge 0\)</span> )</p>
<p>Find shortest path for all vertices to <span
class="math inline">\(t\)</span> .</p></li>
<li><p>Algorithm</p>
<p><span class="math inline">\(opt(i,v)\)</span> : using at most <span
class="math inline">\(i\)</span> edges , the shortest path from <span
class="math inline">\(v\)</span> to <span
class="math inline">\(t\)</span> . <span class="math display">\[
opt(i,v)=\min\begin{cases}
opt(i-1,v)\\
\min_u\{opt(i-1,u)+w_{v\to u}\}
\end{cases}
\]</span> Time Complexity : <span class="math inline">\(\mathcal
O(nm)\)</span> .</p>
<p>Memory Complexity : <span class="math inline">\(\mathcal
O(n^2)\)</span> . ( at most using <span
class="math inline">\(n-1\)</span> edges )</p></li>
<li><p>Optimize Memory Complexity <span class="math display">\[
opt(v)=\min\begin{cases}
opt(v)\\
\min_{(v,u)\in E}\{opt(u)+w_{v\to u}\}
\end{cases}
\]</span> Iterate the update <span class="math inline">\(n\)</span>
times .</p>
<blockquote>
<p>Note : may using <span class="math inline">\(opt(i,u)\)</span> , but
we do not care about the really number of edges in the shortest path
.</p>
</blockquote>
<blockquote>
<p>Observation : After <span class="math inline">\(i\)</span> iterations
, <span class="math inline">\(opt(v)\)</span> is not larger than <span
class="math inline">\(opt(i,v)\)</span></p>
</blockquote></li>
<li><p>Find the Shortest Path</p>
<p>Construct a pointer graph <span
class="math inline">\(P=\{(v,first[v])|v\in V\backslash\{t\}\}\)</span>
:</p>
<p><span class="math inline">\(\forall v\in V\)</span> , <span
class="math inline">\(first[v]\)</span> : the first node on the <span
class="math inline">\(v\to t\)</span> path after <span
class="math inline">\(v\)</span> .</p>
<p>Compute <span class="math inline">\(first[v]\)</span> : When <span
class="math inline">\(opt(v)\)</span> is updated by <span
class="math inline">\(opt(u)+w_{v\to u}\)</span> , let <span
class="math inline">\(first[v]=u\)</span> .</p>
<blockquote>
<p>Observation : After all iterations , <span
class="math inline">\(\{(v,first[v])|v\in V\backslash \{t\}\}\)</span>
forms a shortest path tree .</p>
</blockquote></li>
<li><p>Lemma 1 : Suppose <span class="math inline">\(G\)</span> has no
negative cycle . At the termination of the algorithm , <span
class="math inline">\(P\)</span> is the a shortest path tree rooted at
<span class="math inline">\(t\)</span> .</p>
<p>Proof : [ Induction like ]</p>
<p>If <span class="math inline">\(first[v]=u\)</span> , then <span
class="math inline">\(opt(v)=opt(u)+w_{v\to u}\)</span></p>
<p><span class="math inline">\(opt(u)\)</span> is the shortest <span
class="math inline">\(u\to t\)</span> path . Therefore , the cost of
<span class="math inline">\(u\to t\)</span> path on <span
class="math inline">\(P\)</span> is smallest . Therefore , the cost of
<span class="math inline">\(v\to t\)</span> path on <span
class="math inline">\(P\)</span> is smallest .</p></li>
<li><p>Lemma 2 : If <span class="math inline">\(P\)</span> contains a
cycle <span class="math inline">\(C\)</span> at any stage , then <span
class="math inline">\(cost(C)&lt;0\)</span></p>
<p>Proof : Let <span
class="math inline">\(C=\{v_1,v_2,\cdots,v_k\}\)</span> .</p>
<p>If <span class="math inline">\(first[v]=u\)</span> , then <span
class="math inline">\(opt(v)\ge w_{v\to u} +opt(u)\)</span> .</p>
<blockquote>
<p>If <span class="math inline">\(opt(v)&lt;w_{v\to u}+opt(u)\)</span> ,
then <span class="math inline">\(v\)</span> is updated by other <span
class="math inline">\(u&#39;\)</span> , so <span
class="math inline">\(first[v]\neq u\)</span> .</p>
</blockquote>
<p>Therefore , <span class="math inline">\(opt(v_1)\ge w_{v_1\to
v_2}+opt(v_2)\)</span> , <span class="math inline">\(opt(v_2)\ge
w_{v_2\to v_3}+opt(v_3)\)</span> , <span
class="math inline">\(\cdots\)</span> , <span
class="math inline">\(opt(v_k)\ge w_{v_k \to v_1} +opt(v_1)\)</span>
.</p>
<p>Therefore , <span class="math inline">\(cost(C)=\sum_{i=1}^k
w_{v_i\to v_{i+1}}\le 0\)</span> .</p>
<p>Consider the time before we update the last cycle edge , suppose that
it is <span class="math inline">\(v_k\to v_1\)</span> .</p>
<p>Therefore , exactly before the update , <span
class="math inline">\(opt(v_k)&gt;w_{v_k\to v_1}+opt(v_1)\)</span> , so
at this time the inequality is strict .</p></li>
<li><p>Note : If exists negative cycle , there may still exist finite
shortest-path vertices and <span class="math inline">\(+\infty\)</span>
shortest-path vertices .</p></li>
</ol>
<h2 id="chapter-4-np-completeness">Chapter 4 NP Completeness</h2>
<ol type="1">
<li><p>[ Cook , Karp ]</p>
<p><span class="math inline">\(NPC\subset NP\)</span> , poly-time
reduction</p>
<p><span class="math inline">\(P\neq NP\)</span> conjecture</p></li>
</ol>
<h3 id="polynomial-time-reduction">4.1 Polynomial Time Reduction</h3>
<ol type="1">
<li><p>using poly-time as measure ?</p>
<p>different computation model can have different power constant ( <span
class="math inline">\(\mathcal O(n^2,n^3,\cdots)\)</span> )</p></li>
<li><p>Def [ <strong><em>polynomial-time reduction</em></strong> ] : If
a problem <span class="math inline">\(Y\)</span> can be solved in
poly-time plus an oracle that solves problem <span
class="math inline">\(X\)</span> , then <span
class="math inline">\(Y\)</span> is <strong><em>poly-time
reducible</em></strong> to <span class="math inline">\(X\)</span> ,
denote as <span class="math inline">\(Y\le_P X\)</span> .</p>
<ol type="1">
<li><p>Def [ <strong><em>oracle</em></strong> ] : an oracle for <span
class="math inline">\(X\)</span> is a "black-box" , input an instance of
<span class="math inline">\(X\)</span> and can output the answer in
<span class="math inline">\(\mathcal O(1)\)</span> time .</p>
<blockquote>
<p>Even if <span class="math inline">\(X\)</span> itself cannot be
solved in <span class="math inline">\(\mathcal O(1)\)</span> .</p>
</blockquote></li>
<li><p><span class="math inline">\(Y\le _P X\)</span> : <span
class="math inline">\(X\)</span> is more powerful than <span
class="math inline">\(Y\)</span> ( i.e. <span
class="math inline">\(Y\)</span> is not harder than <span
class="math inline">\(X\)</span> )</p></li>
</ol></li>
<li><p>Properties</p>
<ol type="1">
<li>If <span class="math inline">\(Y\le_P X\)</span> , <span
class="math inline">\(X\)</span> is poly-solvable , then <span
class="math inline">\(Y\)</span> is poly-solvable</li>
<li>If <span class="math inline">\(Y\le_P X\)</span> , <span
class="math inline">\(Y\)</span> cannot be solved in poly-time , then
<span class="math inline">\(X\)</span> cannot be solved in
poly-time</li>
</ol></li>
<li><p>[ Cook , Karp ] :</p>
<p>Intuitive : If <span class="math inline">\(Y\le_P X\)</span> , then
connect a directed edge <span class="math inline">\(Y\to X\)</span> .
Then there exists a class of Problems <span
class="math inline">\(\mathcal C\)</span> . <span
class="math inline">\(\forall C\in \mathcal C,\forall X\in \mathcal
P\)</span> , there exists a directed edge <span
class="math inline">\(X\to C\)</span> .</p></li>
</ol>
<h3 id="examples-of-poly-reduction">4.2 Examples of Poly-reduction</h3>
<ol type="1">
<li><p>Independent Set Problem</p>
<p><span class="math inline">\(IS=(G(V,E),k)\)</span> .</p>
<p>Independent set : <span class="math inline">\(I\subseteq V\)</span> ,
s.t. <span class="math inline">\(\forall u,v\in I,(u,v)\notin E\)</span>
.</p>
<p>Ask whether there exists an Independent Set of size at least <span
class="math inline">\(k\)</span> .</p></li>
<li><p>Vertex Cover Problem</p>
<p><span class="math inline">\(VC=(G(V,E),h)\)</span> .</p>
<p>Vertex Cover : <span class="math inline">\(C\subseteq V\)</span> ,
s.t. <span class="math inline">\(\forall (u,v)\in E\)</span> , either
<span class="math inline">\(u\in C\)</span> or <span
class="math inline">\(v\in C\)</span> .</p>
<p>Ask whether there exists a Vertex Cover of size at most <span
class="math inline">\(h\)</span> .</p></li>
<li><p><span class="math inline">\(IS\le_P VC\)</span></p>
<p>Lemma : <span class="math inline">\(I\)</span> is an Independent Set
<span class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(V\backslash I\)</span> is a Vertex Cover</p></li>
<li><p>Set Cover Problem</p>
<p><span class="math inline">\(SC=(U,\{S_1,\cdots,S_m\},h)\)</span>
.</p>
<p><span class="math inline">\(U\)</span> : universe . <span
class="math inline">\(S_1,\cdots,S_m\subseteq U\)</span> .</p>
<p>Set Cover : <span class="math inline">\(I\subseteq [m]\)</span> ,
s.t. <span class="math inline">\(\bigcup_{i\in I}S_i=U\)</span> .</p>
<p>Ask whether there exists a Set Cover of size at most <span
class="math inline">\(h\)</span> .</p></li>
<li><p><span class="math inline">\(VC\le_P SC\)</span></p>
<p>Let <span class="math inline">\(S_i=\{e\in E|i\in e\}\)</span> ,
<span class="math inline">\(U=E\)</span> .</p></li>
</ol>
<h3 id="np-complete-problem">4.3 NP-Complete Problem</h3>
<ol type="1">
<li><p>Def [ <strong><em>NP</em></strong> ] : Only consider decision
problems ( output Y/N )</p>
<p>A decision problem <span class="math inline">\(X\)</span> , we can
consider <span class="math inline">\(X\)</span> as a collection of YES
instances.</p>
<ol type="1">
<li><p>Def [ <strong><em>Efficient Verifier</em></strong> ] : <span
class="math inline">\(V(x,\pi)\)</span> is an <strong><em>efficient
verifier</em></strong> for problem <span
class="math inline">\(X\)</span> if</p>
<ul>
<li><p><span class="math inline">\(V\)</span> is a poly-time algorithm
with <span class="math inline">\(x\)</span> and <span
class="math inline">\(\pi\)</span></p></li>
<li><p><span class="math inline">\(x\in X\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\exists \pi , |\pi|\le poly(|x|) ,
V(x,\pi)=1\)</span></p></li>
</ul>
<p><span class="math inline">\(\pi\)</span> : certificate /
proof</p></li>
<li><p>Def [ <strong><em>P</em></strong> ] : The class of all problems
<span class="math inline">\(X\)</span> , s.t. there exists a poly-time
algorithm that solves <span class="math inline">\(X\)</span> .</p></li>
<li><p>Def [ <strong><em>NP</em></strong> ] : The class of all problems
<span class="math inline">\(X\)</span> , s.t. there exists an efficient
verifier for <span class="math inline">\(X\)</span> .</p></li>
</ol></li>
<li><p>Def [ <strong><em>NP-Complete</em></strong> ] : A problem <span
class="math inline">\(X\)</span> is <strong><em>NPC</em></strong> if</p>
<ul>
<li><span class="math inline">\(X\in NP\)</span></li>
<li><span class="math inline">\(\forall Y\in NP\)</span> , <span
class="math inline">\(Y\le_P X\)</span></li>
</ul></li>
<li><p>Properties of NPC</p>
<ol type="1">
<li><span class="math inline">\(\forall X\in NPC\)</span> , if <span
class="math inline">\(X\in P\)</span> , then <span
class="math inline">\(P=NP\)</span></li>
<li><span class="math inline">\(\forall X,Y\in NPC\)</span> , <span
class="math inline">\(X\le_P Y\)</span> and <span
class="math inline">\(Y\le_P X\)</span></li>
</ol></li>
<li><p>Thm [ Cook-Levin 1971 , the first NPC problem ] : SAT is NPC</p>
<ol type="1">
<li><p>Def [ <strong><em>SAT</em></strong> ] : a formula <span
class="math inline">\(F\)</span> of <span
class="math inline">\(0/1\)</span> variables <span
class="math inline">\(\{x_n\}\)</span> and <span
class="math inline">\(\land,\lor,\lnot\)</span> .</p>
<p>Fix some variables , determine whether there exists an assignment of
<span class="math inline">\(\{x_n\}\)</span> s.t. <span
class="math inline">\(F=true\)</span> .</p></li>
<li><p>Proof ( high-level sketch )</p>
<p>SAT <span class="math inline">\(\in\)</span> NP : given an assignment
, can verify</p>
<p><span class="math inline">\(\forall X\in NP,X\le_P SAT\)</span> :</p>
<p>efficient verifier for <span class="math inline">\(X\)</span> : can
be write as logic-circuit form</p>
<p><span class="math inline">\(V(x,\pi)\)</span> : <span
class="math inline">\(x\)</span> as fixed , <span
class="math inline">\(\pi\)</span> as assignment .</p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-图论-treewidth</tag>
        <tag>算法-图论-minor graph</tag>
        <tag>算法-图论-最短路(Bellman Ford)</tag>
        <tag>计算理论-多项式规约</tag>
        <tag>计算理论-P,NP,NPC</tag>
        <tag>计算理论-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>ZKP and MPC 2</title>
    <url>/2023/10/15/ZKP-and-MPC-2/</url>
    <content><![CDATA[<h2 id="lec02-zero-knowledge-proof-under-composition">Lec02
Zero-Knowledge Proof under Composition</h2>
<h3 id="review-of-interactive-proof">2.1 Review of Interactive
Proof</h3>
<ol type="1">
<li><p>Interactive Proof</p>
<ol type="1">
<li><p>Framework</p>
<p>Prover <span class="math inline">\(P\)</span>, Verifier <span
class="math inline">\(V\)</span> . <span
class="math inline">\(P,V\)</span> knows <span
class="math inline">\(x\)</span> .</p>
<p><span class="math inline">\(P\)</span> wants to convince <span
class="math inline">\(V\)</span> that <span class="math inline">\(x\in
L\)</span> with interaction .</p>
<p><span class="math inline">\(P,V\)</span> sends messages <span
class="math inline">\(m_1,m_2,\cdots,m_k\)</span> one by one , then
<span class="math inline">\(V\)</span> accept/reject whether <span
class="math inline">\(x\in L\)</span> .</p>
<p><span class="math inline">\(\braket{P,V}(x)=y\in \{0,1\}\)</span> ,
indicating whether <span class="math inline">\(x\in L\)</span> .</p>
<p><strong><em>transcript</em></strong> : <span
class="math inline">\(\tau=\{m_1,m_2,\cdots,m_k\}\)</span> .</p></li>
<li><p>Formal Definition</p>
<p><span class="math inline">\((P,V)\)</span> is an
<strong><em>interactive proof</em></strong> for <span
class="math inline">\(L\)</span> if</p>
<ul>
<li><span class="math inline">\(V\)</span> is an efficient algorithm (
poly-time )</li>
<li><strong><em>Completeness</em></strong> : <span
class="math inline">\(\forall x\in
L,\Pr\{\braket{P,V}(x)=1\}=1\)</span></li>
<li><strong><em>(Almost) Soundness</em></strong> : <span
class="math inline">\(\forall x\notin L,\forall
P^*,\Pr\{\braket{P^*,V}(x)=1\}&lt;\epsilon\)</span></li>
</ul></li>
</ol></li>
<li><p>Error Toleration</p>
<ol type="1">
<li><p>Security parameter : <span
class="math inline">\(\kappa\)</span></p></li>
<li><p>For Efficiency : <span
class="math inline">\(|x|=poly(\kappa)\)</span></p></li>
<li><p>For Security</p>
<ul>
<li><p>Def [<strong><em>Negligible Function</em></strong>] <span
class="math inline">\(\epsilon:\mathbb N\to \mathbb R^*\)</span> is
<strong><em>negligible</em></strong> if for all positive polynomial
<span class="math inline">\(p\)</span> , <span
class="math inline">\(\exists c\)</span> , s.t. <span
class="math inline">\(\forall k\ge
c,\epsilon(k)&lt;\frac{1}{p(k)}\)</span></p></li>
<li><p>Def [<strong><em>Statistically Indistinguishable</em></strong>] :
two distribution <span class="math inline">\(f,g\)</span> are
<strong><em>statistically indistinguishable</em></strong> if there
exists a negligible function <span
class="math inline">\(\epsilon\)</span> that : <span
class="math display">\[
SD(f(x),g(x))=\frac{1}{2}\sum_{s}\left|\Pr\{f(x)=s\}-\Pr\{g(x)=s\}\right|&lt;\epsilon
\]</span></p></li>
<li><p>Def [<strong><em>Computationally Indistinguishable</em></strong>]
: two distribution <span class="math inline">\(f,g\)</span> are
<strong><em>computationally indistinguishable</em></strong> if <span
class="math inline">\(\forall D\)</span> (distinguisher) in P.P.T ,
there exists a negligible function <span
class="math inline">\(\epsilon\)</span> that : <span
class="math display">\[
\left|\Pr\left\{D\big(f(x)\big)=1\right\}-\Pr\left\{D\big(g(x)\big)=1\right\}\right|&lt;\epsilon
\]</span></p></li>
</ul></li>
</ol></li>
<li><p>Zero Knowledge</p>
<ol type="1">
<li><p>Intuition : not gain of <strong>Knowledge</strong></p>
<blockquote>
<p>Everything can be <strong>computed locally</strong> is not a gain of
knowledge</p>
</blockquote></li>
<li><p>Def [<strong><em>View</em></strong>] : <span
class="math display">\[
View_V^P(x)=(x,r,\tau)
\]</span></p></li>
<li><p>Def [<strong><em>dishonest-verifier zero-knowledge</em></strong>]
: <span class="math inline">\((P,V)\)</span> is an IP for <span
class="math inline">\(L\)</span> . If <span
class="math inline">\((P,V)\)</span> achieves
perfect/statistical/computational <strong><em>dishonest-verifier
zero-knowledge</em></strong> , it satisfies that :</p>
<p><span class="math inline">\(\forall V^*\)</span> in P.P.T. , <span
class="math inline">\(\exists \ \)</span> expected poly-time randomized
algorithm <span class="math inline">\(M^*\)</span> , s.t. <span
class="math display">\[
\forall x\in L,M^*(x)\sim View_{V^*}^P(x)
\]</span> <span class="math inline">\(\sim\)</span> refers to equivalent
/ statistically indistinguishable / computationally
indistinguishable</p></li>
<li><p>Alternative definition of zero-knowledge :</p>
<p><span class="math inline">\(\forall V^*\)</span> in P.P.T. , <span
class="math inline">\(\exists\ \)</span> expected poly-time randomized
algorithm <span class="math inline">\(M^*\)</span> , s.t. <span
class="math display">\[
\forall x\in L,\braket{P,V^*}(x)\sim M^*(x)
\]</span></p>
<blockquote>
<p><em>Proof of Equivalence</em></p>
<p>Original <span class="math inline">\(\to\)</span> Alternative : The
output of <span class="math inline">\(V^*\)</span> only depends on its
view . If <span class="math inline">\(M^*\)</span> can simulate the view
of <span class="math inline">\(V^*\)</span> , then it can run <span
class="math inline">\(V^*\)</span> with the view , and get the output of
<span class="math inline">\(V^*\)</span> .</p>
<p>Alternative <span class="math inline">\(\to\)</span> Original : The
proposition holds for all <span class="math inline">\(V^*\)</span> (
which can violate the protocol ) , so if <span
class="math inline">\(V^*\)</span> just output its entire view , we
still need to be able to find the corresponding <span
class="math inline">\(M^*\)</span> , this means the ability to simulate
the view of <span class="math inline">\(V^*\)</span> .</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="interactive-proof-for-graph-isomorphism">2.2 Interactive Proof
for Graph Isomorphism</h3>
<ol type="1">
<li><p>Protocol</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 12%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\pi_r\leftarrow S_n\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\tilde
G:=\pi_r(G_0)\)</span></td>
<td style="text-align: center;">--<span class="math inline">\(\tilde
G\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;-<span
class="math inline">\(b\)</span>--</td>
<td style="text-align: center;"><span class="math inline">\(b\leftarrow
\{0,1\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">find <span
class="math inline">\(\pi_b\)</span> , s.t. <span
class="math inline">\(\tilde G=\pi_b(G_b)\)</span></td>
<td style="text-align: center;">--<span
class="math inline">\(\pi_b\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;\tilde
G=\pi_b(G_b)\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note : If Prover knows <span class="math inline">\(\pi\)</span> that
<span class="math inline">\(\pi(G_0)=G_1\)</span> , then <span
class="math inline">\(\pi_b\)</span> can be constructed : <span
class="math display">\[
\pi_b=\begin{cases}\pi_r&amp;b=0\\\pi_r\circ\pi^{-1}&amp;b=1\end{cases}
\]</span></p>
</blockquote></li>
<li><p>Completeness : By construction of <span
class="math inline">\(\pi_b\)</span> above , <span
class="math inline">\(\Pr\{V\text{ accepts}\}=1\)</span> .</p></li>
<li><p>Soundness : <span class="math inline">\(\forall \tilde G\)</span>
, if <span class="math inline">\(G_0\not\sim G_1\)</span> , then either
<span class="math inline">\(\tilde G\not\sim G_0\)</span> , or <span
class="math inline">\(\tilde G\not\sim G_1\)</span> ,</p>
<p>If <span class="math inline">\(\tilde G\not\sim G_{b^*}\)</span> ,
then <span class="math inline">\(\Pr\{V\text{ rejects}\}\ge
\Pr\{b=b^*\}=\frac{1}{2}\)</span></p>
<blockquote>
<p>Note : we cannot let Verifier just choose <span
class="math inline">\(b=1\)</span> , since a malicious Prover can
violate the protocol , <span class="math inline">\(\pi_r\)</span> may
not be a permutation , and <span class="math inline">\(\tilde G\)</span>
may not isomorphic to <span class="math inline">\(G_0\)</span> .</p>
</blockquote>
<p>Repeat <span class="math inline">\(k\)</span> times , <span
class="math inline">\(\Pr\{V\text{ rejects}\}\ge
1-\frac{1}{2^k}\)</span> .</p></li>
<li><p>Honest-Verifier Zero-Knowledge : <span
class="math inline">\(P,V\)</span> follows the protocol .</p>
<p>In <span class="math inline">\(View_V^P\)</span> , the additional
info is <span class="math inline">\(\tilde G,\pi_b\)</span> , which are
both randomly picked s.t. <span class="math inline">\(\pi_b(G_b)=\tilde
G\)</span> .</p>
<p><span class="math inline">\(M\)</span> : samples <span
class="math inline">\(b\gets\{0,1\}\)</span> , samples <span
class="math inline">\(\pi_b\gets S_n\)</span> , computes <span
class="math inline">\(\tilde G=\pi_b(G_b)\)</span> .</p></li>
<li><p>Dishonest-Verifier Zero-Knowledge : <span
class="math inline">\(V^*\)</span> may not follow the protocol : <span
class="math inline">\(b\)</span> may be chosen depends on <span
class="math inline">\(\tilde G\)</span> .</p>
<p><span class="math inline">\(M^*\)</span> : perform as <span
class="math inline">\(P\)</span> (but without knowing <span
class="math inline">\(\pi\)</span>)</p>
<ol type="1">
<li><p><em>Strategy</em> :</p>
<ol type="1">
<li><p><span class="math inline">\(M^*\)</span> samples <span
class="math inline">\(b^*\gets \{0,1\}\)</span> ,samples <span
class="math inline">\(\pi_{b^*}\gets S_n\)</span> , computes <span
class="math inline">\(\tilde G=\pi_{b^*}(G_{b^*})\)</span></p></li>
<li><p><span class="math inline">\(M^*\)</span> runs with <span
class="math inline">\(V^*\)</span> and obtains <span
class="math inline">\(b\)</span> .</p></li>
<li><p>If <span class="math inline">\(b^*=b\)</span> , reply <span
class="math inline">\(\pi_{b^*}\)</span> and find out the view .</p>
<p>If <span class="math inline">\(b^*\neq b\)</span> , go back to
(1).</p></li>
</ol></li>
<li><p>Prove <span class="math inline">\(M^*(x)\equiv
View_{V^*}^P(x)\)</span> :</p>
<p><em>Proof Strategy</em> : <strong><em>Hybrid Arguments</em></strong>
: make sure that every two adjacent <span
class="math inline">\(Hyb\)</span> are so near .</p>
<ol start="0" type="1">
<li><p><span class="math inline">\(Hyb_0\)</span> : <span
class="math inline">\(P\)</span> runs with <span
class="math inline">\(V^*\)</span> , output <span
class="math inline">\(View_{V^*}^P(x)\)</span></p></li>
<li><p><span class="math inline">\(Hyb_1\)</span> : <span
class="math inline">\(\tilde P\)</span> runs with <span
class="math inline">\(V^*\)</span> , receives <span
class="math inline">\(b\)</span> . Then <span
class="math inline">\(\tilde P\)</span> samples <span
class="math inline">\(b^*\gets \{0,1\}\)</span></p>
<p>If <span class="math inline">\(b^*=b\)</span> , <span
class="math inline">\(\tilde P\)</span> continues with <span
class="math inline">\(V^*\)</span> . Otherwise , <span
class="math inline">\(\tilde P\)</span> reruns with <span
class="math inline">\(V^*\)</span> .</p>
<ul>
<li><span class="math inline">\(\mathbb E\{\text{repitition
time}\}=2\)</span></li>
<li><span class="math inline">\(View_{V^*}^P(x)\equiv View_{V^*}^{\tilde
P}(x)\)</span></li>
</ul>
<blockquote>
<p>Proof : <span class="math inline">\(\forall v\)</span> , compute
<span class="math inline">\(\Pr\{View_{V^*}^{\tilde
P}(x)=v\}\)</span></p>
<p>Define <span class="math inline">\(v_i\)</span> : view of <span
class="math inline">\(V^*\)</span> in the <span
class="math inline">\(i\)</span>-th iteration</p>
<p>If <span class="math inline">\(\tilde P\)</span> exactly finishes at
<span class="math inline">\(i\)</span>-th iteration , then <span
class="math inline">\(v_i\equiv View_{V^*}^{P}(x)\)</span> <span
class="math display">\[
\begin{aligned}
\Pr\{View_{V^*}^{\tilde P}(x)=v\}&amp;=\sum_{l=1}^{+\infty}
\Pr\{v_l=v\land b_l^*=b_l\land \forall i&lt;l,b_i^*\neq b_i\}\\
&amp;=\sum_{l=1}^{+\infty}\Pr\{v_l=v\}\Pr\{b_l^*=b_l\land \forall
i&lt;l,b_i^*\neq b_i\}\\
&amp;=\Pr\{View_{V^*}^P(x)=v\}\sum_{l=1}^{+\infty}\Pr\{b_l^*=b_l\land
\forall i&lt;l,b_i^*\neq b_i\}\\
&amp;=\Pr\{View_{V^*}^P(x)=v\}
\end{aligned}
\]</span></p>
</blockquote></li>
<li><p><span class="math inline">\(Hyb_2\)</span> : <span
class="math inline">\(\tilde P\)</span> samples <span
class="math inline">\(b^*\gets \{0,1\}\)</span> . Then <span
class="math inline">\(\tilde P\)</span> runs with <span
class="math inline">\(V^*\)</span> , receives <span
class="math inline">\(b\)</span> .</p>
<p>If <span class="math inline">\(b^*=b\)</span> , <span
class="math inline">\(\tilde P\)</span> continues with <span
class="math inline">\(V^*\)</span> . Otherwise , <span
class="math inline">\(\tilde P\)</span> reruns with <span
class="math inline">\(V^*\)</span> .</p>
<ul>
<li><span class="math inline">\(\mathbb E\{\text{repitition
time}\}=2\)</span></li>
<li><span class="math inline">\(Hyb_1\equiv Hyb_2\)</span> ( Since we
only swap two independent operations )</li>
</ul></li>
<li><p><span class="math inline">\(Hyb_3\)</span> : <span
class="math inline">\(\tilde P\)</span> samples <span
class="math inline">\(b^*\gets\{0,1\}\)</span> . Then <span
class="math inline">\(\tilde P\)</span> samples <span
class="math inline">\(\pi_{b^*}\)</span> and computes <span
class="math inline">\(\tilde G=\pi_{b^*}(G_{b^*})\)</span> . Then <span
class="math inline">\(\tilde P\)</span> runs with <span
class="math inline">\(V^*\)</span> , receives <span
class="math inline">\(b\)</span> .</p></li>
</ol>
<p>If <span class="math inline">\(b^*=b\)</span> , <span
class="math inline">\(\tilde P\)</span> continues with <span
class="math inline">\(V^*\)</span> . Otherwise , <span
class="math inline">\(\tilde P\)</span> reruns with <span
class="math inline">\(V^*\)</span> .</p>
<ul>
<li><span class="math inline">\(\mathbb E\{\text{repitition
time}\}=2\)</span></li>
<li><span class="math inline">\(Hyb_2\equiv Hyb_3\)</span> ( Since the
distribution of <span class="math inline">\((\pi_{b^*},\tilde
G)\)</span> is the same )</li>
<li><span class="math inline">\(Hyb_3\)</span> is exactly <span
class="math inline">\(M^*\)</span></li>
</ul></li>
</ol></li>
<li><p>Zero-knowledge under Repetition (for soundness)</p>
<ol type="1">
<li><p>Def [<strong><em>parallel composition</em></strong>] :</p>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 23%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\pi_r^i\leftarrow S_n\)</span> for <span
class="math inline">\(i\in [\kappa]\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\tilde
{G^i}:=\pi_r^i(G_0)\)</span> for <span class="math inline">\(i\in
[\kappa]\)</span></td>
<td style="text-align: center;">--<span class="math inline">\(\{\tilde
{G^i}|i\in [\kappa]\}\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;-<span
class="math inline">\(b\)</span>--</td>
<td style="text-align: center;"><span class="math inline">\(b\leftarrow
\{0,1\}^\kappa\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">find <span
class="math inline">\(\pi_b^i\)</span> , s.t. <span
class="math inline">\(\tilde {G^i}=\pi_{b}^i(G_{b_i})\)</span></td>
<td style="text-align: center;">--<span
class="math inline">\(\{\pi_b^i|i\in [\kappa]\}\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;\forall i\in [\kappa],\tilde
{G^i}=\pi_b^i(G_{b_i})\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Brute force simulator :</p>
<p>randomly sample <span
class="math inline">\(b^*\gets\{0,1\}^\kappa\)</span> , if received
<span class="math inline">\(b\neq b^*\)</span> , rerun .</p>
<p>Good : <span class="math inline">\(M^*(x)\equiv
View_{V^*}^P(x)\)</span></p>
<p>Bad : <span class="math inline">\(\mathbb E\{\text{repitition
time}\}=2^{\kappa}\)</span></p></li>
</ol>
<blockquote>
<p>For most ZKP , we don't know how to prove <em>dishonest-verifier
zero-knowledge</em> under parallel composition .</p>
</blockquote></li>
</ol>
<h3 id="sequential-composition">2.3 Sequential Composition</h3>
<ol type="1">
<li><p>Def [<strong><em>sequential composition</em></strong>] : <span
class="math inline">\((P,V)\)</span> is an IP for <span
class="math inline">\(L\)</span> , Let <span
class="math inline">\((P_q,V_q)\)</span> be <span
class="math inline">\((P,V)\)</span> repeat <span
class="math inline">\(q\)</span> times .</p></li>
<li><p>Brute force simulator for Graph Isomorphism :</p>
<p>For <span class="math inline">\(i=1,2,\cdots,\kappa\)</span> :</p>
<ol type="1">
<li><p><span class="math inline">\(M^*\)</span> samples <span
class="math inline">\(b^*\gets\{0,1\}\)</span> , samples <span
class="math inline">\(\pi_{b^*}\gets S_n\)</span> , computes <span
class="math inline">\(\tilde G=\pi_{b^*}(G_{b^*})\)</span></p></li>
<li><p><span class="math inline">\(M^*\)</span> runs with <span
class="math inline">\(V^*\)</span> and receives <span
class="math inline">\(b^*\)</span></p></li>
<li><p>If <span class="math inline">\(b=b^*\)</span> , <span
class="math inline">\(M^*\)</span> continues working as <span
class="math inline">\(P\)</span></p>
<p>If <span class="math inline">\(b\neq b^*\)</span> , <span
class="math inline">\(M^*\)</span> restarts from <span
class="math inline">\(i=1\)</span></p></li>
</ol>
<blockquote>
<p>Bad : <span class="math inline">\(\mathbb E\{\text{repitition
time}\}=\mathcal O(2^{\kappa})\)</span></p>
</blockquote></li>
<li><p>Idea : Not restarts from <span class="math inline">\(i=1\)</span>
?</p>
<p>Store the state of <span class="math inline">\(V^*\)</span> : <span
class="math inline">\((input,memory,output,randomness)\)</span></p>
<blockquote>
<p>We can store randomness of <span class="math inline">\(V^*\)</span>
since it can be provided by <span class="math inline">\(M^*\)</span></p>
<p>The randomness of <span class="math inline">\(V^*\)</span> can be
pre-determined</p>
</blockquote>
<p>Simulator <span class="math inline">\(M^*\)</span> :</p>
<p>For <span class="math inline">\(i=1,2,\cdots,\kappa\)</span> :</p>
<ol type="1">
<li><p><span class="math inline">\(M^*\)</span> saves the state <span
class="math inline">\(st_{i-1}\)</span> of <span
class="math inline">\(V^*\)</span></p></li>
<li><p><span class="math inline">\(M^*\)</span> samples <span
class="math inline">\(b_i^*\gets\{0,1\}\)</span> , samples <span
class="math inline">\(\pi_{b_i^*}\gets S_n\)</span> , computes <span
class="math inline">\(\tilde
G_i=\pi_{b_i^*}(G_{b_i^*})\)</span></p></li>
<li><p><span class="math inline">\(M^*\)</span> runs with <span
class="math inline">\(V^*\)</span> and receives <span
class="math inline">\(b_i^*\)</span></p></li>
<li><p>If <span class="math inline">\(b_i=b_i^*\)</span> , <span
class="math inline">\(M^*\)</span> continues working as <span
class="math inline">\(P\)</span></p>
<p>If <span class="math inline">\(b_i\neq b_i^*\)</span> , <span
class="math inline">\(M^*\)</span> reloads <span
class="math inline">\(st_{i-1}\)</span> for <span
class="math inline">\(V^*\)</span> and goes back to (2).</p></li>
</ol></li>
<li><p>Def [<strong><em>Interactive Proof with Auxiliary
Input</em></strong>] :</p>
<p><span class="math inline">\((P,V)\)</span> is an
<strong><em>interactive zk-proof with auxiliary input</em></strong> for
<span class="math inline">\(L\)</span> if</p>
<ul>
<li><p><span class="math inline">\(V\)</span> is an efficient algorithm
( poly-time )</p></li>
<li><p><strong><em>Completeness</em></strong> : <span
class="math inline">\(\forall x\in L,\forall y,z\in
\{0,1\}^*,\Pr\{\braket{P(y),V(z)}(x)=1\}=1\)</span></p></li>
<li><p><strong><em>(Almost) Soundness</em></strong> : <span
class="math inline">\(\forall x\notin L,\forall y,z\in \{0,1\}^*,\forall
P^*,\Pr\{\braket{P^*(y),V(z)}(x)=1\}&lt;\epsilon\)</span></p></li>
<li><p><strong><em>Zero-Knowledge</em></strong> : <span
class="math inline">\(\forall V^*\)</span> in P.P.T. , <span
class="math inline">\(\exists\)</span> expected poly-time algorithm
<span class="math inline">\(M^*\)</span> , <span
class="math inline">\(\forall x\in L,\forall y,z\in \{0,1\}^*\)</span> ,
<span class="math display">\[
M^*(x,z)\sim View_{V^*(z)}^{P(y)}(x)
\]</span></p></li>
</ul></li>
<li><p>Lemma [<strong><em>Composition Lemma</em></strong>] :</p>
<p><span class="math inline">\((P,V)\)</span> : zero-knowledge IP for
<span class="math inline">\(L\)</span> , <span
class="math inline">\(q\)</span> is a polynomial of <span
class="math inline">\(\kappa\)</span></p>
<p><span class="math inline">\((P_q,V_q)\)</span> : An IP runs <span
class="math inline">\((P,V)\)</span> <span
class="math inline">\(q\)</span> times</p>
<p>Claim : <span class="math inline">\((P_q,V_q)\)</span> are still
zero-knowledge .</p>
<blockquote>
<p>Proof Intuition</p>
<p>In the <span class="math inline">\(i\)</span>-th iteration : <span
class="math inline">\(V\)</span> runs like <span
class="math inline">\(V_i^*(x,st_{i-1})\)</span> , construct
corresponding <span class="math inline">\(M_i^*(x,st_{i-1})\)</span></p>
<p>Prove <span class="math inline">\(M_i^*(x,st_{i-1})\sim
View_{V_i^*}^P(x)\)</span></p>
</blockquote></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>零知识证明和多方安全计算</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>密码学-零知识证明</tag>
        <tag>密码学-交互式证明</tag>
        <tag>密码学-证明复合</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 4</title>
    <url>/2023/10/09/Algorithm-Design-4/</url>
    <content><![CDATA[<h2 id="chapter-2-greedy-algorithm">Chapter 2 Greedy Algorithm</h2>
<h3 id="optimal-caching">2.7 Optimal Caching</h3>
<ol type="1">
<li><p>Description</p>
<ul>
<li><p>U : <span class="math inline">\(n\)</span> pieces of distinct
elements stored in main memory</p></li>
<li><p>cache : can hold <span class="math inline">\(k&lt;n\)</span>
pieces</p>
<p>init : cache holds <span class="math inline">\(k\)</span>
elements</p></li>
<li><p>need to process a sequence of elements <span
class="math inline">\(d_1,\cdots,d_m\)</span> ( <span
class="math inline">\(m\)</span> can <span class="math inline">\(\ge
n\)</span> , not distinct)</p></li>
<li><p>when processing <span class="math inline">\(d_i\)</span> :</p>
<ul>
<li>If <span class="math inline">\(d_i\)</span> already in cache : cache
hit , do nothing to the cache</li>
<li>If <span class="math inline">\(d_i\)</span> not in cache : cache
miss , evict some other element from the cache</li>
</ul></li>
<li><p>Goal : minimize # of cache miss .</p></li>
</ul></li>
<li><p>Greedy Algorithm</p>
<ol type="1">
<li><p>FF Strategy : evict the element that will be used the furthest in
the future .</p></li>
<li><p>Proof [Exchange Argument] :</p>
<p>See BOOK</p>
<blockquote>
<p>Suppose our solution <span class="math inline">\(S_{FF}\)</span>
differs with the optimal solution <span class="math inline">\(S\)</span>
firstly at <span class="math inline">\(d_i\)</span> , which is a cache
miss , and our solution evicts <span class="math inline">\(a\)</span>
and the optimal solution evicts <span class="math inline">\(b\)</span> ,
where the future used time : <span
class="math inline">\(t(a)&gt;t(b)\)</span> . Let's prove that we can
construct a new solution <span class="math inline">\(S&#39;\)</span>
that is same with our solution at <span
class="math inline">\(d_i\)</span> as well , and is not worse than the
optimal solution <span class="math inline">\(S\)</span>.</p>
<p>We do not need to care about other caches and other elements . We
only need to care about <span class="math inline">\(a,b\)</span> . <span
class="math inline">\(S=S&#39;\)</span> except the following cases :</p>
<p>Case 0 : At <span class="math inline">\(d_i\)</span> , <span
class="math inline">\(S&#39;\)</span> should evict <span
class="math inline">\(a\)</span> rather than <span
class="math inline">\(b\)</span></p>
<p>Case 1 : <span class="math inline">\(d_j\)</span> let <span
class="math inline">\(a\)</span> evicted in <span
class="math inline">\(S\)</span> before the first future used time <span
class="math inline">\(t(a)\)</span> . Then let <span
class="math inline">\(S&#39;\)</span> evicts <span
class="math inline">\(b\)</span> at the same time , <span
class="math inline">\(S\)</span> is the same as <span
class="math inline">\(S&#39;\)</span> .</p>
<p>Case 2 : At <span class="math inline">\(t(b)\)</span> . If at this
time , <span class="math inline">\(S\)</span> evicts <span
class="math inline">\(a\)</span> , then <span
class="math inline">\(S&#39;\)</span> can do nothing and save one cache
miss . If at this time , <span class="math inline">\(S\)</span> evicts
<span class="math inline">\(c\neq a\)</span> , then we can let <span
class="math inline">\(S&#39;\)</span> evicts <span
class="math inline">\(c\)</span> as well , and then let <span
class="math inline">\(a\)</span> "waiting" until it is used at <span
class="math inline">\(t(a)\)</span> or evicted later .</p>
</blockquote></li>
</ol></li>
<li><p>In reality : we cannot know the sequence ahead</p>
<p>LRU : least recently used</p>
<p>using locality of reference</p>
<p>[ Slater , Tarjan ] : LRU is the earliest online solution (elements
come one by one)</p>
<p><span class="math inline">\(LRU\le k(FF+1)\)</span> , <span
class="math inline">\(k\)</span> is the cache size .</p></li>
</ol>
<h3 id="minimum-cost-arborescence">2.8 Minimum Cost Arborescence</h3>
<p>a.k.a 最小树形图</p>
<ol type="1">
<li><p>Description</p>
<p>Find a min-cost directed spanning tree rooted at <span
class="math inline">\(r\)</span> in a directed graph <span
class="math inline">\(G\)</span> .</p>
<p>Assumption : <span class="math inline">\(\forall e\in E,w(e)\ge
0\)</span></p></li>
<li><p>Algorithm</p>
<ul>
<li><p>For <span class="math inline">\(v\in V\backslash \{r\}\)</span> ,
choose the in-edge with minimum weight <span
class="math inline">\(e_v\)</span> .</p>
<p>Let <span class="math inline">\(F^*\)</span> be the set of chosen
edge , so <span class="math inline">\(cost(F^*)\le OPT\)</span> .</p>
<p>If <span class="math inline">\(F^*\)</span> is already a tree , we
get the optimal solution .</p></li>
<li><p>Otherwise , for all <span class="math inline">\(v\in
V\backslash\{r\}\)</span> , let <span
class="math inline">\(w&#39;(e=(u,v))=w(u,v)-w(e_v)\)</span> , and then
contract zero-cost cycles to get a new graph <span
class="math inline">\(G&#39;\)</span> .</p></li>
<li><p>Process <span class="math inline">\(G&#39;\)</span> as above
.</p></li>
</ul></li>
<li><p>Extension : matrix-tree theorem</p>
<p>count # of spanning tree in a graph (either directed or
undirected)</p>
<p><span class="math inline">\(Det(L_{00})\)</span></p>
<p>variant : count # of spanning tree in a graph with given total
weight</p></li>
</ol>
<h2 id="chapter-3-dynamic-programming">Chapter 3 Dynamic
Programming</h2>
<h3 id="weighted-interval-scheduling-problem">3.1 weighted interval
scheduling problem</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(n\)</span> intervals <span
class="math inline">\([l_i,r_i]\)</span> with weight <span
class="math inline">\(w_i\)</span></p>
<p>Goal : maximize the total weight s.t. the chosen intervals are
distinct</p></li>
<li><p>key : Dynamic Programming recursion</p>
<ol type="1">
<li>sort the jobs according to <span class="math inline">\(r_i\)</span>
(like greedy algorithm)</li>
<li>define <span class="math inline">\(opt(j)\)</span> : the optimal
value for the first <span class="math inline">\(j\)</span>
intervals</li>
</ol>
<p><span class="math display">\[
opt(i)=\max\{opt(i-1),opt(p(i))+w_i\}
\]</span></p>
<p>where <span class="math inline">\(p(i)=\max\{j|r_j&lt;l_i\}\)</span>
.</p>
<ol start="3" type="1">
<li><p>If we don't use interval <span class="math inline">\(i\)</span> ,
it is <span class="math inline">\(opt(i-1)\)</span> .</p>
<p>If we use interval <span class="math inline">\(i\)</span> , since
<span class="math inline">\(\{r_i\}\)</span> non-decreasing , <span
class="math inline">\(opt(p(i))\)</span> contains all valid optimal
solutions before .</p></li>
</ol></li>
<li><p>Implementation</p>
<p>naive :</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute_opt</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">compute_opt</span>(i<span class="number">-1</span>),w[i]+<span class="built_in">compute_opt</span>(<span class="built_in">p</span>(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Problem : can be exponential time !</p>
<p>Key : many redundant computation <span
class="math inline">\(\to\)</span> store them</p>
</blockquote>
<p>memorization / filling out the DP table :</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt[]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// recursive implementation </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute_opt</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(opt[i]!=<span class="number">-1</span>)<span class="keyword">return</span> opt[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> opt[i]=<span class="built_in">max</span>(<span class="built_in">compute_opt</span>(i<span class="number">-1</span>),w[i]+<span class="built_in">compute_opt</span>(<span class="built_in">p</span>(i)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// non-recursive implementation</span></span><br><span class="line">&#123;</span><br><span class="line">    opt[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        opt[i]=<span class="built_in">max</span>(opt[i<span class="number">-1</span>],w[i]+opt[<span class="built_in">p</span>(i)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="subset-sum-knapsack">3.2 Subset Sum / Knapsack</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(n\)</span> items , item <span
class="math inline">\(i\)</span> has weight <span
class="math inline">\(w_i\)</span> and value <span
class="math inline">\(v_i\)</span> ; Weight limit <span
class="math inline">\(W\)</span></p>
<p>Goal : find a subset of items <span class="math inline">\(S\)</span>
s.t. <span class="math inline">\(\sum_{i\in S}w_i\le W\)</span> and
maximize <span class="math inline">\(\sum_{i\in S}v_i\)</span>
.</p></li>
<li><p>DP Algorithm</p>
<ol type="1">
<li><p>pseudo-poly time / poly time</p>
<p>pseudo-poly time : <span class="math inline">\(poly(n,W)\)</span></p>
<p>poly time : <span class="math inline">\(poly(n,\log W)\)</span> (
<span class="math inline">\(\log W\)</span> is the least number of bits
to input <span class="math inline">\(W\)</span> )</p>
<blockquote>
<p>Knapsack : NP-Hard : hard to find poly time algorithm</p>
<p>But finding a pseudo-poly time algorithm is easy !</p>
</blockquote></li>
<li><p><span class="math inline">\(opt(i,w)\)</span> : the optimal
solution for first <span class="math inline">\(i\)</span> items and
weight <span class="math inline">\(= w\)</span> <span
class="math display">\[
opt(i,w)=\max\begin{cases}opt(i-1,w)&amp;\text{not using i-th item}\\
opt(i-1,w-w_i)+v_i&amp;\text{using i-th item}
\end{cases}
\]</span></p></li>
<li><p>Time Complexity : <span class="math inline">\(\mathcal
O(nW)\)</span> .</p></li>
</ol></li>
<li><p>Implementation</p>
<p><span class="math inline">\(opt(w)\)</span> : at <span
class="math inline">\(i\)</span>-th iteration : the optimal solution for
first <span class="math inline">\(i\)</span> items and weight <span
class="math inline">\(= w\)</span> <span class="math display">\[
opt(w)=\max\{opt(w),opt(w-w_i)+v_i\}
\]</span> iterate <span class="math inline">\(w\)</span>
decreasingly</p>
<p><img src="\images\posts\AD4_fig1.jpg" /></p>
<p>Memory Complexity : <span class="math inline">\(\mathcal
O(n+W)\)</span></p></li>
</ol>
<h3 id="rna-secondary-structure">3.3 RNA secondary structure</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(\{A,C,G,U\}^n\)</span></p>
<p>Constraints :</p>
<ul>
<li>no sharp turns : If pairing <span class="math inline">\((i,j)\in
S\)</span> , then <span class="math inline">\(i&lt;j-4\)</span></li>
<li>pairing : <span class="math inline">\(A-G\)</span> , <span
class="math inline">\(C-U\)</span></li>
<li>one base can only appear in <span class="math inline">\(\le
1\)</span> pairs</li>
<li>no crossing pairing : <span class="math inline">\(\not\exist
(i,j),(l,r)\in S,i&lt;l&lt;j&lt;r\)</span></li>
</ul>
<p>Goal : maximize the size of pairing set <span
class="math inline">\(S\)</span></p></li>
<li><p>Algorithm</p>
<p><span class="math inline">\(opt(l,r)\)</span> : the maximum number of
pairs in subsequence <span class="math inline">\([l,r]\)</span> <span
class="math display">\[
opt(l,r)=\max\begin{cases}
opt(l+1,r-1)&amp;a[l]\text{ and }a[r] \text{ can pairing}\\
\max_{l\le i\le r-1}\{opt(l,i)+opt(i+1,r)\}
\end{cases}
\]</span> Order : <span class="math inline">\(r-l\)</span>
increasing</p>
<p>Time Complexity : <span class="math inline">\(\mathcal
O(n^3)\)</span></p>
<p>Memory Complexity : <span class="math inline">\(\mathcal
O(n^2)\)</span></p></li>
</ol>
<h3 id="dp-on-tree-and-tree-like-graph">3.4 DP on tree and tree-like
graph</h3>
<h4 id="maximum-independent-set-on-tree">3.4.1 maximum independent set
on tree</h4>
<ol type="1">
<li><p>Description</p>
<p>Input : A tree , vertex-weighted</p>
<p>Goal : Find an Independent Set of maximum weight</p></li>
<li><p>Algorithm</p>
<p><span class="math inline">\(opt_{0/1}(x)\)</span> : the
maximum-weighted independent set of the subtree <span
class="math inline">\(x\)</span> , <span
class="math inline">\(opt_1\)</span> means we choose <span
class="math inline">\(x\)</span> , <span
class="math inline">\(opt_0\)</span> means we don't choose <span
class="math inline">\(x\)</span> . <span class="math display">\[
opt_1(x)=w_x+\sum_{y\in child(x)}opt_0(y)\\
opt_0(x)=\sum_{y\in child(x)}\max\{opt_0(y),opt_1(y)\}
\]</span></p></li>
<li><p>Tree DP View :</p>
<ul>
<li>subtree is the natural subinstance</li>
<li>delete <span class="math inline">\(x\)</span> , the tree will be
separated into several parts , no connection between <span
class="math inline">\(subtree(y)\)</span> (<span
class="math inline">\(y\in child(x)\)</span>) , <span
class="math inline">\(G\backslash subtree(x)\)</span></li>
</ul></li>
</ol>
<h4 id="treewidth">3.4.2 treewidth</h4>
<ol type="1">
<li><p>Tree Decomposition ( clique tree , junction trees )</p>
<ol type="1">
<li><p>Def [separator] : For connected graph <span
class="math inline">\(G\)</span> , a separator is a vertex set <span
class="math inline">\(S\subset V\)</span> , s.t. <span
class="math inline">\(G\backslash S\)</span> is not connected .</p></li>
<li><p>Def [tree decomposition] : <span
class="math inline">\(T(G)\)</span> is a tree decomposition if :</p>
<p>Each vertex in <span class="math inline">\(T(G)\)</span> is called a
bag <span class="math inline">\((V_T(x),E_T(x))\)</span> : containing
some vertices in <span class="math inline">\(G\)</span> and their
edges</p>
<ul>
<li><span class="math inline">\(\cup_x V_T(x)=V\)</span></li>
<li><span class="math inline">\(\forall e\in E,\exists x\in T(G) , e\in
E_T(x)\)</span></li>
<li><span class="math inline">\(\forall v\in V,\{x|v\in
V_T(x)\}\)</span> form a connected subtree</li>
</ul></li>
<li><p>Def [treewidth for tree decomposition] : <span
class="math inline">\(tw(T(G)):=\max_x \{|V_T(x)|\}-1\)</span></p></li>
<li><p>Lemma : If <span class="math inline">\(G\)</span> is a tree ,
<span class="math inline">\(tw(T(G))=1\)</span></p></li>
<li><p>Def [treewidth for graph] : <span class="math display">\[
tw(G)=\min\limits_{T(G)\text{ is a tree decomposition}}tw(T(G))
\]</span></p></li>
</ol></li>
<li><p>Lemma [ bags and separators ] : <span
class="math inline">\(T(G)\)</span> is a tree decomposition of <span
class="math inline">\(G\)</span> , <span
class="math inline">\(A,B\)</span> are adjacent bags in <span
class="math inline">\(T(G)\)</span> , then</p>
<p><span class="math inline">\(V_T(A)\)</span> is a separator of <span
class="math inline">\(G\)</span> , <span class="math inline">\(V_T(A\cap
B)\)</span> is a separator of <span
class="math inline">\(G\)</span></p></li>
<li><p>Independent Set on a graph with a tree decomposition</p>
<p>Input : given <span class="math inline">\(G\)</span> and a tree
decomposition <span class="math inline">\(T(G)\)</span></p>
<p>Goal : Find maximum Independent Set in Time Complexity <span
class="math inline">\(\mathcal O(n2^{tw(T(G))})\)</span></p></li>
<li><p>Algorithm</p>
<ul>
<li><p><span class="math inline">\(opt(x,S)\)</span> : consider the
subtree <span class="math inline">\(x\)</span> in the tree decomposition
, choosing exactly <span class="math inline">\(S\)</span> in <span
class="math inline">\(V_T(x)\)</span> , the maximum independent
set</p></li>
<li><p><span class="math display">\[
opt(x,S)=w(S)+\sum_{y\in child(x)}\max_{S&#39; , S\text{ consists with }
S&#39;\text{ on }S\cap S&#39;}\{opt(y,S&#39;)-w(S\cap S&#39;)\}
\]</span></p></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-贪心</tag>
        <tag>算法-贪心-最优缓存</tag>
        <tag>算法-图论-最小树形图</tag>
        <tag>算法-动态规划</tag>
        <tag>算法-动态规划-线性DP</tag>
        <tag>算法-动态规划-背包</tag>
        <tag>算法-动态规划-区间DP</tag>
        <tag>算法-动态规划-树形DP</tag>
        <tag>算法-图论-树分解</tag>
      </tags>
  </entry>
  <entry>
    <title>Probability and Statistics 2</title>
    <url>/2023/10/08/Probability-and-Statistics-2/</url>
    <content><![CDATA[<h2 id="chapter-1-background-in-probability">Chapter 1 Background in
Probability</h2>
<h3 id="random-variables">1.2 Random Variables</h3>
<ol type="1">
<li><p>measurable map</p>
<ol type="1">
<li><p>Remark of Thm [a sufficient condition for measurable map]</p>
<blockquote>
<p>If <span class="math inline">\(\mathcal S\)</span> is a <span
class="math inline">\(\sigma\)</span>-field , then <span
class="math inline">\(\{X^{-1}(B)|B\in \mathcal S\}\)</span> is a <span
class="math inline">\(\sigma\)</span>-field</p>
</blockquote>
<blockquote>
<p>Def : [generation of measurable map] <span
class="math inline">\(\sigma(X)\)</span> is the <span
class="math inline">\(\sigma\)</span>-field generated by <span
class="math inline">\(X\)</span> <span class="math display">\[
\sigma(X)=\{X^{-1}(B)|B\in \mathcal S\}
\]</span></p>
</blockquote>
<blockquote>
<p><span class="math inline">\(\sigma(X)\)</span> is the smallest <span
class="math inline">\(\sigma\)</span>-field on <span
class="math inline">\(\Omega\)</span> that makes <span
class="math inline">\(X\)</span> a measurable map to <span
class="math inline">\((S,\mathcal S)\)</span> .</p>
</blockquote></li>
<li><p>Thm [measurable map composition] : If <span
class="math inline">\(X:(\Omega,\mathcal F)\to(S,\mathcal S)\)</span> ,
<span class="math inline">\(f:(S,\mathcal S)\to (T,\mathcal T)\)</span>
are both measurable maps , then <span class="math inline">\(f\circ
X\)</span> is a measurable map <span
class="math inline">\((\Omega,\mathcal S)\to(T,\mathcal T)\)</span>
.</p>
<blockquote>
<p>Proof : <span class="math inline">\((f\circ
X)^{-1}(B)=X^{-1}(f^{-1}(B))\)</span> , <span
class="math inline">\(C:=f^{-1}(B)\in \mathcal S\)</span> , <span
class="math inline">\(X^{-1}(C)\in \mathcal F\)</span></p>
</blockquote></li>
<li><p>Cor : If <span class="math inline">\(X_1,\cdots,X_n\)</span> are
random variables , <span class="math inline">\(f:(\mathbb R^n,\mathcal
R^n)\to(\mathbb R,\mathcal R)\)</span> is measurable , then <span
class="math inline">\(f(X_1,\cdots,X_n)\)</span> is a random variable
.</p></li>
<li><p>(*) Cor : <span class="math inline">\(X_1,\cdots,X_n\)</span> are
random variables , then <span
class="math inline">\(X_1+\cdots+X_n\)</span> is a random variable
.</p></li>
<li><p>(*) Thm : <span class="math inline">\(X_1,\cdots\)</span> are
random variables , then <span class="math inline">\(\inf_n X_n\)</span>
, <span class="math inline">\(\sup_n X_n\)</span> , <span
class="math inline">\(\liminf_n X_n\)</span> , <span
class="math inline">\(\limsup_n X_n\)</span> are random variables</p>
<blockquote>
<p>Proof : <span class="math inline">\(\{\inf_n
X_n&lt;a\}=\cup_n\{X_n&lt;a\}\in\mathcal F\)</span> . <span
class="math display">\[
\liminf_{n\to \infty}X_n=\sup_n\left(\inf_{m\ge n}X_m\right)
\]</span> <span class="math inline">\(Y_n=\inf_{m\ge n}X_m\)</span> is a
random variable .</p>
</blockquote></li>
</ol></li>
<li><p>(*) Generalization of random variable</p>
<ol type="1">
<li><p>Def : [Converges almost surely]</p>
<p>From Thm above , the following set is a measurable set <span
class="math display">\[
\Omega_o:=\{w:\lim_{n\to\infty}X_n\text{
exists}\}=\{w:\limsup_{n\to\infty}X_n-\liminf_{n\to\infty}X_n=0\}
\]</span> If <span class="math inline">\(P(\Omega_o)=1\)</span> , then
<span class="math inline">\(X_n\)</span> converges almost surely ( a.s.
) .</p>
<blockquote>
<p>即一列 <span class="math inline">\(X_n\)</span> 是几乎处处收敛的
当且仅当 <span class="math inline">\(X_n\)</span> 不收敛的点集测度为
<span class="math inline">\(0\)</span></p>
</blockquote>
<p>Def : <span class="math inline">\(X_\infty:=\limsup_{n\to \infty}
X_n\)</span></p>
<p>Problem : <span class="math inline">\(X_{\infty}\)</span> can have
value <span class="math inline">\(\pm\infty\)</span> .</p></li>
<li><p>Def : [Generalized random variable]</p>
<p>A function whose domain is <span class="math inline">\(D\in \mathcal
F\)</span> and range is <span class="math inline">\(\mathbb
R^*:=[-\infty,+\infty]\)</span> is a random variable if <span
class="math inline">\(\forall B\in \mathcal R^* , X^{-1}(B)\in \mathcal
F\)</span> .</p>
<p>Def : [Extended Borel set ] : <span class="math inline">\(\mathcal
R^*\)</span> is generated by intervals of form <span
class="math inline">\([-\infty,a),(a,b),(b,+\infty]\)</span> , <span
class="math inline">\(a,b\in \mathbb R\)</span> .</p>
<blockquote>
<p>extended real line <span class="math inline">\((\mathbb R^*,\mathcal
R^*)\)</span> is a measurable space</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="distribution">1.3 Distribution</h3>
<ol type="1">
<li><p>Definition of Distribution</p>
<ol type="1">
<li><p>Def : [distribution] <span class="math inline">\(X\)</span> is a
random variable , then let <span class="math inline">\(\mu=P\circ
X^{-1}\)</span> ( <span class="math inline">\(\mu(A)=P(X\in A)\)</span>
) , <span class="math inline">\(\mu\)</span> is a probability measure
called distribution .</p></li>
<li><p>Check <span class="math inline">\(\mu\)</span> is a probability
measure <span class="math inline">\((\mathbb R,\mathcal R)\to (\mathbb
R,\mathcal R)\)</span> .</p>
<ul>
<li><p><span class="math inline">\(\mu(A)=P(\{w\in \Omega:X(w)\in
A\})\ge 0\)</span></p></li>
<li><p>If <span class="math inline">\(A_i\in \mathcal R\)</span> are
disjoint countable sequence , then <span
class="math inline">\(X^{-1}(A_i)\)</span> are also disjoint <span
class="math display">\[
\begin{aligned}
\mu(\cup_i A_i)&amp;=P(X^{-1}(\cup_i A_i))\\
&amp;=P(\cup_i X^{-1}(A_i))\\
&amp;=\sum_{i} P(X^{-1}(A_i))\\
&amp;=\sum_{i} \mu(A_i)
\end{aligned}
\]</span></p></li>
</ul></li>
</ol></li>
<li><p>distribution function</p>
<ol type="1">
<li><p>Def : [distribution function] Let <span
class="math inline">\(F(x)=P(X\le x)\)</span> , <span
class="math inline">\(F(x)\)</span> is the distribution function .</p>
<blockquote>
<p><span class="math inline">\(F(x)=P(X\le x)\)</span> : Let <span
class="math inline">\(A_x=(-\infty,x]\)</span> , <span
class="math inline">\(F(x)=P(X^{-1}(A_x))=\mu(A_x)\)</span></p>
</blockquote>
<blockquote>
<p><span class="math inline">\(F(x)\)</span> can be viewed as the CDF of
<span class="math inline">\(\mu\)</span> / the Stieltjes measure
function</p>
</blockquote></li>
<li><p>Thm [Props of distribution function] : Let <span
class="math inline">\(F\)</span> be a distribution function</p>
<ul>
<li><p><span class="math inline">\(F\)</span> : non-decreasing</p></li>
<li><p><span class="math inline">\(\lim\limits_{x\to -\infty
}F(x)=0\)</span> , <span
class="math inline">\(\lim\limits_{x\to+\infty}F(x)=1\)</span></p></li>
</ul>
<blockquote>
<p><span class="math inline">\(x\to -\infty , \{X\le x\}\downarrow
\varnothing\)</span> , <span class="math inline">\(x\to+\infty , \{X\le
x\}\uparrow \Omega\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(F\)</span> : right continuous , <span
class="math inline">\(F(x^+)=\lim_{y\downarrow x}F(y)=F(x)\)</span></li>
</ul>
<blockquote>
<p><span class="math inline">\(y=x+\epsilon\)</span> , <span
class="math inline">\(\{X\le y\}=\{X\le x+\epsilon\}\downarrow \{X\le
x\}\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(F(x^-)=P(X&lt;x)\)</span></li>
</ul>
<blockquote>
<p><span class="math inline">\(y=x-\epsilon\)</span> , <span
class="math inline">\(\{X\le y\}=\{X\le x-\epsilon\}\uparrow
\{X&lt;x\}\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(P(X=x)=F(x)-F(x^-)\)</span></li>
</ul></li>
<li><p>Thm [Judgement of distribution function] : <span
class="math inline">\(F\)</span> satisfies (i) , (ii) , (iii) is a
distribution function</p>
<blockquote>
<p>Proof : [construction]</p>
<p>Let <span class="math inline">\(\Omega=(0,1)\)</span> , <span
class="math inline">\(\mathcal F\)</span> is the corresponding Borel set
, <span class="math inline">\(P\)</span> is Lebesgue measure , so <span
class="math inline">\(P((a,b])=b-a\)</span> .</p>
<p>Let <span class="math inline">\(X(w)=\sup\{y:F(y)&lt;w\}\)</span> ,
we want to prove that <span class="math inline">\(P(X\le
x)=F(x)\)</span> .</p>
<p>Since <span class="math inline">\(F(x)=P(\{w:w\le F(x)\})\)</span> ,
we want to prove that : <span class="math display">\[
\{w:X(w)\le x\}=\{w:w\le F(x)\} \quad\quad \quad (*)
\]</span> <span class="math inline">\(R\subset L\)</span> : <span
class="math inline">\(\forall w,w\le F(x)\)</span> , and <span
class="math inline">\(X(w)=\sup\{y:F(y)&lt;w\}\)</span> , so <span
class="math inline">\(F(X(w))\le w\le F(x)\)</span> , so <span
class="math inline">\(X(w)\le x\)</span> .</p>
<p><span class="math inline">\(R^c\subset L^c\)</span> : <span
class="math inline">\(\forall w,w&gt;F(x)\)</span> , and <span
class="math inline">\(X(w)=\sup\{y:F(y)&lt;w\}\)</span> .</p>
<p><span class="math inline">\(F\)</span> : right continuous , so <span
class="math inline">\(\exists \epsilon&gt;0\)</span> , <span
class="math inline">\(F(x+\epsilon)&lt;w\)</span> , so <span
class="math inline">\(X(w)\ge x+\epsilon&gt;x\)</span> .</p>
</blockquote>
<p>Equation (*) means :</p>
<p><img src="/images/posts/PS2_fig1.png" /></p></li>
<li><p>Remark</p>
<p>Each distribution function <span class="math inline">\(F\)</span>
corresponds to a unique distribution measure <span
class="math inline">\(\mu\)</span></p>
<p>One distribution function <span class="math inline">\(F\)</span> can
correspond to many different random variables</p>
<p>Def [equal in distribution] : If <span
class="math inline">\(X,Y\)</span> have same distribution
measure/function , then <span class="math inline">\(X\)</span> and <span
class="math inline">\(Y\)</span> are equal in distribution , denote as
<span class="math inline">\(X\overset{d}{=}Y\)</span> or <span
class="math inline">\(X=_d Y\)</span> .</p></li>
</ol></li>
<li><p>Density function</p>
<ol type="1">
<li><p>Def [density function] : when a distribution function <span
class="math inline">\(F(x)=P(X\le x)\)</span> has the form <span
class="math display">\[
F(x)=\int_{-\infty}^x f(y)\ dy
\]</span> then <span class="math inline">\(X\)</span> has the density
function <span class="math inline">\(f\)</span> , denote as <span
class="math inline">\(f_X(x)\)</span> .</p>
<blockquote>
<p><span class="math display">\[
P(X=x)=\lim_{\epsilon\to0}\int_{x-\epsilon}^{x+\epsilon} f(y)dy=0
\]</span></p>
</blockquote></li>
<li><p>Prop : (necessary and sufficient)</p>
<ul>
<li><span class="math inline">\(f(x)\ge 0\)</span></li>
<li><span
class="math inline">\(\int_{-\infty}^{+\infty}f(x)dx=1\)</span></li>
</ul></li>
</ol></li>
<li><p>Discrete / Continuous</p>
<p>A probability measure <span class="math inline">\(P\)</span> is
discrete if there exists a countable set <span
class="math inline">\(S\)</span> that <span
class="math inline">\(P(S^c)=0\)</span> ( only non-zero on countable
set) .</p>
<p>Discrete : usually <span class="math inline">\([a_i,b_i)\)</span>
segments like .</p></li>
</ol>
<h3 id="integration">1.4 Integration</h3>
<p>Intuition : Expectation needs Integration .</p>
<ol type="1">
<li><p>Notations</p>
<ol type="1">
<li><p>Def : <span class="math inline">\((\Omega,\mathcal F)\)</span> ,
with measure <span class="math inline">\(\mu\)</span> , <span
class="math inline">\(f:(\Omega,\mathcal F)\to(\mathbb R,\mathcal
R)\)</span> . Denote the integration as <span class="math inline">\(\int
fd\mu\)</span> .</p></li>
<li><p>Restriction for <span class="math inline">\(\mu\)</span> : should
be <span class="math inline">\(\sigma\)</span>-finite measure</p>
<p>e.g. Lebesgue measure is <span
class="math inline">\(\sigma\)</span>-finite : <span
class="math inline">\(A_i=[-i,i]\)</span> , so <span
class="math inline">\(\mu(A_i)&lt;\infty\)</span> and <span
class="math inline">\(\cup_i{A_i}=\mathbb R\)</span> .</p></li>
<li><p>Restriction for <span class="math inline">\(\int fd\mu\)</span>
:</p>
<ol type="i">
<li><span class="math inline">\(\varphi\ge 0\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int\varphi d\mu\ge 0\)</span></li>
</ol>
<p>Def [almost everywhere] : <span
class="math inline">\(\mu\)</span>-a.e. : <span
class="math inline">\(\mu(\{w:\varphi(w)&lt;0\})=0\)</span> .</p>
<ol start="2" type="i">
<li><p><span class="math inline">\(\int a\varphi d\mu=a\int \varphi
d\mu\)</span></p></li>
<li><p><span class="math inline">\(\int (\varphi+\psi)d\mu=\int \varphi
d\mu+\int \psi d\mu\)</span></p></li>
<li><p><span class="math inline">\(\varphi\le \psi\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int \varphi d\mu\le \int \psi
d\mu\)</span></p></li>
<li><p><span class="math inline">\(\varphi=\psi\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int \varphi d\mu=\int \psi d\mu\)</span></p></li>
<li><p><span class="math inline">\(\left|\int \varphi d\mu\right|\le
\int |\varphi|d\mu\)</span></p></li>
</ol></li>
<li><p>Thm : (i),(ii),(iii) can derive (iv),(v),(vi)</p></li>
</ol></li>
<li><p>Simple Function</p>
<ol type="1">
<li><p>Def [simple function] : If <span
class="math inline">\(\varphi(\omega)=\sum_{i=1}^n a_i \mathbb
1_{A_i}\)</span> , and <span class="math inline">\(A_i\)</span> are
disjoint sets , <span
class="math inline">\(\mu(A_i)&lt;\infty\)</span></p></li>
<li><p>Def [simple function integration] : If <span
class="math inline">\(\varphi(\omega)=\sum_{i=1}^n a_i \mathbb
1_{A_i}\)</span> , define <span class="math display">\[
\int \varphi d\mu=\sum_{i=1}^n a_i \mu(A_i)
\]</span></p></li>
<li><p>Check Props</p>
<blockquote>
<ol type="i">
<li><p>: <span class="math inline">\(\varphi\ge 0\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , so for all <span
class="math inline">\(A_i\)</span> with <span
class="math inline">\(\mu(A_i)&gt;0\)</span> , <span
class="math inline">\(a_i\ge 0\)</span> .</p></li>
<li><p>: trivial</p></li>
</ol>
</blockquote>
<blockquote>
<ol start="3" type="i">
<li>: Suppose <span class="math inline">\(\varphi=\sum_{i=1}^m a_i
\mathbb 1_{A_i}\)</span> , <span class="math inline">\(\psi=\sum_{j=1}^n
b_j \mathbb 1_{B_j}\)</span></li>
</ol>
<p>Define <span class="math inline">\(A_0=\cup_{j} B_j-\cup_i
A_i\)</span> , <span class="math inline">\(B_0=\cup_i A_i-\cup_j
B_j\)</span> . Let <span class="math inline">\(a_0=b_0=0\)</span> .</p>
<p>Therefore <span class="math inline">\(\cup_{j=1}^n B_j\subset
\cup_{i=0}^n A_i\)</span> and <span class="math inline">\(\cup_{i=1}^m
A_i\subset \cup_{j=1}^n B_j\)</span> . <span class="math display">\[
\begin{aligned}
\int(\varphi+\psi)d\mu&amp;=\sum_{i=0}^m \sum_{j=0}^n
(a_i+b_j)\mu(A_i\cap B_j)\\
&amp;=\sum_{i=0}^m a_i\sum_{j=0}^n \mu(A_i\cap
B_j)+\sum_{j=0}^nb_j\sum_{i=0}^m \mu(A_i\cup B_j)\\
&amp;=\sum_{i=0}^m a_i\mu(A_i)+\sum_{j=0}^n b_j\mu(B_j)\\
&amp;=\int \varphi d\mu +\int \psi d\mu
\end{aligned}
\]</span></p>
</blockquote></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>概率与统计</category>
      </categories>
      <tags>
        <tag>实分析-测度-可测映射</tag>
        <tag>概率论-随机变量</tag>
        <tag>概率论-分布函数</tag>
        <tag>概率论-概率密度函数</tag>
        <tag>实分析-Lebesgue积分</tag>
      </tags>
  </entry>
  <entry>
    <title>Probability and Statistics 1</title>
    <url>/2023/10/08/Probability-and-Statistics-1/</url>
    <content><![CDATA[<h2 id="chapter-0">Chapter 0</h2>
<ol type="1">
<li><p>Categories</p>
<ol type="1">
<li><p>Background in Probability</p>
<ul>
<li><p>what is probability <span class="math inline">\(\to\)</span>
measure theory</p></li>
<li><p>what is integration $$ Riemann / Lebesgue Integration</p></li>
<li><p>Expectation &amp; its properties</p></li>
</ul></li>
<li><p>Probability foundations of Asymptotic Statistics</p>
<ul>
<li>weak law of large numbers</li>
<li>strong law of large numbers (proof by Kolmoguor)</li>
<li>central limit theorem</li>
<li>characteristic function</li>
</ul></li>
<li><p>Estimation inference &amp; testing</p>
<ul>
<li>hypothesis testing</li>
<li>regression analysis</li>
<li>frontiers of statistical research (e.g. distribution of free
test)</li>
</ul></li>
</ol></li>
<li><p>Textbook</p>
<p>[Durrett] Probability Theory &amp; Examples (or PTE)</p></li>
</ol>
<h2 id="chapter-1-background-in-probability">Chapter 1 Background in
Probability</h2>
<h3 id="probability-space">1.1 Probability Space</h3>
<ol type="1">
<li><p>Probability Space</p>
<ol type="1">
<li><p>Def : <span class="math inline">\((\Omega,\mathcal
F,P)\)</span></p>
<p><span class="math inline">\(\Omega\)</span> : set of "outcomes"</p>
<p><span class="math inline">\(\mathcal F\)</span> : set of "events" ,
like subset of <span class="math inline">\(\Omega\)</span></p>
<p><span class="math inline">\(P\)</span> : function : <span
class="math inline">\(\mathcal F\to [0,1]\)</span></p></li>
<li><p><span class="math inline">\(\mathcal F\)</span> should be a <span
class="math inline">\(\sigma\)</span>-field</p>
<ol type="1">
<li><p>Def : [<span class="math inline">\(\sigma\)</span>-field] A
nonempty collection of subsets of <span
class="math inline">\(\Omega\)</span> that</p>
<ul>
<li>补封闭：If <span class="math inline">\(A\in \mathcal F\)</span> ,
then <span class="math inline">\(A^c\in \mathcal F\)</span></li>
<li>可数无穷并封闭：If <span class="math inline">\(A_i\in \mathcal
F\)</span> , <span class="math inline">\(A_i\)</span> is a countable
sequence , then <span class="math inline">\(\cup_i A_i\in \mathcal
F\)</span></li>
</ul></li>
<li><p>Prop :</p>
<ul>
<li><span class="math inline">\(\varnothing \in \mathcal F,\Omega\in
\mathcal F\)</span></li>
</ul>
<blockquote>
<p>Proof : <span class="math inline">\(A\in\mathcal F\)</span> $$ <span
class="math inline">\(A^c\in \mathcal F\)</span> <span
class="math inline">\(\to\)</span> <span class="math inline">\(A\cup
A^c\in \mathcal F\)</span> <span class="math inline">\(\to\)</span>
<span class="math inline">\(\Omega\in \mathcal F\)</span> <span
class="math inline">\(\to\)</span> <span
class="math inline">\(\varnothing\in \mathcal F\)</span></p>
</blockquote>
<ul>
<li>可数无穷交封闭：If <span class="math inline">\(A_i\in \mathcal
F\)</span> , , <span class="math inline">\(A_i\)</span> is a countable
sequence , then <span class="math inline">\(\cap_i A_i\in \mathcal
F\)</span></li>
</ul>
<blockquote>
<p>Proof : <span class="math inline">\(A\cap B=(A^c\cup
B^c)^c\)</span></p>
</blockquote></li>
</ol></li>
</ol></li>
<li><p>Measurable Space</p>
<ol type="1">
<li><p>Def : [measure] : non-negative , countably additive , set
function</p>
<p>A function <span class="math inline">\(\mu:\mathcal F\to \mathbb
R\)</span> with :</p>
<ul>
<li><p><span class="math inline">\(\forall A\in \mathcal F\)</span> ,
<span class="math inline">\(\mu(A)\ge
\mu(\varnothing)=0\)</span></p></li>
<li><p>If <span class="math inline">\(A_i\in \mathcal F\)</span> , <span
class="math inline">\(A_i\)</span> countable <strong>disjoint</strong>
sequence , then <span class="math display">\[
\mu(\cup_i A_i)=\sum_{i}\mu(A_i)
\]</span></p></li>
</ul></li>
<li><p>Def : [probability measure] : a measure <span
class="math inline">\(\mu\)</span> with <span
class="math inline">\(\mu(\Omega)=1\)</span></p></li>
<li><p>Thm : a measure <span class="math inline">\(\mu\)</span> on <span
class="math inline">\((\Omega,\mathcal F)\)</span> satisfies</p>
<ul>
<li><p>monotonicity : <span class="math inline">\(A\subset B\Rightarrow
\mu(A)\le \mu(B)\)</span></p></li>
<li><p>subadditivity : <span class="math inline">\(A\subset
\cup_{i=1}^{\infty} A_i\Rightarrow \mu(A)\le
\sum_{i=1}^{\infty}A_i\)</span></p></li>
<li><p>continuity :</p>
<blockquote>
<p>Def : [<span class="math inline">\(A_i\uparrow A\)</span> ]</p>
<p>For set <span class="math inline">\(A\)</span> : <span
class="math inline">\(A_1\subset A_2\subset\cdots , \cup_i
A_i=A\)</span></p>
<p>For real number <span class="math inline">\(A\)</span> : <span
class="math inline">\(A_1\le A_2\le
\cdots,\lim_{n\to\infty}A_n=A\)</span></p>
</blockquote>
<p>If <span class="math inline">\(A_i\uparrow A\)</span> , then <span
class="math inline">\(\mu(A_i)\uparrow \mu(A)\)</span></p>
<p>If <span class="math inline">\(A_i\downarrow A\)</span> , then <span
class="math inline">\(\mu(A_i)\downarrow \mu(A)\)</span></p></li>
</ul>
<blockquote>
<p>Proof :</p>
<ol type="i">
<li>: Let <span class="math inline">\(B-A=B\cap A^c\)</span> , so if
<span class="math inline">\(A\subset B\)</span> , then <span
class="math inline">\(B=A+(B-A)\)</span> , and <span
class="math inline">\(A,B-A\)</span> are disjoint <span
class="math display">\[
\mu(B)=\mu(A+(B-A))=\mu(A)+\mu(B-A)\ge \mu(A)
\]</span></li>
<li>: Let <span class="math inline">\(A_n&#39;:=A_n\cap A\)</span> , so
<span class="math inline">\(A=\cup_{i=1}^{\infty} A&#39;_i\)</span> .
Let <span
class="math inline">\(B_n=\begin{cases}A_1&#39;&amp;n=1\\A_n&#39;-\cup_{i=1}^{n-1}
A_i&#39;&amp;n\ge 2\end{cases}\)</span></li>
</ol>
Therefore , <span class="math inline">\(B_n\)</span> are disjoint , and
<span class="math inline">\(\cup_{i=1}^{\infty} B_i=\cup_{i=1}^{\infty}
A_i&#39;=A\)</span> <span class="math display">\[
\mu(A)=\mu(\cup_{i} B_i)=\sum_{i}\mu(B_i)\le \sum_{i} \mu(A_i)
\]</span>
<ol start="3" type="i">
<li>: Let <span class="math inline">\(B_n=A_n-A_{n-1}\)</span> , so
<span class="math inline">\(B_n\)</span> are disjoint , <span
class="math inline">\(\cup_{i=1}^{n} B_i=A_n\)</span> , <span
class="math inline">\(\cup_{i=1}^{\infty}B_i=A\)</span> <span
class="math display">\[
\mu(A)=\sum_{i=1}^{\infty} \mu(B_i)=\lim_{n\to\infty}\sum_{i=1}^n
\mu(B_i)=\lim_{n\to \infty}\mu(A_n)
\]</span></li>
</ol>
</blockquote></li>
<li><p>E.g.1 Discrete Probability Space</p>
<p><span class="math inline">\(\Omega\)</span> : countable set , <span
class="math inline">\(\mathcal F\)</span> : the set of all subsets of
<span class="math inline">\(\Omega\)</span> , <span
class="math inline">\(p: \Omega\to[0,1]\)</span> , where <span
class="math inline">\(\sum_{\omega\in \Omega}p(\omega)=1\)</span> .
<span class="math display">\[
P(A):=\sum_{\omega\in A}p(\omega)
\]</span></p></li>
</ol></li>
<li><p>Measure on real line</p>
<ol type="1">
<li><p>Def : [generate] <span class="math inline">\(\mathcal A\)</span>
is a set of some subsets of <span class="math inline">\(\Omega\)</span>.
A <span class="math inline">\(\sigma\)</span>-field is generated by
<span class="math inline">\(\mathcal A\)</span> if it is the smallest
<span class="math inline">\(\sigma\)</span>-field containing <span
class="math inline">\(\mathcal A\)</span> : <span
class="math display">\[
\sigma(\mathcal A):=\bigcap_{\mathcal A\subset\mathcal F,\mathcal
F\text{ is }\sigma\text{-field}}\mathcal F
\]</span></p></li>
<li><p>Def : [Borel Set]</p>
<p>Let <span class="math inline">\(\mathcal A\)</span> be the open
subsets of <span class="math inline">\(\mathbb R^d\)</span> , Borel set
is <span class="math inline">\(\sigma(\mathcal A)\)</span> , denoted as
<span class="math inline">\(\mathcal R^d\)</span> .</p></li>
<li><p>measure for <span class="math inline">\(d=1\)</span></p>
<ol type="1">
<li><p>Def : [Stieltjes measure function] <span
class="math inline">\(F:\mathbb R\to\mathbb R\)</span> satisfies :</p>
<ul>
<li>non-decreasing : <span class="math inline">\(\forall x\ge y ,
F(x)\ge F(y)\)</span></li>
<li>right-continuous : <span class="math inline">\(\lim_{y\downarrow
x}F(y)=\lim_{y\to x^+}F(y)=F(x)\)</span></li>
</ul></li>
<li><p>Thm : For all Stieltjes measure function <span
class="math inline">\(F\)</span> , there is a unique measure <span
class="math inline">\(\mu\)</span> on <span
class="math inline">\((\mathbb R,\mathcal R)\)</span> , with <span
class="math display">\[
\mu((a,b])=F(b)-F(a)
\]</span></p></li>
<li><blockquote>
<p>When <span class="math inline">\(F(x)=x\)</span> , <span
class="math inline">\(\mu\)</span> is Lebesgue measure</p>
</blockquote>
<blockquote>
<p>right-continuous : If <span class="math inline">\(b_n\downarrow
b\)</span> , then <span
class="math inline">\(\cup_{n}(a,b_n]=(a,b_n]\)</span>
（可以保持右闭）</p>
</blockquote></li>
<li><p>Def [CDF] : For probability measure : <span
class="math inline">\(\lim\limits_{x\to
-\infty}F(x)=0,\lim\limits_{x\to+\infty}F(x)=1\)</span></p>
<p><span class="math inline">\(F\)</span> : Cumulative Distribution
Function [CDF] .</p></li>
</ol></li>
</ol></li>
<li><p>(*) semi-algebra , algebra , <span
class="math inline">\(\sigma\)</span>-algebra</p>
<ol type="1">
<li>Def : [semi-algebra , algebra , <span
class="math inline">\(\sigma\)</span>-algebra]</li>
</ol></li>
</ol>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 43%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">structure</th>
<th style="text-align: center;">complement</th>
<th style="text-align: center;">intersection/union</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">semi-algebra</td>
<td style="text-align: center;"><span class="math inline">\(S^c\)</span>
is a finite , disjoint union of sets in <span
class="math inline">\(\mathcal S\)</span></td>
<td style="text-align: center;"><span class="math inline">\(S,T\in
\mathcal S\)</span> , then <span class="math inline">\(S\cap
T\in\mathcal S\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">algebra</td>
<td style="text-align: center;"><span class="math inline">\(A\in
\mathcal A\)</span> , then <span class="math inline">\(A^c\in \mathcal
A\)</span></td>
<td style="text-align: center;"><span class="math inline">\(S,T\in
\mathcal A\)</span> , then <span class="math inline">\(S\cap T,S\cup
T\in \mathcal A\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\sigma\)</span>-algebra</td>
<td style="text-align: center;"><span class="math inline">\(A\in
\mathcal F\)</span> , then <span class="math inline">\(A^c\in \mathcal
F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(A_i\in
\mathcal F\)</span> , countable sequence , then <span
class="math inline">\(\cup_i A_i\in \mathcal F\)</span></td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li><p>E.g. [algebra but not <span
class="math inline">\(\sigma\)</span>-algebra]</p>
<p><span class="math inline">\(\Omega=\mathbb Z\)</span> , <span
class="math inline">\(\mathcal A=\{A\subset \Omega | A\text{ or
}A^c\text{ is finite}\}\)</span></p>
<p><span class="math inline">\(\mathcal A\)</span> is obviously algebra
but not <span class="math inline">\(\sigma\)</span>-algebra</p></li>
<li><p>Lemma</p>
<p>If <span class="math inline">\(\mathcal S\)</span> is a semi-algebra
, then <span class="math inline">\(\bar{\mathcal S}=\{\text{finite
disjoint union of sets in }\mathcal S\}\)</span> is algebra .</p>
<p><span class="math inline">\(\bar{\mathcal S}\)</span> is called the
algebra generated by <span class="math inline">\(\mathcal S\)</span>
.</p>
<blockquote>
<p>Proof : easy to check two properties of algebra</p>
</blockquote>
<blockquote>
<p>Question : Is this generation the smallest generation ?</p>
</blockquote></li>
<li><p>Def : [measure for algebra] a measure <span
class="math inline">\(\mu\)</span> on an algebra <span
class="math inline">\(\mathcal A\)</span> satisfies :</p>
<ul>
<li><p><span class="math inline">\(\forall A\in \mathcal A , \mu(A)\ge
\mu(\varnothing)=0\)</span></p></li>
<li><p>If <span class="math inline">\(A_i\in \mathcal A\)</span> is a
disjoint sequence , and <span class="math inline">\(\cup_i A_i\in
\mathcal A\)</span> , then <span class="math display">\[
\mu(\cup_i A_i)=\sum_{i}\mu(A_i)
\]</span></p></li>
</ul>
<p>Def : [<span class="math inline">\(\sigma\)</span>-finite] If there
exists a sequence of sets $A_nA $ , $(A_n)&lt;$ , <span
class="math inline">\(\cup_n A_n=\Omega\)</span> .</p>
<blockquote>
<p>We can let <span class="math inline">\(A_n&#39;=\cup_{i=1}^n
A_i\)</span> , then <span class="math inline">\(A_n&#39;\uparrow
\Omega\)</span> .</p>
<p>We can let <span
class="math inline">\(A_n&#39;=A_n\cap(\cap_{i=1}^{n-1}A_i^c)\)</span> ,
then <span class="math inline">\(A_n&#39;\)</span> are disjoint .</p>
<p>即，在构造这样的 <span class="math inline">\(A_n\)</span>
的时候，我们可以直接考虑 <span class="math inline">\(A_n\uparrow
\Omega\)</span> 或 <span class="math inline">\(A_n\)</span> 不交</p>
</blockquote></li>
<li><p>Thm : <span class="math inline">\(\mathcal S\)</span> is a
semi-algebra , <span class="math inline">\(\mu\)</span> defined on <span
class="math inline">\(\mathcal S\)</span> with <span
class="math inline">\(\mu(\varnothing)=0\)</span></p>
<ol type="i">
<li>. If <span class="math inline">\(\mu\)</span> satisfies :</li>
</ol>
<ul>
<li>If <span class="math inline">\(S\in \mathcal S\)</span> is a finite
disjoint union of sets <span class="math inline">\(S_i\in \mathcal
S\)</span> , then <span
class="math inline">\(\mu(S)=\sum_{i}\mu(S_i)\)</span></li>
<li>If <span class="math inline">\(S_i,S\in \mathcal S\)</span> , <span
class="math inline">\(S=+_{i\ge 1} S_i\)</span> , then <span
class="math inline">\(\mu(S)\le \sum_{i\ge 1} \mu(S_i)\)</span></li>
</ul>
<p>Then <span class="math inline">\(\mu\)</span> has a unique extension
<span class="math inline">\(\bar \mu\)</span> that is a measure on <span
class="math inline">\(\bar{\mathcal S}\)</span> .</p>
<ol start="2" type="i">
<li>. If <span class="math inline">\(\bar\mu\)</span> is <span
class="math inline">\(\sigma\)</span>-finite , then there is a unique
extension <span class="math inline">\(\hat \mu\)</span> that is a
measure on <span class="math inline">\(\sigma(\mathcal S)\)</span>
.</li>
</ol></li>
<li><p>Lemma : If <span class="math inline">\(\mathcal S\)</span> is a
semi-algebra , <span class="math inline">\(\mu\)</span> defined on <span
class="math inline">\(\mathcal S\)</span> with <span
class="math inline">\(\mu(\varnothing)=0\)</span> . If <span
class="math inline">\(S\in \mathcal S\)</span> is a finite disjoint
union of sets <span class="math inline">\(S_i\in \mathcal S\)</span> ,
then <span class="math inline">\(\mu(S)=\sum_{i}\mu(S_i)\)</span> . Then
,</p>
<ul>
<li>If <span class="math inline">\(A,B_i\in \bar{\mathcal S}\)</span> ,
<span class="math inline">\(A=+_{i=1}^n B_i\)</span> , then <span
class="math inline">\(\bar \mu(A)=\sum_{i=1}^n
\bar\mu(B_i)\)</span></li>
<li>If <span class="math inline">\(A,B_i\in \bar{\mathcal S}\)</span> ,
<span class="math inline">\(A\subset \cup_{i=1}^n B_i\)</span> , then
<span class="math inline">\(\bar \mu(A)\le \sum_{i=1}^n
\bar\mu(B_i)\)</span></li>
</ul>
<blockquote>
<p>相当于，上面 (i) 中如果第一个条件成立，对于有限情况下的 第二个条件
一定成立，并可以直接扩展到 <span class="math inline">\(\bar{\mathcal
S}\)</span> 和 <span class="math inline">\(\bar \mu\)</span> 上 。</p>
</blockquote></li>
<li><p>可以借助 Thm , 证明 Stieltjes measure function 对应的 measure
存在，且证明过程需要左开。</p></li>
<li><p>(*) measure on <span class="math inline">\(\mathbb
R^d\)</span></p>
<ol type="1">
<li><p>直接采用类似 Stieltjes measure function 的条件构造 measure
是不够的</p>
<p>Restrictions :</p>
<ul>
<li>non-decreasing : If <span class="math inline">\(\vec x\le \vec
y\)</span> ( <span class="math inline">\(\forall i\in [d] , x_i\le
y_i\)</span>) , then <span class="math inline">\(F(\vec x)\le F(\vec
y)\)</span></li>
<li>right-continuous : Define <span class="math inline">\(\vec
y\downarrow \vec x\)</span> as <span class="math inline">\(\forall i\in
[d] , y_i\downarrow x_i\)</span> , then <span
class="math inline">\(\lim_{\vec y\downarrow \vec x}F(\vec y)=F(\vec
x)\)</span></li>
<li>(probability measure) <span class="math inline">\(\lim\limits_{\vec
x\downarrow -\infty}F(\vec x)=0\)</span> , <span
class="math inline">\(\lim_{\vec x\uparrow +\infty}F(\vec
x)=1\)</span></li>
</ul>
<p>Problem : <span class="math display">\[
F(x_1,x_2)=\begin{cases}
1&amp;x_1\ge 1,x_2\ge 1\\
\frac{2}{3}&amp;x_1\ge 1,x_2\in [0,1)\\
\frac{2}{3}&amp;x_1\in [0,1),x_2\ge 1\\
0&amp;\text{otherwise}
\end{cases}
\]</span></p>
<p><span class="math display">\[
\mu((a_1,b_1]\times(a_2,b_2])=F(b_1,b_2)-F(a_1,b_2)-F(b_1,a_2)+F(a_1,a_2)
\]</span></p>
<p>Let $a_1,a_2=1-$ , <span class="math inline">\(b_1,b_2=1\)</span> ,
<span class="math inline">\(\epsilon \to 0\)</span> , then <span
class="math display">\[
\mu(\{1\}\times\{1\})=-\frac{1}{3}&lt;0
\]</span></p></li>
<li><p>Def : [ <span class="math inline">\(\mathbb R^d\)</span> measure
]</p>
<p>Consider finite rectangles <span
class="math inline">\(A=(a_1,b_1]\times\cdots\times(a_d,b_d]\)</span> ,
<span
class="math inline">\(V=\{a_1,b_1\}\times\cdots\times\{a_d,b_d\}\)</span></p>
<p>If <span class="math inline">\(v\in V\)</span> , define <span
class="math display">\[
sgn(v)=(-1)^{|\{i\in [d]|v_i=a_i\}|}\\
\Delta_A F:=\sum_{v\in V}sgn(v)F(v)
\]</span> let <span class="math inline">\(\mu(A)=\Delta_A F\)</span>
.</p>
<blockquote>
<p>此处相当于 <span class="math inline">\(d\)</span>
维前缀和与差分，<span class="math inline">\(V\)</span> 相当于 <span
class="math inline">\(d\)</span> 维矩形 <span
class="math inline">\(A\)</span> 的所有顶点，<span
class="math inline">\(sgn(v)\)</span> 相当于顶点 <span
class="math inline">\(v\)</span> 有多少维是左顶点，然后容斥求差分。</p>
</blockquote></li>
<li><p>Thm : [<span class="math inline">\(\mathbb R^d\)</span> measure ]
If <span class="math inline">\(F:\mathbb R^d\to [0,1]\)</span> ,
satisfies the <span class="math inline">\(3\)</span> restrictions above
, and for all rectangles <span class="math inline">\(A\)</span> , <span
class="math inline">\(\Delta_A F\ge 0\)</span> . Then there is a unique
probability measure <span class="math inline">\(\mu\)</span> on <span
class="math inline">\((\mathbb R^d,\mathcal R^d)\)</span> that <span
class="math inline">\(\mu(A)=\Delta_A F\)</span> for all finite
rectangles .</p></li>
<li><blockquote>
<p>If <span class="math inline">\(F(\vec x)=\prod_{i=1}^d
F_i(x_i)\)</span> , <span class="math inline">\(F_i\)</span> are all
Stieltjes measure function , then <span class="math display">\[
\Delta_A F=\prod_{i=1}^d (F_i(b_i)-F_i(a_i))
\]</span> When <span class="math inline">\(F_i(x)=x\)</span> for all
<span class="math inline">\(i\in [d]\)</span> , <span
class="math inline">\(F\)</span> is Lebesgue measure on <span
class="math inline">\(\mathbb R^d\)</span> .</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="random-variables">1.2 Random Variables</h3>
<ol type="1">
<li><p>measurable map</p>
<ol type="1">
<li><p>Def : [measurable map] <span class="math inline">\(X:\Omega\to
S\)</span> is a measurable map from <span
class="math inline">\((\Omega,\mathcal F)\)</span> to <span
class="math inline">\((S,\mathcal S)\)</span> if <span
class="math display">\[
\forall B\in \mathcal S , X^{-1}(B):=\{w\in \Omega|X(w)\in B\}\in
\mathcal F
\]</span> Def : [random vector] When <span
class="math inline">\((S,\mathcal S)=(\mathbb R^d,\mathcal R^d)\)</span>
, <span class="math inline">\(X\)</span> is random vector .</p>
<p>Def : [random variable] When <span class="math inline">\((S,\mathcal
S)=(\mathbb R,\mathcal R)\)</span> , <span
class="math inline">\(X\)</span> is a random variable .</p></li>
<li><blockquote>
<p>虽然 measurable map 写作 from <span
class="math inline">\((\Omega,\mathcal F)\)</span> to <span
class="math inline">\((S,\mathcal S)\)</span> ，但 <span
class="math inline">\(X\)</span> 本身并不实现 <span
class="math inline">\(\mathcal F\to\mathcal S\)</span> 的映射，只有
<span class="math inline">\(\Omega\to S\)</span> 的映射。 <span
class="math inline">\(\mathcal F,\mathcal S\)</span> 是表明 measurable
的"范围"</p>
</blockquote>
<blockquote>
<p>Random variable is not a variable but a (measurable) map</p>
<p>这也很好解释了 <span class="math inline">\(E(X^2)\)</span>
这种类型的记号的实际含义</p>
</blockquote></li>
<li><p>Thm [a sufficient condition for measurable map]</p>
<p><span class="math inline">\(X:\Omega\to S\)</span> , $A $ : a
collection of some subsets of <span class="math inline">\(S\)</span> ,
If</p>
<ul>
<li><span class="math inline">\(\forall A\in \mathcal A , X^{-1}(A)\in
\mathcal F\)</span></li>
<li><span class="math inline">\(\mathcal A\)</span> generates <span
class="math inline">\(\mathcal S\)</span></li>
</ul>
<p>Then <span class="math inline">\(X\)</span> is a measurable map from
<span class="math inline">\((\Omega,\mathcal F)\)</span> to <span
class="math inline">\((S,\mathcal S)\)</span> .</p>
<blockquote>
<p>Proof : Prove <span class="math inline">\(\mathcal B=\{B\subset
S|X^{-1}(B)\in \mathcal F\}\)</span> is a <span
class="math inline">\(\sigma\)</span>-field , and obviously <span
class="math inline">\(\mathcal A\subset \mathcal B\)</span> . Consider
generation is the smallest , <span class="math inline">\(\mathcal
S\subset \mathcal B\)</span> .</p>
</blockquote></li>
<li><p>E.g. <span class="math inline">\(f:\mathbb R^d\to \mathbb
R\)</span> : <span class="math inline">\(f(x_1,\cdots,x_d)=\sum_{i=1}^d
x_i\)</span> is a measurable map from <span
class="math inline">\((\mathbb R^d,\mathcal R^d)\)</span> to <span
class="math inline">\((\mathbb R,\mathcal R)\)</span> .</p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>概率与统计</category>
      </categories>
      <tags>
        <tag>概率论-概率空间</tag>
        <tag>实分析-测度</tag>
        <tag>实分析-代数空间</tag>
        <tag>实分析-测度-可测映射</tag>
        <tag>概率论-随机变量</tag>
      </tags>
  </entry>
  <entry>
    <title>答疑坊 线性代数 趣题若干</title>
    <url>/2023/10/07/%E7%AD%94%E7%96%91%E5%9D%8A-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%B6%A3%E9%A2%98%E8%8B%A5%E5%B9%B2/</url>
    <content><![CDATA[<h3 id="t1">T1</h3>
<p>类型：行列式计算，加行列技巧</p>
<h4 id="题目">题目</h4>
<p>求矩阵 <span class="math inline">\(A\)</span> 的行列式，其中 <span
class="math inline">\(A\)</span> 定义为： <span class="math display">\[
A_{ij}=\begin{cases}a_i+b_j+1&amp;i=j\\a_i+b_j\end{cases}
\]</span></p>
<h4 id="解答">解答</h4>
<p>（自己不会做，求助大佬的）</p>
<p><img src="/images/posts/DYF_Linear_Algebra_fig1.jpg" /></p>
]]></content>
      <categories>
        <category>答疑坊</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>答疑坊</tag>
        <tag>线性代数</tag>
        <tag>线性方程组</tag>
        <tag>矩阵</tag>
        <tag>行列式</tag>
        <tag>对角化</tag>
      </tags>
  </entry>
  <entry>
    <title>答疑坊 微积分 趣题若干</title>
    <url>/2023/10/07/%E7%AD%94%E7%96%91%E5%9D%8A-%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%B6%A3%E9%A2%98%E8%8B%A5%E5%B9%B2/</url>
    <content><![CDATA[<h3 id="p1">P1</h3>
<p>类型：极限存在性</p>
<h4 id="题目">题目</h4>
<p>证明下面的极限存在： <span class="math display">\[
\lim_{n\to
+\infty}(1+\frac{1}{2^2})(1+\frac{1}{3^2})\cdots(1+\frac{1}{n^2})
\]</span></p>
<h4 id="解答">解答</h4>
<p>显然上述数列单调增，因此只需要证明有上界 <span
class="math display">\[
\begin{aligned}
&amp;\quad \prod_{k=2}^n (1+\frac{1}{k^2})\\
&amp;=\exp\left(\sum_{k=2}^n \ln (1+\frac{1}{k^2})\right)\\
&amp;\le \exp\left(\sum_{k=2}^n \frac{1}{k^2}\right)\\
&amp;\le \exp\left(\sum_{k=2}^n \frac{1}{k(k-1)}\right)\\
&amp;=\exp\left(\sum_{k=1}^n \frac{1}{k-1}-\frac{1}{k}\right)\\
&amp;=\exp(1-\frac{1}{n})\\
&amp;\le e
\end{aligned}
\]</span> 其中第 <span class="math inline">\(3\)</span> 行使用常见不等式
<span class="math inline">\(\ln(1+x)\le x\)</span> ，第 <span
class="math inline">\(4\sim 6\)</span> 行为裂项。</p>
<hr />
<h3 id="p2">P2</h3>
<p>类型：<span class="math inline">\(e\)</span> 相关极限不等式</p>
<h4 id="题目-1">题目</h4>
<p>证明，对任意正整数 <span class="math inline">\(n\ge 2\)</span> ，
<span class="math display">\[
\sum_{k=0}^n
\frac{1}{k!}-\frac{3}{2n}&lt;(1+\frac{1}{n})^n&lt;\sum_{k=0}^n
\frac{1}{k!}
\]</span></p>
<h4 id="解答-1">解答</h4>
<p>使用二项式定理 <span class="math display">\[
\begin{aligned}
(1+\frac{1}{n})^n&amp;=\sum_{k=0}^n \frac{n!}{k!(n-k)!}\frac{1}{n^k}\\
&amp;=\sum_{k=0}^n \frac{1}{k!}\prod_{j=0}^{k-1}(1-\frac{j}{n})
\end{aligned}
\]</span> 显然对 <span class="math inline">\(n\ge 2\)</span> , <span
class="math inline">\(\prod_{j=0}^{k-1}(1-\frac{j}{n})&lt; 1\)</span>
，故右侧不等式成立。</p>
<p>考虑 Bernoulli 不等式： <span class="math display">\[
\forall a_1,\cdots,a_n&gt;-1,且a_i 同号，则\prod_{k=1}^n
(1+a_k)&gt;1+\sum_{k=1}^n a_k
\]</span> 故 <span class="math display">\[
\begin{aligned}
(1+\frac{1}{n})^n&amp;&gt;\sum_{k=0}^n\left(
\frac{1}{k!}-\frac{1}{k!}\sum_{j=1}^{k-1}\frac{j}{n}\right)\\
&amp;=\sum_{k=0}^n \frac{1}{k!}-\sum_{k=0}^n
\frac{1}{k!}\frac{k(k-1)}{2n}\\
&amp;=\sum_{k=0}^n \frac{1}{k!}-\sum_{k=2}^n
\frac{1}{(k-2)!}\frac{1}{2n}\\
&amp;\ge \sum_{k=0}^n \frac{1}{k!}-\frac{1}{2n}\left(2+\sum_{k=2}^{n-2}
\frac{1}{k(k-1)}\right)\\
&amp;=\sum_{k=0}^n \frac{1}{k!}-\frac{1}{2n}(3-\frac{1}{n-2})\\
&amp;&gt;\sum_{k=0}^n \frac{1}{k!}-\frac{3}{2n}
\end{aligned}
\]</span></p>
<hr />
]]></content>
      <categories>
        <category>答疑坊</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>答疑坊</tag>
        <tag>微积分</tag>
        <tag>多元微积分</tag>
        <tag>级数</tag>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title>答疑坊 程设/离散/DSA 趣题若干</title>
    <url>/2023/10/07/%E7%AD%94%E7%96%91%E5%9D%8A-%E7%A8%8B%E8%AE%BE-DSA-%E8%B6%A3%E9%A2%98%E8%8B%A5%E5%B9%B2/</url>
    <content><![CDATA[<h3 id="p1">P1</h3>
<h4 id="问题描述">问题描述</h4>
<p>输入 <span class="math inline">\(3n-1\)</span> 个数，其中 <span
class="math inline">\(n-1\)</span> 个数出现恰好 <span
class="math inline">\(3\)</span> 次，<span
class="math inline">\(1\)</span> 个数恰好出现 <span
class="math inline">\(2\)</span> 次。求这个出现 <span
class="math inline">\(2\)</span> 次的数。</p>
<p>要求，时间复杂度 <span class="math inline">\(\tilde {\mathcal
O}(n)\)</span> , 空间复杂度 <span class="math inline">\(\mathcal
O(1)\)</span> .</p>
<h4 id="算法分析">算法分析</h4>
<p>考虑使用三进制不进位加法，显然满足交换律、结合律，且 <span
class="math inline">\(a\oplus a\oplus a=0\)</span> ，出现 <span
class="math inline">\(3\)</span> 次的数都抵消掉，只剩下恰好出现 <span
class="math inline">\(2\)</span> 次的那个数 <span
class="math inline">\(a\)</span> 的 "2倍"。</p>
<p>对最后结果 <span class="math inline">\(sum\)</span> 求 <span
class="math inline">\(sum\oplus sum\)</span> 。因 <span
class="math inline">\(sum=a\oplus a\)</span> , 故 <span
class="math inline">\(sum\oplus sum=a\oplus a\oplus a\oplus a=a\)</span>
。</p>
]]></content>
      <categories>
        <category>答疑坊</category>
        <category>程设/离散/DSA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>答疑坊</tag>
        <tag>程序设计</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 3</title>
    <url>/2023/10/07/Algorithm-Design-3/</url>
    <content><![CDATA[<h2 id="chapter-2-greedy-algorithm">Chapter 2 Greedy Algorithm</h2>
<h3 id="minimum-spanning-tree-undirected">2.3 Minimum Spanning Tree
(undirected)</h3>
<ol type="1">
<li><p>Definition</p>
<ol type="1">
<li><p>Input : undirected , edge-weighted graph <span
class="math inline">\(G\)</span></p></li>
<li><p>Output : Minimum Spanning Tree of <span
class="math inline">\(G\)</span></p>
<p>Spanning Tree : a subgraph of <span class="math inline">\(G\)</span>
that is a tree containing all vertices</p>
<p>Minimum : the sum of weights on tree's all edges is
minimized</p></li>
</ol></li>
<li><p>Properties</p>
<ol type="1">
<li><p>Spanning Tree</p>
<ol type="1">
<li>Connectivity <span class="math inline">\(\leftrightarrow\)</span>
check connectivity <span class="math inline">\(\to\)</span>
<strong>cut</strong></li>
<li>Acyclic</li>
</ol></li>
<li><p>Cut</p>
<ol type="1">
<li><p>Def : Graph <span class="math inline">\(G=(V,E),V=A\cup B,A\cap
B=\varnothing\)</span></p>
<p><span class="math inline">\((A,B)\)</span>-cut : <span
class="math inline">\(E(A,B)=\{(u,v)\in E|u\in A,v\in
B\}\)</span></p></li>
<li><p>Observation : If <span class="math inline">\(T\)</span> is a
Spanning Tree , <span class="math inline">\(E(A,B)\)</span> is any cut ,
then <span class="math inline">\(T\cap E(A,B)\neq
\varnothing\)</span></p>
<blockquote>
<p>Otherwise , not connected</p>
</blockquote></li>
</ol></li>
<li><p>Lemma : Assumption : weights are distinct</p>
<p>Suppose <span class="math inline">\(e=(u,v),u\in A,v\in B\)</span> is
the edge with minimum weight in <span
class="math inline">\((A,B)\)</span>-cut , then every MST must contain
<span class="math inline">\(e\)</span> .</p>
<p>Proof : [Exchange Argument , Prove by contradiction]</p>
<p>Suppose <span class="math inline">\(T\)</span> is a MST but <span
class="math inline">\(e\notin T\)</span> . By the observation , there
exists <span class="math inline">\(e&#39;\in T,e&#39;\in E(A,B)\)</span>
.</p>
<p>Let <span class="math inline">\(T&#39;=T-e&#39;+e\)</span> , then
<span class="math inline">\(T\)</span> is still connected , with smaller
weight .</p></li>
</ol></li>
</ol>
<div class="note warning"><p>Problem : <span class="math inline">\(T\)</span> can have cycle !</p>
</div>
<div class="note success"><p>Correction :<br />
Choose one specific <span class="math inline">\(e&#39;\)</span> : <span
class="math inline">\(e\notin T\)</span> , then <span
class="math inline">\(e\)</span> and some edges in <span
class="math inline">\(T\)</span> can form a cycle ( the path from <span
class="math inline">\(u\)</span> to <span
class="math inline">\(v\)</span> on <span
class="math inline">\(T\)</span> ). This cycle must contain an edge
<span class="math inline">\(e&#39;\in E(A,B)\)</span> .</p>
</div>
<ol start="3" type="1">
<li><p>Kruskal's Algorithm</p>
<ol type="1">
<li><p>Algorithm</p>
<p>Successively inserting edges from <span
class="math inline">\(E\)</span> in increasing order of weight .</p>
<p>If edge <span class="math inline">\(e\)</span> would create a cycle .
discard it .</p>
<p>(Using Union-Find Set)</p></li>
<li><p>Proof of Correctness</p>
<p>Consider every added edge <span class="math inline">\(e\)</span> ,
<span class="math inline">\(e\)</span> is the min-weight edge in some
cut</p>
<p><span class="math inline">\(e=(u,v)\)</span> , consider the connected
component <span class="math inline">\(C\)</span> containing <span
class="math inline">\(u\)</span> , then <span
class="math inline">\(e\)</span> is the minimum weight edge in cut <span
class="math inline">\(E(C,V\backslash C)\)</span></p></li>
</ol></li>
<li><p>Prim's Algorithm</p>
<ol type="1">
<li><p>Algorithm</p>
<p>At each step , add the node that can be attached as cheaply as
possible to the partial tree we already have .</p></li>
<li><p>Naive Implementation</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// d[x] : current minimum edge in cut E(&#123;x&#125;,S)</span></span><br><span class="line"><span class="comment">// Init </span></span><br><span class="line"><span class="keyword">for</span> (v in V)&#123;</span><br><span class="line">    d[v]=+inf;</span><br><span class="line">&#125;</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;S.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(S!=V)&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">argmin</span>(d[v] | v in V\S);</span><br><span class="line">    S.<span class="built_in">insert</span>(x); <span class="comment">// using the edge d[x]</span></span><br><span class="line">    <span class="keyword">for</span>(y in <span class="built_in">Neighbour</span>(x))&#123;</span><br><span class="line">        d[y]=<span class="built_in">min</span>(d[y],<span class="built_in">w</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Improvement : Priority Queue</p></li>
</ol></li>
<li><p>Reverse Deletion</p>
<p>Successively removing edges from <span
class="math inline">\(E\)</span> in decreasing order of weight .</p>
<p>If removing edge <span class="math inline">\(e\)</span> would cause
disconnectedness , discard it .</p>
<blockquote>
<p>The reverse version of Kruskal's Algorithm</p>
</blockquote></li>
<li><p>Faster algorithms</p>
<p>[Chazelle] Deterministic Algorithm <span
class="math inline">\(\mathcal O(|E|\alpha(|E|))\)</span></p>
<blockquote>
<p>This means MST is weaker than sorting</p>
</blockquote>
<p>[Karger , Klem , Tarjan] Randomized Algorithm <span
class="math inline">\(\mathcal O(|E|+|V|)\)</span></p>
<p><strong>Open Question</strong> : Deterministic Linear
Algorithm</p></li>
</ol>
<h3 id="union-find-set">2.4 Union-Find Set</h3>
<ol type="1">
<li><p>Definition</p>
<p>Maintain sets of elements , support :</p>
<ol type="1">
<li><code>find(element e)</code> , return the set that contains <span
class="math inline">\(e\)</span></li>
<li><code>union(set Si,set Sj)</code> , combine set <span
class="math inline">\(S_i\)</span> and <span
class="math inline">\(S_j\)</span> , return the union set <span
class="math inline">\(S_i\cup S_j\)</span></li>
</ol></li>
<li><p>Implementation</p>
<p>The sets can be viewed as trees .</p>
<p>The set can be represented by the root of the corresponding tree
.</p>
<p><code>find</code> : find the root of the tree (keep finding
father)</p>
<p><code>union</code> : <span
class="math inline">\(fa(root(S_1))\leftarrow root(S_2)\)</span></p>
<p>Problem : tree can be very deep</p></li>
<li><p>Improve</p>
<ol type="1">
<li><p>启发式合并 / Heuristic merging</p>
<p>To make the tree shallow , suppose <span
class="math inline">\(|S_1|\le |S_2|\)</span></p>
<p>小集合合并到大集合上</p></li>
<li><p>路径压缩 / Path Compression</p>
<p>Suppose one find : <span
class="math inline">\(e,v_1,\cdots,v_k,root\)</span> , after the find ,
let <span
class="math inline">\(fa(e)=fa(v_1)=\cdots=fa(v_k)=root\)</span></p></li>
</ol></li>
<li><p>Time Complexity</p>
<p>Amortized Analysis / 均摊分析 ( using Path Compression and Heuristic
merging)</p>
<p>Suppose we have a sequence of <code>find</code> or <code>union</code>
operations , with length <span class="math inline">\(m\)</span> .</p>
<p>Total running time of union-find is <span
class="math inline">\(\mathcal O(m\alpha(m,n))\)</span></p>
<p><span class="math inline">\(\alpha\)</span> : inverse Ackermann's
function , grows very slow</p>
<blockquote>
<p>Another slow function : <span
class="math inline">\(\log^*(n)\)</span> , number of logs to make <span
class="math inline">\(n\)</span> to small constant (i.e. <span
class="math inline">\(\log(\log\cdots\log(n))\le 5\)</span>)</p>
</blockquote>
<p>See [CLRS] for detailed proof .</p></li>
<li><p>Kruskal's Algorithm Implementation</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(E); <span class="comment">// weight-increasing</span></span><br><span class="line"><span class="keyword">for</span>(edge e=(u,v):E)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(u)!=<span class="built_in">find</span>(v))&#123;</span><br><span class="line">        T.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="built_in">union</span>(<span class="built_in">find</span>(u),<span class="built_in">find</span>(v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Total time complexity : <span class="math inline">\(\mathcal
O(|E|\log|E|)\)</span> .</p></li>
</ol>
<h3 id="priority-queue">2.5 Priority Queue</h3>
<ol type="1">
<li><p>Definition</p>
<p>Maintain a set of elements <span class="math inline">\(S\)</span> ,
support :</p>
<p><code>insert(S,x)</code> , insert <span
class="math inline">\(x\)</span> into <span
class="math inline">\(S\)</span> .</p>
<p><code>extract_max(S)</code> , return the maximum element in <span
class="math inline">\(S\)</span> , and then remove this element .</p>
<p><code>max(S)</code> , return the maximum element in <span
class="math inline">\(S\)</span></p>
<p><code>increase_key(S,x,k)</code> , increase value of <span
class="math inline">\(x\)</span> by <span
class="math inline">\(k\)</span></p></li>
<li><p>(Basic) (max) Heap</p>
<ol type="1">
<li><p>Property : Complete binary tree , parent $$ both
children</p></li>
<li><p>Can be implemented in an array</p>
<p><code>fa[x]=x/2</code> , <code>left_child[x]=2x</code> ,
<code>right_child[x]=2x+1</code></p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(S,x)&#123; <span class="comment">// flow down , O(log n)</span></span><br><span class="line">    val[|S|]=x;|S|++;</span><br><span class="line">    <span class="type">int</span> p=|S|<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=root&amp;&amp;val[p]&gt;val[fa[p]])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(val[p],val[fa[p]]);</span><br><span class="line">        p=fa[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Note : build a heap : O(n)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">extract_max</span>(S)&#123; <span class="comment">// flow up , O(log n)</span></span><br><span class="line">    <span class="type">int</span> ret_val=val[root];</span><br><span class="line">    <span class="built_in">swap</span>(val[root],val[|S|<span class="number">-1</span>]); <span class="comment">// swap the root and the last element</span></span><br><span class="line">    |S|--; <span class="comment">// delete original root</span></span><br><span class="line">    <span class="type">int</span> p=root;</span><br><span class="line">    <span class="keyword">while</span>(val[p]&lt;val[left_child[p]]||val[p]&lt;val[right_child[p]])&#123;</span><br><span class="line">        <span class="keyword">if</span>(val[left_child[p]]&gt;val[right_child[p]])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(val[p],val[left_child[p]]);</span><br><span class="line">            p=left_child[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(val[p],val[right_child[p]]);</span><br><span class="line">            p=right_child[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(S)&#123; <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> val[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">increase_key</span>(S,p,k)&#123; <span class="comment">// flow down , O(log n)</span></span><br><span class="line">    val[p]=val[p]+k;</span><br><span class="line">    <span class="keyword">while</span>(p!=root&amp;&amp;val[p]&gt;val[fa[p]])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(val[p],val[fa[p]]);</span><br><span class="line">        p=fa[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Advanced : Fibonacci Heap</p>
<p>Time complexity (amortized-time)</p>
<table>
<thead>
<tr class="header">
<th>operations</th>
<th>binary heap</th>
<th>Fibonacci heap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>insert</code></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
</tr>
<tr class="even">
<td><code>extract_max</code></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
</tr>
<tr class="even">
<td><code>increase_key</code></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>See [CLRS] for detailed Fibonacci heap .</p></li>
<li><p>Prim's Algorithm with Priority Queue</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using min priority queue</span></span><br><span class="line"><span class="keyword">for</span> (v in V\&#123;<span class="number">1</span>&#125;)&#123;</span><br><span class="line">    d[v]=+inf;</span><br><span class="line">    inS[v]=<span class="literal">false</span>;</span><br><span class="line">    PQ.<span class="built_in">insert</span>((v,+inf));</span><br><span class="line">&#125;</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;inS[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">PQ.<span class="built_in">insert</span>((<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="comment">// index 1 , value 0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123; <span class="comment">// n-1 rounds</span></span><br><span class="line">    <span class="type">int</span> x=PQ.<span class="built_in">extract_min</span>(); <span class="comment">// argmin value</span></span><br><span class="line">    inS[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// using edge d[x]</span></span><br><span class="line">    <span class="keyword">for</span>(y in <span class="built_in">Neighbour</span>(x))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inS[y] &amp;&amp; <span class="built_in">w</span>(x,y)&lt;d[y])&#123;</span><br><span class="line">            PQ.<span class="built_in">decrease_key</span>(y,d[y]-<span class="built_in">w</span>(x,y));</span><br><span class="line">            d[y]=<span class="built_in">w</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : <span class="math inline">\(\mathcal O(|E|\log
|V|)\)</span> .</p></li>
<li><p>Dijkstra's Algorithm with Priority Queue</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using min priority queue</span></span><br><span class="line"><span class="keyword">for</span>(v in V\&#123;s&#125;)&#123;</span><br><span class="line">    d[v]=+inf;</span><br><span class="line">    inS[v]=<span class="literal">false</span>;</span><br><span class="line">    PQ.<span class="built_in">insert</span>((v,+inf))</span><br><span class="line">&#125;</span><br><span class="line">d[s]=<span class="number">0</span>;inS[s]=<span class="literal">true</span>;</span><br><span class="line">PQ.<span class="built_in">insert</span>((v,+inf));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123; <span class="comment">// n-1 rounds</span></span><br><span class="line">    <span class="type">int</span> x=PQ.<span class="built_in">extract_min</span>();</span><br><span class="line">    inS[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(y in <span class="built_in">Neighbour</span>(x))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inS[y] &amp;&amp; d[y] &gt; d[x]+<span class="built_in">w</span>(x,y) )&#123;</span><br><span class="line">            PQ.<span class="built_in">decrease_key</span>(d[y]-d[x]-<span class="built_in">w</span>(x,y));</span><br><span class="line">            d[y]=d[x]+<span class="built_in">w</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : <span class="math inline">\(\mathcal O(|E|\log
|V|)\)</span> .</p></li>
</ol>
<h3 id="huffman-code">2.6 Huffman Code</h3>
<ol type="1">
<li><p>Code Definition : a set <span class="math inline">\(S\)</span> of
letters encode to <span class="math inline">\(\{0,1\}^*\)</span> , <span
class="math inline">\(r:S\to \{0,1\}^*\)</span></p>
<p>Properties</p>
<ol type="1">
<li><span class="math inline">\(r\)</span> is one-to-one /
injection</li>
<li>encoding / decoding efficiently</li>
<li>minimize average length of the code</li>
<li>[optional] robust to errors , Error Correction Code</li>
</ol></li>
<li><p>Prefix Code</p>
<ol type="1">
<li><p>Def : <span class="math inline">\(\forall x,y\in S\)</span> ,
<span class="math inline">\(r(x)\)</span> is not a prefix of <span
class="math inline">\(r(y)\)</span></p></li>
<li><p>Property : useful for decoding (unique decode) , can decode
greedily</p></li>
<li><p>e.g. <span class="math inline">\(S=\{a,b,c,d,e\}\)</span></p>
<p>Prefix Code <span class="math display">\[
r(a)=11,r(b)=01,r(c)=001,r(d)=10,r(e)=000
\]</span></p>
<p><span class="math display">\[
decode(0000011101)=decode(000\ 001\ 11\ 01)=ecab
\]</span></p>
<p>non-Prefix Code <span class="math display">\[
r(a)=110,r(b)=11,r(c)=01
\]</span></p>
<p><span class="math display">\[
decode(11011)=decode(110\ 11)=decode(11\ 01\ 1)
\]</span></p></li>
<li><p>Prefix Code can be represented using a binary tree</p>
<p>Leafy tree : each leaf corresponds to a letter</p></li>
</ol></li>
<li><p>Minimize the length</p>
<ol type="1">
<li><p>Average encoding length</p>
<p>Suppose each letter has a frequency <span
class="math inline">\(p(x)\)</span> , <span
class="math inline">\(\sum_{x\in S}p(x)=1\)</span> .</p>
<p>Average encoding length : <span class="math display">\[
AEL(r)=\sum_{x\in S}p(x)|r(x)|
\]</span></p></li>
<li><p>[Shannon] Source Coding Theorem <span class="math display">\[
\forall r,AEL(r)\ge \sum_{x\in S}-p(x)\log p(x) =:H
\]</span> See : [Thomas Cover] Information Theory</p></li>
</ol></li>
<li><p>Lemma</p>
<p>There is an optimal code ( or an optimal binary tree ) in which two
lowest-frequency letter are assigned to leaves that are as deep as
possible , and are siblings .</p>
<blockquote>
<p>Proof : 同层换：对 AEL 无影响；跨层： exchange argument</p>
</blockquote></li>
<li><p>Huffman's Code</p>
<p>Initially , construct a set <span class="math inline">\(S\)</span>
containing all letters.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(|S|&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    elem x,y;</span><br><span class="line">    x=<span class="built_in">extract_max</span>(S) , y=<span class="built_in">extract_max</span>(S);</span><br><span class="line">    elem new_elem=(id,<span class="built_in">p</span>(x)+<span class="built_in">p</span>(y));</span><br><span class="line">    <span class="built_in">insert</span>(S,new_elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-图论</tag>
        <tag>算法-图论-最小生成树</tag>
        <tag>算法-图论-最短路</tag>
        <tag>算法-数据结构-并查集</tag>
        <tag>算法-数据结构-堆/优先队列</tag>
        <tag>编码-Huffman编码</tag>
      </tags>
  </entry>
  <entry>
    <title>ZKP and MPC 1</title>
    <url>/2023/10/06/ZKP-and_MPC-1/</url>
    <content><![CDATA[<h2 id="lec01-basic-definitions-and-examples-of-zkp">Lec01 Basic
Definitions and Examples of ZKP</h2>
<h3 id="basic-notations">1 Basic Notations</h3>
<ol type="1">
<li><p>Complexity</p>
<ol type="1">
<li><p>Efficient Algorithm : poly-time algorithm .</p></li>
<li><p>NP class : class of problems that are easy to verify a solution
(but may be hard to solve it)</p>
<p>Formal def : Suppose <span class="math inline">\(L\subset
\{0,1\}^*\)</span> is a language . <span class="math inline">\(L\in
NP\)</span> if there exists a poly-time algorithm <span
class="math inline">\(\mathcal A\)</span> :</p>
<ul>
<li>If <span class="math inline">\(x\in L\)</span> , <span
class="math inline">\(\exists w\in \{0,1\}^{poly(|x|)}\)</span> , <span
class="math inline">\(\mathcal A(x,w)=1\)</span></li>
<li>If <span class="math inline">\(x\notin L\)</span> , <span
class="math inline">\(\forall w\in \{0,1\}^{poly(|x|)}\)</span> , <span
class="math inline">\(\mathcal A(x,w)=0\)</span></li>
</ul>
<p><span class="math inline">\(w\)</span> that makes <span
class="math inline">\(\mathcal A(x,w)=1\)</span> is called the proof of
<span class="math inline">\(x\in L\)</span> , and <span
class="math inline">\(\mathcal A\)</span> is called the verification
algorithm .</p></li>
</ol></li>
<li><p>Proof</p>
<ol type="1">
<li><p>Def : a static sequence of rules</p></li>
<li><p>E.g.1 : Prove that <span
class="math inline">\(f(x,y)=x^2y^3-5xy+4=0\)</span> has a solution
.</p>
<p>Proof 1 [Explicit Proof] : <span
class="math inline">\(f(1,1)=0\)</span></p>
<p>Proof 2 [Implicit Proof] : <span
class="math inline">\(f(2,1)&lt;0,f(2,2)&gt;0\)</span> .</p>
<p>( <span class="math inline">\(f(2,x)\)</span> is continuous , so
<span class="math inline">\(\exists x_0\in (1,2) , f(2,x_0)=0\)</span>
)</p></li>
</ol></li>
</ol>
<h3 id="interactive-proof">2 Interactive Proof</h3>
<ol type="1">
<li><p>Interactive Proof</p>
<ol type="1">
<li><p>A Prover and a Verifier , Prover needs to convince Verifier some
proposition .</p>
<p>Usually , Prover needs to convince Verifier that some proposition is
<strong>true</strong> . <span class="math inline">\((x\in
L)\)</span></p></li>
<li><p>Prover : with unbounded computation sources</p>
<p>Verifier : Only efficient algorithm</p></li>
<li><p>Complexity Class : IP : class of problems that are easy to
determine with an interactive proof</p>
<ul>
<li><span class="math inline">\(NP\subsetneq IP\)</span></li>
</ul></li>
<li><p>Transcript</p>
<p>Prover sends <span class="math inline">\(m_1\)</span> to Verifier ,
Verifier receives <span class="math inline">\(m_1\)</span> and sends
<span class="math inline">\(m_2\)</span> to Prover , ... <span
class="math display">\[
\begin{aligned}
P(x,r_p)\to m_1\quad \quad &amp;\\
V(x,r_v,m_1,\cdots,m_{i-1})\to m_i\quad&amp; \text{for odd }i\\
P(x,r_p,m_1,\cdots,m_{i-1})\to m_i\quad&amp; \text{for even }i\\
V(x,r_v,m_1,\cdots,m_k)\to y\in \{0,1\}&amp;
\end{aligned}
\]</span></p>
<ol type="1">
<li>Def : transcript : <span
class="math inline">\(\tau=\{m_1,\cdots,m_k\}\)</span></li>
<li>Def : <span class="math inline">\(\braket{P,V}(x):=y\)</span></li>
</ol></li>
</ol></li>
<li><p>IP Criteria</p>
<ol type="1">
<li><p>Completeness : If Prover is honest , Verifier accepts the proof
.</p>
<p><span class="math inline">\(\forall x\in L ,
\Pr\{\left&lt;P,V\right&gt;(x)=1\}=1\)</span></p></li>
<li><p>Soundness : If Prover is dishonest , Verifier rejects the proof
(with high probability) .</p></li>
<li><p>Zero-Knowledge : If Prover is honest , Verifier cannot know more
than "knowing the proposition is true"</p></li>
</ol></li>
<li><p>Definition (somewhat formal (?) )</p>
<p>A pair of randomized algorithms <span
class="math inline">\((P,V)\)</span> is an interactive proof for <span
class="math inline">\(L\)</span></p>
<ol type="1">
<li><p><span class="math inline">\(V\)</span> runs in poly-time</p></li>
<li><p>Completeness : <span class="math inline">\(\forall x\in L ,
\Pr\{\braket{P,V}(x)=1\}=1\)</span></p></li>
<li><p>Soundness : <span class="math inline">\(\forall x\notin L,\forall
P^*,\Pr\{\braket{P^*,V}(x)=1\}&lt; \epsilon\)</span></p></li>
<li><p>Zero-Knowledge (Optimal)</p>
<p><span class="math inline">\(\forall x\in L\)</span> , <span
class="math inline">\(V\)</span> can generate everything itself with
bounded computation time without interaction</p>
<p><strong>gain sth. cannot gain by PPT <span
class="math inline">\(\Rightarrow\)</span> gain
knowledge</strong></p></li>
</ol></li>
</ol>
<h3 id="ip-examples">3 IP Examples</h3>
<ol type="1">
<li><p>Graph non-Isomorphism</p>
<ol type="1">
<li><p>Description</p>
<p>Prover and Verifier know graphs <span
class="math inline">\(G_0,G_1\)</span> .</p>
<p>Prover wants to convince verifier that <span
class="math inline">\(G_0\)</span> is not isomorphic with <span
class="math inline">\(G_1\)</span> . <span class="math display">\[
\begin{aligned}
&amp;G_0=(V,E_0) , G_1=(V,E_1)\\
\not\exists \pi\in S_{|V|}&amp;\ ,\ \{(\pi(u),\pi(v)):(u,v)\in E_0\}=E_1
\end{aligned}
\]</span></p></li>
<li><p>Protocol</p>
<p>Global : Prover and Verifier already know <span
class="math inline">\(G_0,G_1\)</span> .</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 13%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th>Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(b\leftarrow \{0,1\}\)</span> , <span
class="math inline">\(\pi\leftarrow S_{|V|}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;- <span class="math inline">\(\tilde
G\)</span> --</td>
<td><span class="math inline">\(\tilde G:=\pi(G_b)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Find $b $ , <span
class="math inline">\(G_{\tilde b}\sim \tilde G\)</span></td>
<td style="text-align: center;">-- <span class="math inline">\(\tilde
b\)</span> -&gt;</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(y=\begin{cases}1&amp; \text{if }b=\tilde
b\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Analysis</p>
<ol type="1">
<li><p>Completeness : When <span class="math inline">\(G_0\not\sim
G_1\)</span> , <span class="math inline">\(G_{\tilde b}\sim \tilde G\sim
G_b\)</span> , so <span class="math inline">\(b=\tilde b\)</span> .
Always accept .</p></li>
<li><p>Soundness : When <span class="math inline">\(G_0\sim G_1\)</span>
, any prover can only guess <span class="math inline">\(\tilde
b\)</span> randomly since <span class="math inline">\(G_0\sim G_1\sim
\tilde G\)</span> . <span class="math inline">\(\Pr\{V\text{
accept}\}\le \frac{1}{2}\)</span> .</p>
<p>Proof : <span class="math inline">\(P^*\)</span> knows <span
class="math inline">\(\tilde G\)</span> and wants to guess <span
class="math inline">\(b\)</span> , we need to prove that <span
class="math display">\[
\forall P^* , \Pr\{P^*(\tilde G)=b\}\le \frac{1}{2}
\]</span> Since <span class="math inline">\(\forall \tilde G\sim G_0\sim
G_1\)</span> , <span class="math display">\[
\begin{aligned}
\Pr\{\pi(G_0)=\tilde G\}&amp;=\Pr\{\pi(G_1)=\tilde G\}\\
\Rightarrow \Pr\{\pi(G_b)=\tilde G|b=0\}&amp;=\Pr\{\pi(G_b)=\tilde
G|b=1\}\\
\Rightarrow \Pr\{b=0|\pi(G_b)=\tilde G\}&amp;=\Pr\{b=1|\pi(G_b)=\tilde
G\}\\
\end{aligned}
\]</span> Therefore , <span class="math display">\[
\forall P^* , \Pr\{P^*(\tilde G)=b|\pi(G_b)=\tilde G\}\le\frac{1}{2}
\]</span> Therefore , <span class="math display">\[
\begin{aligned}
\Pr\{P^*(\tilde G)=b\}&amp;=\sum_{\tilde G}\Pr\{P^*(\tilde
G)=b|\pi(G_b)=\tilde G\}\Pr\{\pi(G_b)=\tilde G\}\\
&amp;\le \frac{1}{2}\sum_{\tilde G}\Pr\{\pi(G_b)=\tilde G\}\\
&amp;=\frac{1}{2}
\end{aligned}
\]</span> <span class="math inline">\(k\)</span> rounds : <span
class="math inline">\(\Pr\{V\text{ accepts}\}\le \frac{1}{2^k}\)</span>
.</p></li>
<li><p>Zero-Knowledge</p>
<p>Verifier itself knows <span class="math inline">\(b,\pi,\tilde
G\)</span> . Prover tells Verifier <span class="math inline">\(\tilde
b\)</span> .</p>
<p>Only consider <span class="math inline">\(G_0\not\sim G_1\)</span> ,
then <span class="math inline">\(\tilde b\)</span> must be <span
class="math inline">\(b\)</span> . Verifier itself can generate the
transcript .</p>
<blockquote>
<p>注意：因为 zero-knowledge 是对 Prover 的保护，我们只需要保护诚实
Prover 的隐私，因此只要考虑命题成立的情况（即 <span
class="math inline">\(G_0\not\sim G_1\)</span>）。</p>
</blockquote></li>
</ol></li>
<li><p>Notes</p>
<blockquote>
<p>Given <span class="math inline">\(G_0\not\sim G_1\)</span> , Verifier
can generate the proof itself</p>
<p>Due to Verifier's randomness , Prover cannot generate the proof
itself</p>
</blockquote>
<blockquote>
<p>Graph non-isomorphism Problem is not <span
class="math inline">\(NP\)</span> , but can be solved by <span
class="math inline">\(IP\)</span> .</p>
</blockquote></li>
</ol></li>
<li><p>Collision Problem</p>
<ol type="1">
<li><p>Definition</p>
<ol type="1">
<li>Given <span class="math inline">\(h:\{0,1\}^n\to\{0,1\}^n\)</span> ,
either <span class="math inline">\(h\)</span> is a permutation or <span
class="math inline">\(|Im(h)|\le 2^{n-1}\)</span> .</li>
<li>Prover wants to convince Verifier that <span
class="math inline">\(h\)</span> is a permutation .</li>
</ol></li>
<li><p>Protocol 1</p>
<p>Global : Prover and Verifier already know <span
class="math inline">\(h\)</span> . <span class="math inline">\(\forall
x\in \{0,1\}^n\)</span> , Verifier can get <span
class="math inline">\(h(x)\)</span> in poly-time .</p>
<table style="width:100%;">
<colgroup>
<col style="width: 30%" />
<col style="width: 14%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(x\leftarrow
\{0,1\}^n\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;- <span
class="math inline">\(y\)</span> --</td>
<td style="text-align: center;"><span
class="math inline">\(y:=h(x)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Find <span class="math inline">\(\tilde
x\)</span> , <span class="math inline">\(h(\tilde x)=y\)</span></td>
<td style="text-align: center;">-- <span class="math inline">\(\tilde
x\)</span> -&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;x=\tilde
x\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Analysis 1</p>
<ol type="1">
<li><p>Completeness : When <span class="math inline">\(h\)</span> is a
permutation , <span class="math inline">\(h\)</span> is a injection ,
<span class="math inline">\(x=\tilde x\)</span> .</p></li>
<li><p>Soundness : When <span class="math inline">\(h\)</span> is not a
permutation , then <span class="math inline">\(|Im(h)|\le
2^{n-1}\)</span> . <span class="math display">\[
\forall x , P^*\ ,\ \Pr\{P^*(h(x))=x\}=\frac{1}{|h^{-1}(h(x))|}
\]</span> Therefore , <span class="math display">\[
\begin{aligned}
\Pr\{V\text{ accepts}\}&amp;=\sum_{y\in Im(h)}\Pr\{y=f(x)|x\in
\{0,1\}^n\}\Pr\{P^*(h(x))=x\}\\
&amp;=\sum_{y\in Im(h)}\frac{|h^{-1}(y)|}{2^n}\frac{1}{|h^{-1}(y)|}\\
&amp;=\frac{|Im(h)|}{2^n}\\
&amp;\le \frac{1}{2}
\end{aligned}
\]</span> <span class="math inline">\(k\)</span> rounds : <span
class="math inline">\(\Pr\{V \text{ accepts}\}\le\frac{1}{2^k}\)</span>
.</p></li>
<li><p>Zero-knowledge :</p>
<p>Verifier itself knows <span class="math inline">\(x,y\)</span> .
Prover tells Verifier <span class="math inline">\(\tilde x\)</span>
.</p>
<p>When <span class="math inline">\(h\)</span> is a permutation , <span
class="math inline">\(\tilde x=x\)</span> , so Verifier can generate
<span class="math inline">\(\tilde x\)</span> itself .</p></li>
</ol></li>
<li><p>Protocol 2</p>
<p>Global : Prover and Verifier already know <span
class="math inline">\(h\)</span> . <span class="math inline">\(\forall
x\in \{0,1\}^n\)</span> , Verifier can get <span
class="math inline">\(h(x)\)</span> in poly-time .</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 10%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;- <span
class="math inline">\(y\)</span> --</td>
<td style="text-align: center;"><span class="math inline">\(y\leftarrow
\{0,1\}^n\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">Find <span
class="math inline">\(x\)</span> , <span
class="math inline">\(h(x)=y\)</span></td>
<td style="text-align: center;">-- <span
class="math inline">\(x\)</span> -&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;h(x)=y\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Analysis 2</p>
<ol type="1">
<li><p>Completeness : When <span class="math inline">\(h\)</span> is a
permutation , <span class="math inline">\(h\)</span> is a bijection ,
<span class="math inline">\(x\)</span> always exists and unique . Always
accept .</p></li>
<li><p>Soundness : When <span class="math inline">\(h\)</span> is not a
permutation , <span class="math inline">\(|Im(h)|\le 2^{n-1}\)</span> .
<span class="math display">\[
\Pr\{h^{-1}(y)=\varnothing|y\leftarrow
\{0,1\}^n\}=1-\frac{|Im(h)|}{2^n}\ge \frac{1}{2}
\]</span> When <span
class="math inline">\(h^{-1}(y)=\varnothing\)</span> , any Prover cannot
convince verifier , so <span class="math display">\[
\Pr\{V\text{ accepts}\}\le 1-\Pr\{h^{-1}(y)=\varnothing|y\leftarrow
\{0,1\}^n\}\le \frac{1}{2}
\]</span> <span class="math inline">\(k\)</span> rounds : <span
class="math inline">\(\Pr\{V \text{ accepts}\}\le\frac{1}{2^k}\)</span>
.</p></li>
<li><p>Zero-knowledge : <strong>NOT (dishonest-verifier)
zero-knowledge</strong></p>
<p><span class="math inline">\(V\)</span> knows <span
class="math inline">\(h^{-1}(y)\)</span> , which cannot be computed in
poly-time by itself .</p>
<blockquote>
<p>This is still <strong>honest-verifier zero-knowledge</strong> , see
homework 1</p>
</blockquote></li>
</ol></li>
<li><p>Notes</p>
<blockquote>
<p>In Protocol 1 , when <span class="math inline">\(h\)</span> is a
permutation , Verifier can always generate a valid proof</p>
</blockquote>
<blockquote>
<p>In both Protocols , Prover must have the ability to solve <span
class="math inline">\(h^{-1}\)</span> . This may lead Verifier knowing
something more .</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="formularize-zero-knowledge-ip">4 Formularize zero-knowledge
IP</h3>
<ol type="1">
<li><p>Security Parameter : <span
class="math inline">\(\kappa\)</span></p>
<ol type="1">
<li>For efficiency : usually <span
class="math inline">\(|x|=poly(\kappa)\)</span> , PPT should run in
<span class="math inline">\(poly(\kappa)\)</span> .</li>
<li>For security : negligible function</li>
</ol></li>
<li><p>Negligible function : <span
class="math inline">\(\epsilon\)</span></p>
<ol type="1">
<li><p>Def : negligible function <span
class="math inline">\(\epsilon:\mathbb Z^*\to \mathbb R^*\)</span></p>
<p>For all polynomial <span class="math inline">\(p\)</span> , <span
class="math inline">\(\exists c\in \mathbb Z^* , \forall
k&gt;c,\epsilon(k)&lt;\frac{1}{p(k)}\)</span> .</p></li>
<li><p>Propositions :</p>
<ol type="1">
<li><span class="math inline">\(\epsilon , \delta\)</span> negligible
<span class="math inline">\(\to\)</span> <span
class="math inline">\(\epsilon+\delta , \epsilon\delta\)</span>
negligible</li>
<li><span class="math inline">\(\epsilon\)</span> negligible <span
class="math inline">\(\to\)</span> For all polynomial <span
class="math inline">\(p\)</span> , <span
class="math inline">\(p\epsilon\)</span> negligible</li>
</ol></li>
<li><p>Conventions :</p>
<ol type="1">
<li><p><span class="math inline">\(\epsilon\)</span> noticeable : <span
class="math inline">\(\exists\)</span> polynomial <span
class="math inline">\(p\)</span> , <span class="math inline">\(\exists
c\in \mathbb Z^*,\forall k&gt;c,\epsilon(k)\ge
\frac{1}{p(k)}\)</span></p></li>
<li><p><span class="math inline">\(A\)</span> happens with overwhelming
probability : <span class="math display">\[
\Pr\{A\}\ge 1-\epsilon \quad\quad \epsilon \text{ is negligible}
\]</span></p></li>
</ol></li>
</ol>
<blockquote>
<p>There exists function that is neither negligible nor noticeable</p>
</blockquote></li>
<li><p>View of Verifier <span class="math display">\[
View_V^P(x):=(x,r,\tau)
\]</span></p></li>
<li><p>Honest-Verifier Zero-knowledge</p>
<ol type="1">
<li><p>Perfect honest-verifier zero-knowledge <span
class="math display">\[
\exists M\in PPT\ ,\ \forall x\in L\ ,\ View_V^P(x)\equiv M(x)
\]</span></p></li>
<li><p>Statistical honest-verifier zero-knowledge</p>
<p>The statistical distance between <span
class="math inline">\(View_V^P(x)\)</span> and <span
class="math inline">\(M(x)\)</span> is negligible</p>
<p><span class="math inline">\(\exists M\in PPT\ ,\ \forall x\in
L\)</span> , <span class="math display">\[
SD(View_V^P(x),M(x))=\frac{1}{2}\sum_{s}\left|\Pr\{View_V^P(x)=s\}-\Pr\{M(x)=s\}\right|&lt;\epsilon
\]</span></p></li>
<li><p>Computational honest-verifier zero-knowledge</p>
<p><span class="math inline">\(\exists M\in PPT\ ,\ \forall x\in L\ , \
\forall\)</span> distinguisher <span class="math inline">\(D\in
PPT\)</span> , <span class="math display">\[
\left|\Pr\{D(View_V^P(x))=1\}-\Pr\{D(M(x))=1\}\right|&lt;\epsilon
\]</span></p></li>
</ol></li>
<li><p>Dishonest Verifier</p>
<p><span class="math inline">\(\braket{P,V}\)</span> achieves
perfect/statistical/computational dishonest-verifier zero-knowledge if
:</p>
<p><span class="math inline">\(\forall V^*\in PPT\ , \ \exists\)</span>
expected poly-time randomized algorithm <span
class="math inline">\(M^*\)</span> , <span class="math inline">\(\forall
x\in L\)</span> , <span class="math inline">\(View_{V^*}^P(x)\)</span>
and <span class="math inline">\(M^*(x)\)</span> are
perfectly/statistically/computationally indistinguishable .</p></li>
<li><p>Graph Isomorphism IP with dishonest-verifier zero-knowledge</p>
<ol type="1">
<li><p>Definition</p>
<p>Prover and Verifier know graph <span
class="math inline">\(G_0,G_1\)</span> .</p>
<p>Prover wants to convince Verifier that <span
class="math inline">\(G_0\sim G_1\)</span> , i.e. <span
class="math inline">\(\exists \pi,\pi(G_0)=G_1\)</span> .</p></li>
<li><p>Protocol</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 12%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\pi_r\leftarrow S_n\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\tilde
G:=\pi_r(G_0)\)</span></td>
<td style="text-align: center;">--<span class="math inline">\(\tilde
G\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;-<span
class="math inline">\(b\)</span>--</td>
<td style="text-align: center;"><span class="math inline">\(b\leftarrow
\{0,1\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">find <span
class="math inline">\(\pi_b\)</span> , s.t. <span
class="math inline">\(\tilde G=\pi_b(G_b)\)</span></td>
<td style="text-align: center;">--<span
class="math inline">\(\pi_b\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;\tilde
G=\pi_b(G_b)\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note : If Prover knows <span class="math inline">\(\pi\)</span> that
<span class="math inline">\(\pi(G_0)=G_1\)</span> , then <span
class="math inline">\(\pi_b\)</span> can be constructed : <span
class="math display">\[
\pi_b=\begin{cases}\pi_r&amp;b=0\\\pi_r\circ\pi^{-1}&amp;b=1\end{cases}
\]</span></p>
</blockquote></li>
<li><p>Analysis</p>
<ol type="1">
<li><p>Completeness : If <span class="math inline">\(G_0\sim
G_1\)</span> , <span class="math inline">\(\pi_b\)</span> can be
constructed as above . Always Accept .</p></li>
<li><p>Soundness : If <span class="math inline">\(G_0\not\sim
G_1\)</span> , <span class="math inline">\(\exists b^*\in
\{0,1\},G_{b^*}\not\sim\tilde G\)</span></p>
<p><span class="math inline">\(\Pr\{V \text{ rejects}\}\ge \Pr\{V\text{
chooses }b^*\}=\frac{1}{2}\)</span></p>
<blockquote>
<p>Note : we cannot let Verifier just choose <span
class="math inline">\(b=1\)</span> , since a malicious Prover can
violate the protocol , <span class="math inline">\(\pi_r\)</span> may
not be a permutation , and <span class="math inline">\(\tilde G\)</span>
may not isomorphic to <span class="math inline">\(G_0\)</span> .</p>
</blockquote></li>
<li><p>honest-verifier zero-knowledge :</p>
<p>Verifier itself knows : <span
class="math inline">\(G_0,G_1,b\)</span> , <span
class="math inline">\(r\)</span> : randomness generating <span
class="math inline">\(b\)</span> . Prover tells verifier <span
class="math inline">\(\tilde G,\pi_b\)</span> .</p>
<p><span class="math inline">\(View_V^P=(G_0,G_1,r,b,\tilde
G,\pi_b)\)</span> .</p>
<p><span class="math inline">\(M_V\)</span> :</p>
<ol type="1">
<li>sample <span class="math inline">\(b\leftarrow \{0,1\}\)</span></li>
<li>choose <span class="math inline">\(\pi_b\leftarrow S_n\)</span></li>
<li><span class="math inline">\(\tilde G:=\pi_b(G_b)\)</span></li>
</ol>
<p>Since Prover and Verifier are honest , <span
class="math inline">\(b\)</span> is independent of $G $ , and <span
class="math inline">\(\pi_b\)</span> is generated by a uniformly random
<span class="math inline">\(\pi_r\)</span> hence is also uniformly
random .</p></li>
<li><p>dishonest-verifier zero-knowledge :</p>
<p>Malicious Verifier can choose <span class="math inline">\(b\)</span>
based on <span class="math inline">\(\tilde G\)</span> to gain more
knowledge .</p>
<p><span class="math inline">\(M^*\)</span> : should perform as Prover
:</p>
<ol type="1">
<li>guess <span class="math inline">\(b^*\in \{0,1\}\)</span></li>
<li>compute <span class="math inline">\(\pi_r\leftarrow S_n\)</span> ,
<span class="math inline">\(\tilde G:=\pi_r(G_{b^*})\)</span></li>
<li>use Verifier to receive <span class="math inline">\(b\)</span></li>
<li>If <span class="math inline">\(b\neq b^*\)</span> , go back to
1.</li>
<li>If <span class="math inline">\(b=b^*\)</span> , then let <span
class="math inline">\(\pi_b=\pi_r\)</span> , get the view</li>
</ol></li>
</ol></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>零知识证明和多方安全计算</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>密码学-零知识证明</tag>
        <tag>密码学-交互式证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 2</title>
    <url>/2023/10/06/Algorithm-Design-2/</url>
    <content><![CDATA[<h3 id="dfs-application">1.3 dfs application</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">dfs</span><span class="params">(u)</span></span>&#123;</span><br><span class="line">    ++time;</span><br><span class="line">    discover[u]=time;</span><br><span class="line">    col[u]=grey;</span><br><span class="line">    <span class="keyword">for</span>(v in <span class="built_in">Neighbour</span>(u) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==white)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    col[u]=black;</span><br><span class="line">    ++time;</span><br><span class="line">    finish[u]=time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>THM parenthesis</p>
<p>on dfs tree , if <span class="math inline">\(u\)</span> is one
ancestor of <span class="math inline">\(v\)</span> , then <span
class="math inline">\([v.d,v.f]\subset[u.d,u.f]\)</span></p>
<p>on dfs tree , otherwise , then <span
class="math inline">\([u.d,u.f]\cap
[v.d,v.f]=\varnothing\)</span></p></li>
<li><p>THM white-path</p>
<p>on dfs tree , at the time when <span class="math inline">\(u\)</span>
is discovered ,</p>
<p><span class="math inline">\(u\)</span> is one ancestor of <span
class="math inline">\(v\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\exists\)</span> white path from <span
class="math inline">\(u\)</span> to <span
class="math inline">\(v\)</span></p>
<p>即： <span class="math inline">\(v\)</span> 是 <span
class="math inline">\(u\)</span> 的后代<span
class="math inline">\(\Leftrightarrow\)</span>在 <span
class="math inline">\(u\)</span>
刚访问到的时候一定存在一条完全没有被访问过的路径 <span
class="math inline">\(u\to v\)</span> .</p>
<ul>
<li>Proof : use parenthesis THM</li>
</ul>
<p><span class="math inline">\(\Rightarrow\)</span> trivial</p>
<p><span class="math inline">\(\Leftarrow\)</span> proof by
contradiction</p>
<p>Consider a white path <span
class="math inline">\(x_1=u,x_2,\cdots,x_m=v\)</span> , and <span
class="math inline">\(x_k\)</span> is the last vertex that is a
descendent of <span class="math inline">\(u\)</span> (including <span
class="math inline">\(u\)</span> itself) .</p>
<p>We need to prove that <span class="math inline">\(x_{k+1}\)</span> is
also a descendent of <span class="math inline">\(u\)</span> , leading to
contradiction .</p>
<p>Therefore , <span
class="math inline">\(u.d&lt;x_k.d&lt;x_k.f&lt;u.f\)</span> ,</p>
<p>Case 1 : <span
class="math inline">\(x_k.d&lt;x_{k+1}.d&lt;x_{k+1}.f&lt;x_k.f\)</span>
-&gt; <span class="math inline">\(x_{k+1}\)</span> is also a descendent
of <span class="math inline">\(u\)</span> .</p>
<p>Case 2 : <span
class="math inline">\(x_k.d&lt;x_k.f&lt;x_{k+1}.d&lt;x_{k+1}.f\)</span>
: Impossible .</p></li>
<li><p>Strongly Connected Components (SCC)</p>
<ol type="1">
<li><p>View : any directed graph can be viewed as a DAG of SCC</p></li>
<li><p>Find SCC ? Kosaraju's Algorithm</p>
<ol type="1">
<li><p>Algorithm</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs1</span>(G);<span class="comment">// compute the finishing time u.f</span></span><br><span class="line">G_=<span class="built_in">reverse_edge</span>(G);</span><br><span class="line"><span class="built_in">dfs2</span>(G_); <span class="comment">// In main loop , consider vertices in decreasing order of u.f</span></span><br><span class="line">Claim : Each dfs-<span class="function">tree in <span class="title">dfs2</span><span class="params">(G_)</span> is a SCC</span></span><br></pre></td></tr></table></figure></li>
<li><p>Proof</p>
<p>Intuition : find and "delete" sink components in dfs2 , like
a-topological order in <span class="math inline">\(G\_\)</span> ( i.e.
topological order in <span class="math inline">\(G\)</span> )</p>
<ol type="1">
<li><p>Lemma : If we start DFS at a node in a sink component , we will
visit precisely all vertices in this component .</p>
<p>Trivial .</p></li>
<li><p>Lemma (key) : node with largest <span
class="math inline">\(u.f\)</span> belongs to a start component in <span
class="math inline">\(G\)</span> (i.e. a sink component in <span
class="math inline">\(G\_\)</span>)</p>
<p>Only need to prove the following lemma .</p></li>
<li><p>Lemma ( for proving key Lemma ) : <span
class="math inline">\(C,D\)</span> are two SCC , <span
class="math inline">\(D\)</span> is reachable from <span
class="math inline">\(C\)</span> ,</p>
<p>Then for <span class="math inline">\(v\in C\)</span> , which is the
firstly visited vertex in <span class="math inline">\(C\)</span> , then
<span class="math inline">\(\forall u\in D,v.f&gt;u.f\)</span></p>
<p>Proof :</p>
<p>Case 1 : <span class="math inline">\(v\)</span> is also the firstly
visited vertex in <span class="math inline">\(C\cup D\)</span> , then by
white-path THM , all nodes in <span class="math inline">\(C\cup
D\)</span> are descendent of <span class="math inline">\(v\)</span> , so
<span class="math inline">\(\forall u\in C\cup D\backslash \{v\} ,
v.f&gt;u.f\)</span> .</p>
<p>Case 2 : <span class="math inline">\(\exists y\in D\)</span> , <span
class="math inline">\(y\)</span> is the firstly visited vertex in <span
class="math inline">\(C\cup D\)</span> , so <span
class="math inline">\(v\)</span> is not a descendent of <span
class="math inline">\(y\)</span> since <span
class="math inline">\(C\)</span> is not reachable from <span
class="math inline">\(D\)</span> .</p>
<p>Therefore , by parenthesis THM , <span class="math inline">\(y.d\le
u.d&lt;u.f\le y.f&lt;v.d&lt;v.f\)</span> for all <span
class="math inline">\(u\in D\)</span> .</p></li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<h2 id="chapter-2-greedy-algorithm">Chapter 2 : Greedy Algorithm</h2>
<h3 id="interval-scheduling">2.1 Interval Scheduling</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(n\)</span> jobs <span
class="math inline">\(s_i,f_i\)</span></p>
<p>Goal : maximize the #jobs , s.t. at most one job at a time .</p></li>
<li><p>Another view</p>
<p>Connect all jobs pairs <span
class="math inline">\([s_i,f_i],[s_j,f_j]\)</span> if <span
class="math inline">\([s_i,f_i]\cap [s_j,f_j]\neq \varnothing\)</span>
.</p>
<p>Goal <span class="math inline">\(\Leftrightarrow\)</span> maximum
independent set .</p>
<p>In general graph : NP-hard for general graph .</p></li>
<li><p>Algorithm</p>
<p>Repeat : Select the available jobs that finishes first .</p></li>
<li><p>Proof of optimality :</p>
<p>Method : [Exchange Argument] : Compare our solution and the optimal
solution .</p>
<p>SOL : <span class="math inline">\(i_1,i_2,\cdots ,i_m\)</span> , OPT
: <span class="math inline">\(j_1,j_2,\cdots,j_k\)</span> .</p>
<ol type="1">
<li>Claim : If <span class="math inline">\(f_{i_1}\le f_{j_1}\)</span> ,
then <span class="math inline">\(f_{i_r}\le f_{j_r}\)</span> for all
<span class="math inline">\(r\ge 1\)</span> .</li>
</ol>
<p>Proof : [Induction]</p>
<p>If the claim is true for <span class="math inline">\(r-1\)</span> ,
suppose the claim is not true for <span class="math inline">\(r\)</span>
, i.e. <span class="math inline">\(f_{i_r}&gt;f_{j_r}\)</span> . Since
<span class="math inline">\(f_{i_{r-1}}\le f_{j_{r-1}}\)</span> , and
<span class="math inline">\(s_{j_r}&gt;f_{j_{r-1}}\)</span> , then <span
class="math inline">\(f_{i_{r-1}}&lt;s_{j_r}\)</span> , so <span
class="math inline">\(j_r\)</span> is also available , but has earlier
finish time , contradict .</p>
<ol start="2" type="1">
<li>If <span class="math inline">\(m&lt;k\)</span> , then <span
class="math inline">\(f_{i_m}&lt;f_{j_m}\)</span> . We can use <span
class="math inline">\(j_{m+1},\cdots,j_k\)</span> after <span
class="math inline">\(i_m\)</span> .</li>
</ol></li>
</ol>
<h3 id="scheduling-to-minimize-lateness">2.2. Scheduling to minimize
lateness</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(n\)</span> jobs , each job <span
class="math inline">\(i\)</span> has ddl <span
class="math inline">\(d_i\)</span> and length <span
class="math inline">\(t_i\)</span> . Def lateness : <span
class="math inline">\(l_i:=\max\{0,f_i-d_i\}\)</span></p>
<p>Goal : find a schedule of all <span class="math inline">\(n\)</span>
jobs , and minimize the maximal lateness .</p></li>
<li><p>Equal formularization</p>
<p>Goal : find a permutation <span class="math inline">\(\{p_i\}\in
S_n\)</span> , then <span class="math inline">\(f_i=\sum_{j=1}^i
t_{p_j}\)</span> , <span
class="math inline">\(l_i:=\max\{0,f_i-d_{p_i}\}\)</span> . Minimize
<span class="math inline">\(\max\{l_i\}\)</span> .</p>
<p><span class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(l_i:=f_i-d_{p_i}\)</span> , Minimize <span
class="math inline">\(\max\{0,\max\{l_i\}\}\)</span> .</p></li>
<li><p>Algorithm</p>
<p>Schedule the job in increasing order of <span
class="math inline">\(d_i\)</span> .</p></li>
<li><p>Proof of optimality</p>
<ol type="1">
<li><p>Def (Inversion) : Consider a schedule <span
class="math inline">\(A&#39;\)</span> , <span
class="math inline">\((i,j)\)</span> is an inversion if <span
class="math inline">\(i\)</span> is scheduled before <span
class="math inline">\(j\)</span> but <span
class="math inline">\(d_i&gt;d_j\)</span> .</p></li>
<li><p>If OPT$$ SOL , there must be an inversion , then there must be an
adjacent inversion . Suppose <span
class="math inline">\((i,i+1)\)</span> is an inversion , then <span
class="math inline">\(d_{p_i}&gt;d_{p_{i+1}}\)</span> .</p>
<p>Let <span class="math inline">\(f=\sum_{j=1}^{i-1}t_{p_j}\)</span> ,
so <span class="math inline">\(f_i=f+t_{p_i}\)</span> , <span
class="math inline">\(f_{i+1}=f+t_{p_i}+t_{p_{i+1}}\)</span> , so <span
class="math inline">\(l_i=f+t_{p_i}-d_{p_i}\)</span> , <span
class="math inline">\(l_{i+1}=f+t_{p_i}+t_{p_{i+1}}-d_{p_{i+1}}\)</span>
.</p>
<p>If swap <span class="math inline">\((i,i+1)\)</span> , then <span
class="math inline">\(f_{i+1}&#39;=f+t_{p_{i+1}}\)</span> , <span
class="math inline">\(f_{i}&#39;=f+t_{p_{i+1}}+t_{p_i}\)</span> , so
<span
class="math inline">\(l_{i+1}&#39;=f+t_{p_{i+1}}-d_{p_{i+1}}\)</span> ,
<span
class="math inline">\(l_i&#39;=f+t_{p_{i+1}}+t_{p_i}-d_{p_i}\)</span>
.</p>
<p>Therefore , obviously , <span
class="math inline">\(l_{i+1}&#39;&lt;l_{i+1}\)</span> . Since <span
class="math inline">\(d_{p_i}&gt;d_{p_{i+1}}\)</span> , then <span
class="math inline">\(l_i&#39;&lt;l_i\)</span> . Therefore , swap can
lead to better solution , so OPT is not optimal .</p></li>
</ol></li>
</ol>
<h3 id="shortest-path-without-w0">2.3. Shortest Path (without <span
class="math inline">\(w&lt;0\)</span>)</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : weighted graph <span class="math inline">\(G=(V,E)\)</span> ,
start vertex <span class="math inline">\(s\)</span> .</p>
<p>Output : <span class="math inline">\(d(u)\)</span> for all <span
class="math inline">\(u\in V\)</span> , where <span
class="math inline">\(d(u)=\min_{p\text{ is a path }s\to u}\{\sum_{e\in
p}l(e)\}\)</span> .</p></li>
<li><p>Algorithm [Dijkstra 1959]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init</span></span><br><span class="line"><span class="keyword">for</span>(u in V)&#123;</span><br><span class="line">    d[u]=+inf;</span><br><span class="line">&#125;</span><br><span class="line">d[s]=<span class="number">0</span>; S.<span class="built_in">insert</span>(s);</span><br><span class="line"><span class="comment">// Main Algorithm</span></span><br><span class="line"><span class="keyword">while</span>(S != V)&#123;</span><br><span class="line">    v=<span class="built_in">argmin</span>(d[u]+<span class="built_in">l</span>(e) |v: v in V\S , e=(u,v) , u in S );</span><br><span class="line">    d[v]=d[u]+<span class="built_in">l</span>(e);</span><br><span class="line">    S.<span class="built_in">insert</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Proof</p>
<p>Prove by induction on <span class="math inline">\(S\)</span> . <span
class="math inline">\(\forall v\in S , d(v)=\min dist(s,v)\)</span>
,</p>
<p>Suppose we grow <span class="math inline">\(S\)</span> by adding
<span class="math inline">\(v\)</span> , suppose the proposition does
not hold . Then <span class="math inline">\(d(u)+l_e\)</span> is not the
shortest distance to <span class="math inline">\(v\)</span> . Let <span
class="math inline">\(p\)</span> be the shortest path from <span
class="math inline">\(s\)</span> to <span
class="math inline">\(v\)</span> .</p>
<p>Let <span class="math inline">\(w\)</span> be the last vertex that is
in <span class="math inline">\(S\)</span> , then by induction , all
vertices on <span class="math inline">\(p\)</span> from <span
class="math inline">\(s\)</span> to <span
class="math inline">\(w\)</span> are all in <span
class="math inline">\(S\)</span> . Let <span
class="math inline">\(p&#39;=path(s,u)+e\)</span> .</p>
<p><span class="math inline">\(p&#39;: s\to w\to u\to v\)</span> , <span
class="math inline">\(p:s\to w\to x\to v\)</span> . (<span
class="math inline">\(x\notin S\)</span>) . Since <span
class="math inline">\(d(u)+l_e\)</span> is minimal , <span
class="math inline">\(d(u)+l_e\le d(w)+l_{w,x}\)</span> , but <span
class="math inline">\(dist(p)=d(w)+l_{w,x}+dist(x,v)\)</span> , where
<span class="math inline">\(dist(x,v)\ge 0\)</span> , and <span
class="math inline">\(dist(p)&lt;dist(p&#39;)=d(u)+l_e\)</span> , so
<span class="math inline">\(d(w)+l_{w,x}\le dist(p)&lt;d(u)+l_e\)</span>
, contradict .</p></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-搜索</tag>
        <tag>算法-贪心</tag>
        <tag>算法-强连通分量(SCC)</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 1</title>
    <url>/2023/10/05/Algorithm-Design-1/</url>
    <content><![CDATA[<h2 id="chapter-0-logistics">Chapter 0 Logistics</h2>
<p><strong>Content</strong> : discrete(combinatorial) algorithm ,
Theoretical</p>
<ul>
<li>[minority] Complexity , NP-Completeness</li>
<li>Basic Graph Algorithm , DFS / BFS</li>
<li>Greedy</li>
<li>Dynamic Programming</li>
<li>Divide and Conquer</li>
<li>NP-completeness Theory</li>
<li>Approximation Algorithm</li>
<li>Randomized Algorithm (Probability Analysis)</li>
<li><ul>
<li>Computational Geometry</li>
</ul></li>
<li><ul>
<li>Streaming Algorithm (online)</li>
</ul></li>
</ul>
<p><strong>Textbook</strong> : [Kleinberg&amp;Tardos] Algorithm
Design</p>
<p><strong>Reference Book</strong> : [CLRS] Intro to Algorithm</p>
<h2 id="chapter-1">Chapter 1</h2>
<h3 id="stable-matching">1.1 Stable matching</h3>
<ol type="1">
<li><p>Def</p>
<ul>
<li><p>Input : <span class="math inline">\(boys=\{B_1,\cdots,B_n\} ,
girls=\{G_1,\cdots,G_n\}\)</span></p>
<p>Preference List : <span class="math inline">\(BP_i\)</span> : a
permutation of <span class="math inline">\(girls\)</span> , <span
class="math inline">\(GP_i\)</span> : a permutation of <span
class="math inline">\(boys\)</span></p></li>
<li><p>output : a stable matching</p></li>
<li><p>stable matching : no unstable pairs</p></li>
<li><p>unstable pair : <span class="math inline">\((B_i,G_j)\)</span>
s.t. <span class="math inline">\(M(B_i)\)</span> after <span
class="math inline">\(G_j\)</span> in <span
class="math inline">\(BP_i\)</span> and <span
class="math inline">\(M(G_j)\)</span> after <span
class="math inline">\(B_i\)</span> in <span
class="math inline">\(GP_j\)</span></p></li>
</ul></li>
<li><p>Efficient Algorithm : Gale &amp; Shapley Algorithm (
propose-reject )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( exists sb. single )&#123;</span><br><span class="line">    A &lt;- an arbitrary single boy</span><br><span class="line">    X &lt;- <span class="function">first girl A has <span class="keyword">not</span> proposed yet</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">( X is single )</span></span></span><br><span class="line"><span class="function">        A-X engage</span></span><br><span class="line"><span class="function">    <span class="keyword">else</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">( A is better than M(X) )</span></span></span><br><span class="line"><span class="function">            A-X engage</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">            X reject A</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Analysis</p>
<ol type="1">
<li><p>Proof of Termination</p>
<ol type="1">
<li>For girl : once engaged , engaged forever</li>
<li>For one boy : If used all preference list : then all girls must be
engaged</li>
</ol></li>
<li><p>Proof of Correctness</p>
<p>Prove by Contradiction</p>
<p><span class="math inline">\((B_i,G_j)\)</span> : an unstable pair</p>
<p><span class="math inline">\(B_i\)</span> preference list : <span
class="math inline">\(\cdots G_j \cdots M(B_i)\)</span></p>
<p><span class="math inline">\(G_j\)</span> preference list : <span
class="math inline">\(\cdots B_i \cdots Z=M(G_j)\)</span></p>
<p><span class="math inline">\(\therefore\)</span> <span
class="math inline">\(G_j\)</span> rejected <span
class="math inline">\(B_i\)</span> , but <span
class="math inline">\(G_j\)</span> should not reject <span
class="math inline">\(B_i\)</span> compared with <span
class="math inline">\(Z\)</span></p></li>
<li><p>Running Time : <span class="math inline">\(\mathcal
O(n^2)\)</span> ( All boys used up their preference list)</p></li>
</ol></li>
<li><p>Random ver.</p>
<ol type="1">
<li><p>def : <span class="math inline">\(BP_i\)</span> , <span
class="math inline">\(GP_i\)</span> are all random permutations
(uniformly distributed)</p></li>
<li><p>How to get a uniformly distributed random permutation ?</p>
<p>draw-likely process</p></li>
<li><p>THM : <span class="math inline">\(\mathbb E[T]\le n\cdot
H_n\)</span> (<span class="math inline">\(\mathbb E[T]=\mathcal O(n\log
n)\)</span>)</p></li>
<li><p>Proof</p>
<ol type="1">
<li><p>key observation :</p>
<p>G-S' : each time a boy propose to a random girl not proposed yet</p>
<p><strong>This is equivalent as generate a uniformly distributed random
permutation</strong></p>
<p>G-S'' : each time a boy propose to a random girl (can be proposed
yet)</p>
<p>$$ <span class="math inline">\(T(G-S)=T(G-S&#39;)\le
T(G-S&#39;&#39;)\)</span></p></li>
<li><p>Coupon Collector Problem ( Bins-Balls )</p>
<p><span class="math inline">\(n\)</span> bins , each time throw a ball
to a random bin .</p>
<p>Q : <span class="math inline">\(\mathbb E[\text{balls}]\)</span> s.t.
every bin is nonempty .</p>
<p>A : <span class="math inline">\(\mathbb E[\text{balls}]=n\cdot
H_n\)</span></p>
<p>Construct Sequence <span class="math inline">\(a_i\in
\{0,1\}\)</span> , <span
class="math inline">\(a_i=1\Leftrightarrow\)</span> a ball falls in an
empty bin</p>
<p>Exactly <span class="math inline">\(n\)</span> number of <span
class="math inline">\(1\)</span>s . -&gt; <span
class="math inline">\(n\)</span> segments like <span
class="math inline">\(0\cdots 01\)</span> <span class="math display">\[
\begin{aligned}
\mathbb E[T]&amp;=\mathbb E\left[\sum_{i=1}^n \text{len of i-th
segment}\right]\\
&amp;=\sum_{i=1}^n\mathbb E\left[ \text{len of i-th segment}\right]\\
&amp;=\sum_{i=1}^n \frac{1}{\Pr\{\text{in i-th seg , choosed empty
bin}\}}\\
&amp;=\sum_{i=1}^n \frac{n}{n-i+1}\\
&amp;=n\cdot H_n
\end{aligned}
\]</span></p></li>
<li><p>Consider boy -&gt; ball , girl -&gt; bin</p>
<p>G-S'' -&gt; Bins-Balls Problem</p></li>
<li><ul>
<li><p>Concentration inequality for Coupon Collection Running Time</p>
<p>Same as Chernoff Bound</p></li>
</ul></li>
</ol></li>
</ol></li>
</ol>
<h3 id="bfs-dfs">1.2 BFS &amp; DFS</h3>
<ol type="1">
<li><p>BFS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line">q.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(u in Vertices)&#123;</span><br><span class="line">    dep[u]=inf;</span><br><span class="line">    prev[u]=<span class="literal">NULL</span>;</span><br><span class="line">    col[u]=white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dep[s]=<span class="number">0</span>;</span><br><span class="line">prev[s]=<span class="literal">NULL</span>;</span><br><span class="line">col[s]=grey;</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(v in <span class="built_in">Neighbour</span>(u) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==white)&#123;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            prev[v]=u;</span><br><span class="line">            col[v]=grey;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    col[v]=black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS Tree Property : no edges with depth difference <span
class="math inline">\(\ge 2\)</span> .</p></li>
<li><p>DFS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">dfs</span><span class="params">(u)</span></span>&#123;</span><br><span class="line">    ++time;</span><br><span class="line">    discover[u]=time;</span><br><span class="line">    col[u]=grey;</span><br><span class="line">    <span class="keyword">for</span>(v in <span class="built_in">Neighbour</span>(u) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==white)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    col[u]=black;</span><br><span class="line">    ++time;</span><br><span class="line">    finish[u]=time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS Tree Properties</p>
<p>Time stamp intervals</p>
<ol type="1">
<li>non-crossing : only non-intersect / totally include</li>
<li>Tree Structure <span class="math inline">\(\Leftrightarrow\)</span>
Time stamp intervals Structure</li>
</ol></li>
<li><p>Connectivity</p>
<ol type="1">
<li><p>undirected graph : connected component</p></li>
<li><p>directed graph : strongly connected component (SCC)</p>
<p>every vertex can reach other vertex</p></li>
<li><p>directed acyclic graph (DAG)</p>
<p>i.e. no directed cycle</p>
<p>i.e. no SCC has <span class="math inline">\(\ge 2\)</span>
vertices</p>
<ul>
<li>DAG has a topological order</li>
</ul></li>
<li><p>A useful view of directed graph : a DAG of SCC</p>
<p>a.k.a. 缩点</p></li>
<li><p>DAG has a topological order</p>
<p>get topological order : use bfs/dfs starting from <span
class="math inline">\(InDeg=0\)</span></p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-匹配</tag>
        <tag>算法-搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>测试文档</tag>
      </tags>
  </entry>
</search>
