<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithm Design 1</title>
    <url>/2023/10/05/Algorithm-Design-1/</url>
    <content><![CDATA[<h2 id="chapter-0-logistics">Chapter 0 Logistics</h2>
<p><strong>Content</strong> : discrete(combinatorial) algorithm ,
Theoretical</p>
<ul>
<li>[minority] Complexity , NP-Completeness</li>
<li>Basic Graph Algorithm , DFS / BFS</li>
<li>Greedy</li>
<li>Dynamic Programming</li>
<li>Divide and Conquer</li>
<li>NP-completeness Theory</li>
<li>Approximation Algorithm</li>
<li>Randomized Algorithm (Probability Analysis)</li>
<li><ul>
<li>Computational Geometry</li>
</ul></li>
<li><ul>
<li>Streaming Algorithm (online)</li>
</ul></li>
</ul>
<p><strong>Textbook</strong> : [Kleinberg&amp;Tardos] Algorithm
Design</p>
<p><strong>Reference Book</strong> : [CLRS] Intro to Algorithm</p>
<h2 id="chapter-1">Chapter 1</h2>
<h3 id="stable-matching">1.1 Stable matching</h3>
<ol type="1">
<li><p>Def</p>
<ul>
<li><p>Input : <span class="math inline">\(boys=\{B_1,\cdots,B_n\} ,
girls=\{G_1,\cdots,G_n\}\)</span></p>
<p>Preference List : <span class="math inline">\(BP_i\)</span> : a
permutation of <span class="math inline">\(girls\)</span> , <span
class="math inline">\(GP_i\)</span> : a permutation of <span
class="math inline">\(boys\)</span></p></li>
<li><p>output : a stable matching</p></li>
<li><p>stable matching : no unstable pairs</p></li>
<li><p>unstable pair : <span class="math inline">\((B_i,G_j)\)</span>
s.t. <span class="math inline">\(M(B_i)\)</span> after <span
class="math inline">\(G_j\)</span> in <span
class="math inline">\(BP_i\)</span> and <span
class="math inline">\(M(G_j)\)</span> after <span
class="math inline">\(B_i\)</span> in <span
class="math inline">\(GP_j\)</span></p></li>
</ul></li>
<li><p>Efficient Algorithm : Gale &amp; Shapley Algorithm (
propose-reject )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( exists sb. single )&#123;</span><br><span class="line">    A &lt;- an arbitrary single boy</span><br><span class="line">    X &lt;- <span class="function">first girl A has <span class="keyword">not</span> proposed yet</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">( X is single )</span></span></span><br><span class="line"><span class="function">        A-X engage</span></span><br><span class="line"><span class="function">    <span class="keyword">else</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">( A is better than M(X) )</span></span></span><br><span class="line"><span class="function">            A-X engage</span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">            X reject A</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Analysis</p>
<ol type="1">
<li><p>Proof of Termination</p>
<ol type="1">
<li>For girl : once engaged , engaged forever</li>
<li>For one boy : If used all preference list : then all girls must be
engaged</li>
</ol></li>
<li><p>Proof of Correctness</p>
<p>Prove by Contradiction</p>
<p><span class="math inline">\((B_i,G_j)\)</span> : an unstable pair</p>
<p><span class="math inline">\(B_i\)</span> preference list : <span
class="math inline">\(\cdots G_j \cdots M(B_i)\)</span></p>
<p><span class="math inline">\(G_j\)</span> preference list : <span
class="math inline">\(\cdots B_i \cdots Z=M(G_j)\)</span></p>
<p><span class="math inline">\(\therefore\)</span> <span
class="math inline">\(G_j\)</span> rejected <span
class="math inline">\(B_i\)</span> , but <span
class="math inline">\(G_j\)</span> should not reject <span
class="math inline">\(B_i\)</span> compared with <span
class="math inline">\(Z\)</span></p></li>
<li><p>Running Time : <span class="math inline">\(\mathcal
O(n^2)\)</span> ( All boys used up their preference list)</p></li>
</ol></li>
<li><p>Random ver.</p>
<ol type="1">
<li><p>def : <span class="math inline">\(BP_i\)</span> , <span
class="math inline">\(GP_i\)</span> are all random permutations
(uniformly distributed)</p></li>
<li><p>How to get a uniformly distributed random permutation ?</p>
<p>draw-likely process</p></li>
<li><p>THM : <span class="math inline">\(\mathbb E[T]\le n\cdot
H_n\)</span> (<span class="math inline">\(\mathbb E[T]=\mathcal O(n\log
n)\)</span>)</p></li>
<li><p>Proof</p>
<ol type="1">
<li><p>key observation :</p>
<p>G-S' : each time a boy propose to a random girl not proposed yet</p>
<p><strong>This is equivalent as generate a uniformly distributed random
permutation</strong></p>
<p>G-S'' : each time a boy propose to a random girl (can be proposed
yet)</p>
<p>$$ <span class="math inline">\(T(G-S)=T(G-S&#39;)\le
T(G-S&#39;&#39;)\)</span></p></li>
<li><p>Coupon Collector Problem ( Bins-Balls )</p>
<p><span class="math inline">\(n\)</span> bins , each time throw a ball
to a random bin .</p>
<p>Q : <span class="math inline">\(\mathbb E[\text{balls}]\)</span> s.t.
every bin is nonempty .</p>
<p>A : <span class="math inline">\(\mathbb E[\text{balls}]=n\cdot
H_n\)</span></p>
<p>Construct Sequence <span class="math inline">\(a_i\in
\{0,1\}\)</span> , <span
class="math inline">\(a_i=1\Leftrightarrow\)</span> a ball falls in an
empty bin</p>
<p>Exactly <span class="math inline">\(n\)</span> number of <span
class="math inline">\(1\)</span>s . -&gt; <span
class="math inline">\(n\)</span> segments like <span
class="math inline">\(0\cdots 01\)</span> <span class="math display">\[
\begin{aligned}
\mathbb E[T]&amp;=\mathbb E\left[\sum_{i=1}^n \text{len of i-th
segment}\right]\\
&amp;=\sum_{i=1}^n\mathbb E\left[ \text{len of i-th segment}\right]\\
&amp;=\sum_{i=1}^n \frac{1}{\Pr\{\text{in i-th seg , choosed empty
bin}\}}\\
&amp;=\sum_{i=1}^n \frac{n}{n-i+1}\\
&amp;=n\cdot H_n
\end{aligned}
\]</span></p></li>
<li><p>Consider boy -&gt; ball , girl -&gt; bin</p>
<p>G-S'' -&gt; Bins-Balls Problem</p></li>
<li><ul>
<li><p>Concentration inequality for Coupon Collection Running Time</p>
<p>Same as Chernoff Bound</p></li>
</ul></li>
</ol></li>
</ol></li>
</ol>
<h3 id="bfs-dfs">1.2 BFS &amp; DFS</h3>
<ol type="1">
<li><p>BFS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line">q.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(u in Vertices)&#123;</span><br><span class="line">    dep[u]=inf;</span><br><span class="line">    prev[u]=<span class="literal">NULL</span>;</span><br><span class="line">    col[u]=white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dep[s]=<span class="number">0</span>;</span><br><span class="line">prev[s]=<span class="literal">NULL</span>;</span><br><span class="line">col[s]=grey;</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(v in <span class="built_in">Neighbour</span>(u) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==white)&#123;</span><br><span class="line">            dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            prev[v]=u;</span><br><span class="line">            col[v]=grey;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    col[v]=black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS Tree Property : no edges with depth difference <span
class="math inline">\(\ge 2\)</span> .</p></li>
<li><p>DFS</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">dfs</span><span class="params">(u)</span></span>&#123;</span><br><span class="line">    ++time;</span><br><span class="line">    discover[u]=time;</span><br><span class="line">    col[u]=grey;</span><br><span class="line">    <span class="keyword">for</span>(v in <span class="built_in">Neighbour</span>(u) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==white)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    col[u]=black;</span><br><span class="line">    ++time;</span><br><span class="line">    finish[u]=time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS Tree Properties</p>
<p>Time stamp intervals</p>
<ol type="1">
<li>non-crossing : only non-intersect / totally include</li>
<li>Tree Structure <span class="math inline">\(\Leftrightarrow\)</span>
Time stamp intervals Structure</li>
</ol></li>
<li><p>Connectivity</p>
<ol type="1">
<li><p>undirected graph : connected component</p></li>
<li><p>directed graph : strongly connected component (SCC)</p>
<p>every vertex can reach other vertex</p></li>
<li><p>directed acyclic graph (DAG)</p>
<p>i.e. no directed cycle</p>
<p>i.e. no SCC has <span class="math inline">\(\ge 2\)</span>
vertices</p>
<ul>
<li>DAG has a topological order</li>
</ul></li>
<li><p>A useful view of directed graph : a DAG of SCC</p>
<p>a.k.a. 缩点</p></li>
<li><p>DAG has a topological order</p>
<p>get topological order : use bfs/dfs starting from <span
class="math inline">\(InDeg=0\)</span></p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-匹配</tag>
        <tag>算法-搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 2</title>
    <url>/2023/10/06/Algorithm-Design-2/</url>
    <content><![CDATA[<h3 id="dfs-application">1.3 dfs application</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">dfs</span><span class="params">(u)</span></span>&#123;</span><br><span class="line">    ++time;</span><br><span class="line">    discover[u]=time;</span><br><span class="line">    col[u]=grey;</span><br><span class="line">    <span class="keyword">for</span>(v in <span class="built_in">Neighbour</span>(u) )&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[v]==white)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    col[u]=black;</span><br><span class="line">    ++time;</span><br><span class="line">    finish[u]=time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>THM parenthesis</p>
<p>on dfs tree , if <span class="math inline">\(u\)</span> is one
ancestor of <span class="math inline">\(v\)</span> , then <span
class="math inline">\([v.d,v.f]\subset[u.d,u.f]\)</span></p>
<p>on dfs tree , otherwise , then <span
class="math inline">\([u.d,u.f]\cap
[v.d,v.f]=\varnothing\)</span></p></li>
<li><p>THM white-path</p>
<p>on dfs tree , at the time when <span class="math inline">\(u\)</span>
is discovered ,</p>
<p><span class="math inline">\(u\)</span> is one ancestor of <span
class="math inline">\(v\)</span> <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(\exists\)</span> white path from <span
class="math inline">\(u\)</span> to <span
class="math inline">\(v\)</span></p>
<p>即： <span class="math inline">\(v\)</span> 是 <span
class="math inline">\(u\)</span> 的后代<span
class="math inline">\(\Leftrightarrow\)</span>在 <span
class="math inline">\(u\)</span>
刚访问到的时候一定存在一条完全没有被访问过的路径 <span
class="math inline">\(u\to v\)</span> .</p>
<ul>
<li>Proof : use parenthesis THM</li>
</ul>
<p><span class="math inline">\(\Rightarrow\)</span> trivial</p>
<p><span class="math inline">\(\Leftarrow\)</span> proof by
contradiction</p>
<p>Consider a white path <span
class="math inline">\(x_1=u,x_2,\cdots,x_m=v\)</span> , and <span
class="math inline">\(x_k\)</span> is the last vertex that is a
descendent of <span class="math inline">\(u\)</span> (including <span
class="math inline">\(u\)</span> itself) .</p>
<p>We need to prove that <span class="math inline">\(x_{k+1}\)</span> is
also a descendent of <span class="math inline">\(u\)</span> , leading to
contradiction .</p>
<p>Therefore , <span
class="math inline">\(u.d&lt;x_k.d&lt;x_k.f&lt;u.f\)</span> ,</p>
<p>Case 1 : <span
class="math inline">\(x_k.d&lt;x_{k+1}.d&lt;x_{k+1}.f&lt;x_k.f\)</span>
-&gt; <span class="math inline">\(x_{k+1}\)</span> is also a descendent
of <span class="math inline">\(u\)</span> .</p>
<p>Case 2 : <span
class="math inline">\(x_k.d&lt;x_k.f&lt;x_{k+1}.d&lt;x_{k+1}.f\)</span>
: Impossible .</p></li>
<li><p>Strongly Connected Components (SCC)</p>
<ol type="1">
<li><p>View : any directed graph can be viewed as a DAG of SCC</p></li>
<li><p>Find SCC ? Kosaraju's Algorithm</p>
<ol type="1">
<li><p>Algorithm</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs1</span>(G);<span class="comment">// compute the finishing time u.f</span></span><br><span class="line">G_=<span class="built_in">reverse_edge</span>(G);</span><br><span class="line"><span class="built_in">dfs2</span>(G_); <span class="comment">// In main loop , consider vertices in decreasing order of u.f</span></span><br><span class="line">Claim : Each dfs-<span class="function">tree in <span class="title">dfs2</span><span class="params">(G_)</span> is a SCC</span></span><br></pre></td></tr></table></figure></li>
<li><p>Proof</p>
<p>Intuition : find and "delete" sink components in dfs2 , like
a-topological order in <span class="math inline">\(G\_\)</span> ( i.e.
topological order in <span class="math inline">\(G\)</span> )</p>
<ol type="1">
<li><p>Lemma : If we start DFS at a node in a sink component , we will
visit precisely all vertices in this component .</p>
<p>Trivial .</p></li>
<li><p>Lemma (key) : node with largest <span
class="math inline">\(u.f\)</span> belongs to a start component in <span
class="math inline">\(G\)</span> (i.e. a sink component in <span
class="math inline">\(G\_\)</span>)</p>
<p>Only need to prove the following lemma .</p></li>
<li><p>Lemma ( for proving key Lemma ) : <span
class="math inline">\(C,D\)</span> are two SCC , <span
class="math inline">\(D\)</span> is reachable from <span
class="math inline">\(C\)</span> ,</p>
<p>Then for <span class="math inline">\(v\in C\)</span> , which is the
firstly visited vertex in <span class="math inline">\(C\)</span> , then
<span class="math inline">\(\forall u\in D,v.f&gt;u.f\)</span></p>
<p>Proof :</p>
<p>Case 1 : <span class="math inline">\(v\)</span> is also the firstly
visited vertex in <span class="math inline">\(C\cup D\)</span> , then by
white-path THM , all nodes in <span class="math inline">\(C\cup
D\)</span> are descendent of <span class="math inline">\(v\)</span> , so
<span class="math inline">\(\forall u\in C\cup D\backslash \{v\} ,
v.f&gt;u.f\)</span> .</p>
<p>Case 2 : <span class="math inline">\(\exists y\in D\)</span> , <span
class="math inline">\(y\)</span> is the firstly visited vertex in <span
class="math inline">\(C\cup D\)</span> , so <span
class="math inline">\(v\)</span> is not a descendent of <span
class="math inline">\(y\)</span> since <span
class="math inline">\(C\)</span> is not reachable from <span
class="math inline">\(D\)</span> .</p>
<p>Therefore , by parenthesis THM , <span class="math inline">\(y.d\le
u.d&lt;u.f\le y.f&lt;v.d&lt;v.f\)</span> for all <span
class="math inline">\(u\in D\)</span> .</p></li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<h2 id="chapter-2-greedy-algorithm">Chapter 2 : Greedy Algorithm</h2>
<h3 id="interval-scheduling">2.1 Interval Scheduling</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(n\)</span> jobs <span
class="math inline">\(s_i,f_i\)</span></p>
<p>Goal : maximize the #jobs , s.t. at most one job at a time .</p></li>
<li><p>Another view</p>
<p>Connect all jobs pairs <span
class="math inline">\([s_i,f_i],[s_j,f_j]\)</span> if <span
class="math inline">\([s_i,f_i]\cap [s_j,f_j]\neq \varnothing\)</span>
.</p>
<p>Goal <span class="math inline">\(\Leftrightarrow\)</span> maximum
independent set .</p>
<p>In general graph : NP-hard for general graph .</p></li>
<li><p>Algorithm</p>
<p>Repeat : Select the available jobs that finishes first .</p></li>
<li><p>Proof of optimality :</p>
<p>Method : [Exchange Argument] : Compare our solution and the optimal
solution .</p>
<p>SOL : <span class="math inline">\(i_1,i_2,\cdots ,i_m\)</span> , OPT
: <span class="math inline">\(j_1,j_2,\cdots,j_k\)</span> .</p>
<ol type="1">
<li>Claim : If <span class="math inline">\(f_{i_1}\le f_{j_1}\)</span> ,
then <span class="math inline">\(f_{i_r}\le f_{j_r}\)</span> for all
<span class="math inline">\(r\ge 1\)</span> .</li>
</ol>
<p>Proof : [Induction]</p>
<p>If the claim is true for <span class="math inline">\(r-1\)</span> ,
suppose the claim is not true for <span class="math inline">\(r\)</span>
, i.e. <span class="math inline">\(f_{i_r}&gt;f_{j_r}\)</span> . Since
<span class="math inline">\(f_{i_{r-1}}\le f_{j_{r-1}}\)</span> , and
<span class="math inline">\(s_{j_r}&gt;f_{j_{r-1}}\)</span> , then <span
class="math inline">\(f_{i_{r-1}}&lt;s_{j_r}\)</span> , so <span
class="math inline">\(j_r\)</span> is also available , but has earlier
finish time , contradict .</p>
<ol start="2" type="1">
<li>If <span class="math inline">\(m&lt;k\)</span> , then <span
class="math inline">\(f_{i_m}&lt;f_{j_m}\)</span> . We can use <span
class="math inline">\(j_{m+1},\cdots,j_k\)</span> after <span
class="math inline">\(i_m\)</span> .</li>
</ol></li>
</ol>
<h3 id="scheduling-to-minimize-lateness">2.2. Scheduling to minimize
lateness</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : <span class="math inline">\(n\)</span> jobs , each job <span
class="math inline">\(i\)</span> has ddl <span
class="math inline">\(d_i\)</span> and length <span
class="math inline">\(t_i\)</span> . Def lateness : <span
class="math inline">\(l_i:=\max\{0,f_i-d_i\}\)</span></p>
<p>Goal : find a schedule of all <span class="math inline">\(n\)</span>
jobs , and minimize the maximal lateness .</p></li>
<li><p>Equal formularization</p>
<p>Goal : find a permutation <span class="math inline">\(\{p_i\}\in
S_n\)</span> , then <span class="math inline">\(f_i=\sum_{j=1}^i
t_{p_j}\)</span> , <span
class="math inline">\(l_i:=\max\{0,f_i-d_{p_i}\}\)</span> . Minimize
<span class="math inline">\(\max\{l_i\}\)</span> .</p>
<p><span class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(l_i:=f_i-d_{p_i}\)</span> , Minimize <span
class="math inline">\(\max\{0,\max\{l_i\}\}\)</span> .</p></li>
<li><p>Algorithm</p>
<p>Schedule the job in increasing order of <span
class="math inline">\(d_i\)</span> .</p></li>
<li><p>Proof of optimality</p>
<ol type="1">
<li><p>Def (Inversion) : Consider a schedule <span
class="math inline">\(A&#39;\)</span> , <span
class="math inline">\((i,j)\)</span> is an inversion if <span
class="math inline">\(i\)</span> is scheduled before <span
class="math inline">\(j\)</span> but <span
class="math inline">\(d_i&gt;d_j\)</span> .</p></li>
<li><p>If OPT$$ SOL , there must be an inversion , then there must be an
adjacent inversion . Suppose <span
class="math inline">\((i,i+1)\)</span> is an inversion , then <span
class="math inline">\(d_{p_i}&gt;d_{p_{i+1}}\)</span> .</p>
<p>Let <span class="math inline">\(f=\sum_{j=1}^{i-1}t_{p_j}\)</span> ,
so <span class="math inline">\(f_i=f+t_{p_i}\)</span> , <span
class="math inline">\(f_{i+1}=f+t_{p_i}+t_{p_{i+1}}\)</span> , so <span
class="math inline">\(l_i=f+t_{p_i}-d_{p_i}\)</span> , <span
class="math inline">\(l_{i+1}=f+t_{p_i}+t_{p_{i+1}}-d_{p_{i+1}}\)</span>
.</p>
<p>If swap <span class="math inline">\((i,i+1)\)</span> , then <span
class="math inline">\(f_{i+1}&#39;=f+t_{p_{i+1}}\)</span> , <span
class="math inline">\(f_{i}&#39;=f+t_{p_{i+1}}+t_{p_i}\)</span> , so
<span
class="math inline">\(l_{i+1}&#39;=f+t_{p_{i+1}}-d_{p_{i+1}}\)</span> ,
<span
class="math inline">\(l_i&#39;=f+t_{p_{i+1}}+t_{p_i}-d_{p_i}\)</span>
.</p>
<p>Therefore , obviously , <span
class="math inline">\(l_{i+1}&#39;&lt;l_{i+1}\)</span> . Since <span
class="math inline">\(d_{p_i}&gt;d_{p_{i+1}}\)</span> , then <span
class="math inline">\(l_i&#39;&lt;l_i\)</span> . Therefore , swap can
lead to better solution , so OPT is not optimal .</p></li>
</ol></li>
</ol>
<h3 id="shortest-path-without-w0">2.3. Shortest Path (without <span
class="math inline">\(w&lt;0\)</span>)</h3>
<ol type="1">
<li><p>Description</p>
<p>Input : weighted graph <span class="math inline">\(G=(V,E)\)</span> ,
start vertex <span class="math inline">\(s\)</span> .</p>
<p>Output : <span class="math inline">\(d(u)\)</span> for all <span
class="math inline">\(u\in V\)</span> , where <span
class="math inline">\(d(u)=\min_{p\text{ is a path }s\to u}\{\sum_{e\in
p}l(e)\}\)</span> .</p></li>
<li><p>Algorithm [Dijkstra 1959]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init</span></span><br><span class="line"><span class="keyword">for</span>(u in V)&#123;</span><br><span class="line">    d[u]=+inf;</span><br><span class="line">&#125;</span><br><span class="line">d[s]=<span class="number">0</span>; S.<span class="built_in">insert</span>(s);</span><br><span class="line"><span class="comment">// Main Algorithm</span></span><br><span class="line"><span class="keyword">while</span>(S != V)&#123;</span><br><span class="line">    v=<span class="built_in">argmin</span>(d[u]+<span class="built_in">l</span>(e) |v: v in V\S , e=(u,v) , u in S );</span><br><span class="line">    d[v]=d[u]+<span class="built_in">l</span>(e);</span><br><span class="line">    S.<span class="built_in">insert</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Proof</p>
<p>Prove by induction on <span class="math inline">\(S\)</span> . <span
class="math inline">\(\forall v\in S , d(v)=\min dist(s,v)\)</span>
,</p>
<p>Suppose we grow <span class="math inline">\(S\)</span> by adding
<span class="math inline">\(v\)</span> , suppose the proposition does
not hold . Then <span class="math inline">\(d(u)+l_e\)</span> is not the
shortest distance to <span class="math inline">\(v\)</span> . Let <span
class="math inline">\(p\)</span> be the shortest path from <span
class="math inline">\(s\)</span> to <span
class="math inline">\(v\)</span> .</p>
<p>Let <span class="math inline">\(w\)</span> be the last vertex that is
in <span class="math inline">\(S\)</span> , then by induction , all
vertices on <span class="math inline">\(p\)</span> from <span
class="math inline">\(s\)</span> to <span
class="math inline">\(w\)</span> are all in <span
class="math inline">\(S\)</span> . Let <span
class="math inline">\(p&#39;=path(s,u)+e\)</span> .</p>
<p><span class="math inline">\(p&#39;: s\to w\to u\to v\)</span> , <span
class="math inline">\(p:s\to w\to x\to v\)</span> . (<span
class="math inline">\(x\notin S\)</span>) . Since <span
class="math inline">\(d(u)+l_e\)</span> is minimal , <span
class="math inline">\(d(u)+l_e\le d(w)+l_{w,x}\)</span> , but <span
class="math inline">\(dist(p)=d(w)+l_{w,x}+dist(x,v)\)</span> , where
<span class="math inline">\(dist(x,v)\ge 0\)</span> , and <span
class="math inline">\(dist(p)&lt;dist(p&#39;)=d(u)+l_e\)</span> , so
<span class="math inline">\(d(w)+l_{w,x}\le dist(p)&lt;d(u)+l_e\)</span>
, contradict .</p></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-搜索</tag>
        <tag>算法-强连通分量(SCC)</tag>
        <tag>算法-贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Design 3</title>
    <url>/2023/10/07/Algorithm-Design-3/</url>
    <content><![CDATA[<h2 id="chapter-2-greedy-algorithm">Chapter 2 Greedy Algorithm</h2>
<h3 id="minimum-spanning-tree-undirected">2.3 Minimum Spanning Tree
(undirected)</h3>
<ol type="1">
<li><p>Definition</p>
<ol type="1">
<li><p>Input : undirected , edge-weighted graph <span
class="math inline">\(G\)</span></p></li>
<li><p>Output : Minimum Spanning Tree of <span
class="math inline">\(G\)</span></p>
<p>Spanning Tree : a subgraph of <span class="math inline">\(G\)</span>
that is a tree containing all vertices</p>
<p>Minimum : the sum of weights on tree's all edges is
minimized</p></li>
</ol></li>
<li><p>Properties</p>
<ol type="1">
<li><p>Spanning Tree</p>
<ol type="1">
<li>Connectivity <span class="math inline">\(\leftrightarrow\)</span>
check connectivity <span class="math inline">\(\to\)</span>
<strong>cut</strong></li>
<li>Acyclic</li>
</ol></li>
<li><p>Cut</p>
<ol type="1">
<li><p>Def : Graph <span class="math inline">\(G=(V,E),V=A\cup B,A\cap
B=\varnothing\)</span></p>
<p><span class="math inline">\((A,B)\)</span>-cut : <span
class="math inline">\(E(A,B)=\{(u,v)\in E|u\in A,v\in
B\}\)</span></p></li>
<li><p>Observation : If <span class="math inline">\(T\)</span> is a
Spanning Tree , <span class="math inline">\(E(A,B)\)</span> is any cut ,
then <span class="math inline">\(T\cap E(A,B)\neq
\varnothing\)</span></p>
<blockquote>
<p>Otherwise , not connected</p>
</blockquote></li>
</ol></li>
<li><p>Lemma : Assumption : weights are distinct</p>
<p>Suppose <span class="math inline">\(e=(u,v),u\in A,v\in B\)</span> is
the edge with minimum weight in <span
class="math inline">\((A,B)\)</span>-cut , then every MST must contain
<span class="math inline">\(e\)</span> .</p>
<p>Proof : [Exchange Argument , Prove by contradiction]</p>
<p>Suppose <span class="math inline">\(T\)</span> is a MST but <span
class="math inline">\(e\notin T\)</span> . By the observation , there
exists <span class="math inline">\(e&#39;\in T,e&#39;\in E(A,B)\)</span>
.</p>
<p>Let <span class="math inline">\(T&#39;=T-e&#39;+e\)</span> , then
<span class="math inline">\(T\)</span> is still connected , with smaller
weight .</p></li>
</ol></li>
</ol>
<div class="note warning"><p>Problem : <span class="math inline">\(T\)</span> can have cycle !</p>
</div>
<div class="note success"><p>Correction :<br />
Choose one specific <span class="math inline">\(e&#39;\)</span> : <span
class="math inline">\(e\notin T\)</span> , then <span
class="math inline">\(e\)</span> and some edges in <span
class="math inline">\(T\)</span> can form a cycle ( the path from <span
class="math inline">\(u\)</span> to <span
class="math inline">\(v\)</span> on <span
class="math inline">\(T\)</span> ). This cycle must contain an edge
<span class="math inline">\(e&#39;\in E(A,B)\)</span> .</p>
</div>
<ol start="3" type="1">
<li><p>Kruskal's Algorithm</p>
<ol type="1">
<li><p>Algorithm</p>
<p>Successively inserting edges from <span
class="math inline">\(E\)</span> in increasing order of weight .</p>
<p>If edge <span class="math inline">\(e\)</span> would create a cycle .
discard it .</p>
<p>(Using Union-Find Set)</p></li>
<li><p>Proof of Correctness</p>
<p>Consider every added edge <span class="math inline">\(e\)</span> ,
<span class="math inline">\(e\)</span> is the min-weight edge in some
cut</p>
<p><span class="math inline">\(e=(u,v)\)</span> , consider the connected
component <span class="math inline">\(C\)</span> containing <span
class="math inline">\(u\)</span> , then <span
class="math inline">\(e\)</span> is the minimum weight edge in cut <span
class="math inline">\(E(C,V\backslash C)\)</span></p></li>
</ol></li>
<li><p>Prim's Algorithm</p>
<ol type="1">
<li><p>Algorithm</p>
<p>At each step , add the node that can be attached as cheaply as
possible to the partial tree we already have .</p></li>
<li><p>Naive Implementation</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// d[x] : current minimum edge in cut E(&#123;x&#125;,S)</span></span><br><span class="line"><span class="comment">// Init </span></span><br><span class="line"><span class="keyword">for</span> (v in V)&#123;</span><br><span class="line">    d[v]=+inf;</span><br><span class="line">&#125;</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;S.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(S!=V)&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">argmin</span>(d[v] | v in V\S);</span><br><span class="line">    S.<span class="built_in">insert</span>(x); <span class="comment">// using the edge d[x]</span></span><br><span class="line">    <span class="keyword">for</span>(y in <span class="built_in">Neighbour</span>(x))&#123;</span><br><span class="line">        d[y]=<span class="built_in">min</span>(d[y],<span class="built_in">w</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Improvement : Priority Queue</p></li>
</ol></li>
<li><p>Reverse Deletion</p>
<p>Successively removing edges from <span
class="math inline">\(E\)</span> in decreasing order of weight .</p>
<p>If removing edge <span class="math inline">\(e\)</span> would cause
disconnectedness , discard it .</p>
<blockquote>
<p>The reverse version of Kruskal's Algorithm</p>
</blockquote></li>
<li><p>Faster algorithms</p>
<p>[Chazelle] Deterministic Algorithm <span
class="math inline">\(\mathcal O(|E|\alpha(|E|))\)</span></p>
<blockquote>
<p>This means MST is weaker than sorting</p>
</blockquote>
<p>[Karger , Klem , Tarjan] Randomized Algorithm <span
class="math inline">\(\mathcal O(|E|+|V|)\)</span></p>
<p><strong>Open Question</strong> : Deterministic Linear
Algorithm</p></li>
</ol>
<h3 id="union-find-set">2.4 Union-Find Set</h3>
<ol type="1">
<li><p>Definition</p>
<p>Maintain sets of elements , support :</p>
<ol type="1">
<li><code>find(element e)</code> , return the set that contains <span
class="math inline">\(e\)</span></li>
<li><code>union(set Si,set Sj)</code> , combine set <span
class="math inline">\(S_i\)</span> and <span
class="math inline">\(S_j\)</span> , return the union set <span
class="math inline">\(S_i\cup S_j\)</span></li>
</ol></li>
<li><p>Implementation</p>
<p>The sets can be viewed as trees .</p>
<p>The set can be represented by the root of the corresponding tree
.</p>
<p><code>find</code> : find the root of the tree (keep finding
father)</p>
<p><code>union</code> : <span
class="math inline">\(fa(root(S_1))\leftarrow root(S_2)\)</span></p>
<p>Problem : tree can be very deep</p></li>
<li><p>Improve</p>
<ol type="1">
<li><p>启发式合并 / Heuristic merging</p>
<p>To make the tree shallow , suppose <span
class="math inline">\(|S_1|\le |S_2|\)</span></p>
<p>小集合合并到大集合上</p></li>
<li><p>路径压缩 / Path Compression</p>
<p>Suppose one find : <span
class="math inline">\(e,v_1,\cdots,v_k,root\)</span> , after the find ,
let <span
class="math inline">\(fa(e)=fa(v_1)=\cdots=fa(v_k)=root\)</span></p></li>
</ol></li>
<li><p>Time Complexity</p>
<p>Amortized Analysis / 均摊分析 ( using Path Compression and Heuristic
merging)</p>
<p>Suppose we have a sequence of <code>find</code> or <code>union</code>
operations , with length <span class="math inline">\(m\)</span> .</p>
<p>Total running time of union-find is <span
class="math inline">\(\mathcal O(m\alpha(m,n))\)</span></p>
<p><span class="math inline">\(\alpha\)</span> : inverse Ackermann's
function , grows very slow</p>
<blockquote>
<p>Another slow function : <span
class="math inline">\(\log^*(n)\)</span> , number of logs to make <span
class="math inline">\(n\)</span> to small constant (i.e. <span
class="math inline">\(\log(\log\cdots\log(n))\le 5\)</span>)</p>
</blockquote>
<p>See [CLRS] for detailed proof .</p></li>
<li><p>Kruskal's Algorithm Implementation</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(E); <span class="comment">// weight-increasing</span></span><br><span class="line"><span class="keyword">for</span>(edge e=(u,v):E)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(u)!=<span class="built_in">find</span>(v))&#123;</span><br><span class="line">        T.<span class="built_in">insert</span>(e);</span><br><span class="line">        <span class="built_in">union</span>(<span class="built_in">find</span>(u),<span class="built_in">find</span>(v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Total time complexity : <span class="math inline">\(\mathcal
O(|E|\log|E|)\)</span> .</p></li>
</ol>
<h3 id="priority-queue">2.5 Priority Queue</h3>
<ol type="1">
<li><p>Definition</p>
<p>Maintain a set of elements <span class="math inline">\(S\)</span> ,
support :</p>
<p><code>insert(S,x)</code> , insert <span
class="math inline">\(x\)</span> into <span
class="math inline">\(S\)</span> .</p>
<p><code>extract_max(S)</code> , return the maximum element in <span
class="math inline">\(S\)</span> , and then remove this element .</p>
<p><code>max(S)</code> , return the maximum element in <span
class="math inline">\(S\)</span></p>
<p><code>increase_key(S,x,k)</code> , increase value of <span
class="math inline">\(x\)</span> by <span
class="math inline">\(k\)</span></p></li>
<li><p>(Basic) (max) Heap</p>
<ol type="1">
<li><p>Property : Complete binary tree , parent $$ both
children</p></li>
<li><p>Can be implemented in an array</p>
<p><code>fa[x]=x/2</code> , <code>left_child[x]=2x</code> ,
<code>right_child[x]=2x+1</code></p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(S,x)&#123; <span class="comment">// flow down , O(log n)</span></span><br><span class="line">    val[|S|]=x;|S|++;</span><br><span class="line">    <span class="type">int</span> p=|S|<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=root&amp;&amp;val[p]&gt;val[fa[p]])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(val[p],val[fa[p]]);</span><br><span class="line">        p=fa[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Note : build a heap : O(n)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">extract_max</span>(S)&#123; <span class="comment">// flow up , O(log n)</span></span><br><span class="line">    <span class="type">int</span> ret_val=val[root];</span><br><span class="line">    <span class="built_in">swap</span>(val[root],val[|S|<span class="number">-1</span>]); <span class="comment">// swap the root and the last element</span></span><br><span class="line">    |S|--; <span class="comment">// delete original root</span></span><br><span class="line">    <span class="type">int</span> p=root;</span><br><span class="line">    <span class="keyword">while</span>(val[p]&lt;val[left_child[p]]||val[p]&lt;val[right_child[p]])&#123;</span><br><span class="line">        <span class="keyword">if</span>(val[left_child[p]]&gt;val[right_child[p]])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(val[p],val[left_child[p]]);</span><br><span class="line">            p=left_child[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(val[p],val[right_child[p]]);</span><br><span class="line">            p=right_child[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(S)&#123; <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> val[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">increase_key</span>(S,p,k)&#123; <span class="comment">// flow down , O(log n)</span></span><br><span class="line">    val[p]=val[p]+k;</span><br><span class="line">    <span class="keyword">while</span>(p!=root&amp;&amp;val[p]&gt;val[fa[p]])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(val[p],val[fa[p]]);</span><br><span class="line">        p=fa[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Advanced : Fibonacci Heap</p>
<p>Time complexity (amortized-time)</p>
<table>
<thead>
<tr class="header">
<th>operations</th>
<th>binary heap</th>
<th>Fibonacci heap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>insert</code></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
</tr>
<tr class="even">
<td><code>extract_max</code></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
</tr>
<tr class="odd">
<td><code>max</code></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
</tr>
<tr class="even">
<td><code>increase_key</code></td>
<td><span class="math inline">\(\mathcal O(\log n)\)</span></td>
<td><span class="math inline">\(\mathcal O(1)\)</span></td>
</tr>
</tbody>
</table>
<p>See [CLRS] for detailed Fibonacci heap .</p></li>
<li><p>Prim's Algorithm with Priority Queue</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using min priority queue</span></span><br><span class="line"><span class="keyword">for</span> (v in V\&#123;<span class="number">1</span>&#125;)&#123;</span><br><span class="line">    d[v]=+inf;</span><br><span class="line">    inS[v]=<span class="literal">false</span>;</span><br><span class="line">    PQ.<span class="built_in">insert</span>((v,+inf));</span><br><span class="line">&#125;</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;inS[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">PQ.<span class="built_in">insert</span>((<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="comment">// index 1 , value 0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123; <span class="comment">// n-1 rounds</span></span><br><span class="line">    <span class="type">int</span> x=PQ.<span class="built_in">extract_min</span>(); <span class="comment">// argmin value</span></span><br><span class="line">    inS[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// using edge d[x]</span></span><br><span class="line">    <span class="keyword">for</span>(y in <span class="built_in">Neighbour</span>(x))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inS[y] &amp;&amp; <span class="built_in">w</span>(x,y)&lt;d[y])&#123;</span><br><span class="line">            PQ.<span class="built_in">decrease_key</span>(y,d[y]-<span class="built_in">w</span>(x,y));</span><br><span class="line">            d[y]=<span class="built_in">w</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : <span class="math inline">\(\mathcal O(|E|\log
|V|)\)</span> .</p></li>
<li><p>Dijkstra's Algorithm with Priority Queue</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using min priority queue</span></span><br><span class="line"><span class="keyword">for</span>(v in V\&#123;s&#125;)&#123;</span><br><span class="line">    d[v]=+inf;</span><br><span class="line">    inS[v]=<span class="literal">false</span>;</span><br><span class="line">    PQ.<span class="built_in">insert</span>((v,+inf))</span><br><span class="line">&#125;</span><br><span class="line">d[s]=<span class="number">0</span>;inS[s]=<span class="literal">true</span>;</span><br><span class="line">PQ.<span class="built_in">insert</span>((v,+inf));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123; <span class="comment">// n-1 rounds</span></span><br><span class="line">    <span class="type">int</span> x=PQ.<span class="built_in">extract_min</span>();</span><br><span class="line">    inS[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(y in <span class="built_in">Neighbour</span>(x))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inS[y] &amp;&amp; d[y] &gt; d[x]+<span class="built_in">w</span>(x,y) )&#123;</span><br><span class="line">            PQ.<span class="built_in">decrease_key</span>(d[y]-d[x]-<span class="built_in">w</span>(x,y));</span><br><span class="line">            d[y]=d[x]+<span class="built_in">w</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : <span class="math inline">\(\mathcal O(|E|\log
|V|)\)</span> .</p></li>
</ol>
<h3 id="huffman-code">2.6 Huffman Code</h3>
<ol type="1">
<li><p>Code Definition : a set <span class="math inline">\(S\)</span> of
letters encode to <span class="math inline">\(\{0,1\}^*\)</span> , <span
class="math inline">\(r:S\to \{0,1\}^*\)</span></p>
<p>Properties</p>
<ol type="1">
<li><span class="math inline">\(r\)</span> is one-to-one /
injection</li>
<li>encoding / decoding efficiently</li>
<li>minimize average length of the code</li>
<li>[optional] robust to errors , Error Correction Code</li>
</ol></li>
<li><p>Prefix Code</p>
<ol type="1">
<li><p>Def : <span class="math inline">\(\forall x,y\in S\)</span> ,
<span class="math inline">\(r(x)\)</span> is not a prefix of <span
class="math inline">\(r(y)\)</span></p></li>
<li><p>Property : useful for decoding (unique decode) , can decode
greedily</p></li>
<li><p>e.g. <span class="math inline">\(S=\{a,b,c,d,e\}\)</span></p>
<p>Prefix Code <span class="math display">\[
r(a)=11,r(b)=01,r(c)=001,r(d)=10,r(e)=000
\]</span></p>
<p><span class="math display">\[
decode(0000011101)=decode(000\ 001\ 11\ 01)=ecab
\]</span></p>
<p>non-Prefix Code <span class="math display">\[
r(a)=110,r(b)=11,r(c)=01
\]</span></p>
<p><span class="math display">\[
decode(11011)=decode(110\ 11)=decode(11\ 01\ 1)
\]</span></p></li>
<li><p>Prefix Code can be represented using a binary tree</p>
<p>Leafy tree : each leaf corresponds to a letter</p></li>
</ol></li>
<li><p>Minimize the length</p>
<ol type="1">
<li><p>Average encoding length</p>
<p>Suppose each letter has a frequency <span
class="math inline">\(p(x)\)</span> , <span
class="math inline">\(\sum_{x\in S}p(x)=1\)</span> .</p>
<p>Average encoding length : <span class="math display">\[
AEL(r)=\sum_{x\in S}p(x)|r(x)|
\]</span></p></li>
<li><p>[Shannon] Source Coding Theorem <span class="math display">\[
\forall r,AEL(r)\ge \sum_{x\in S}-p(x)\log p(x) =:H
\]</span> See : [Thomas Cover] Information Theory</p></li>
</ol></li>
<li><p>Lemma</p>
<p>There is an optimal code ( or an optimal binary tree ) in which two
lowest-frequency letter are assigned to leaves that are as deep as
possible , and are siblings .</p>
<blockquote>
<p>Proof : 同层换：对 AEL 无影响；跨层： exchange argument</p>
</blockquote></li>
<li><p>Huffman's Code</p>
<p>Initially , construct a set <span class="math inline">\(S\)</span>
containing all letters.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(|S|&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    elem x,y;</span><br><span class="line">    x=<span class="built_in">extract_max</span>(S) , y=<span class="built_in">extract_max</span>(S);</span><br><span class="line">    elem new_elem=(id,<span class="built_in">p</span>(x)+<span class="built_in">p</span>(y));</span><br><span class="line">    <span class="built_in">insert</span>(S,new_elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法-图论</tag>
        <tag>算法-图论-最小生成树</tag>
        <tag>算法-图论-最短路</tag>
        <tag>算法-数据结构-并查集</tag>
        <tag>算法-数据结构-堆/优先队列</tag>
        <tag>编码-Huffman编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Probability and Statistics 1</title>
    <url>/2023/10/08/Probability-and-Statistics-1/</url>
    <content><![CDATA[<h2 id="chapter-0">Chapter 0</h2>
<ol type="1">
<li><p>Categories</p>
<ol type="1">
<li><p>Background in Probability</p>
<ul>
<li><p>what is probability <span class="math inline">\(\to\)</span>
measure theory</p></li>
<li><p>what is integration $$ Riemann / Lebesgue Integration</p></li>
<li><p>Expectation &amp; its properties</p></li>
</ul></li>
<li><p>Probability foundations of Asymptotic Statistics</p>
<ul>
<li>weak law of large numbers</li>
<li>strong law of large numbers (proof by Kolmoguor)</li>
<li>central limit theorem</li>
<li>characteristic function</li>
</ul></li>
<li><p>Estimation inference &amp; testing</p>
<ul>
<li>hypothesis testing</li>
<li>regression analysis</li>
<li>frontiers of statistical research (e.g. distribution of free
test)</li>
</ul></li>
</ol></li>
<li><p>Textbook</p>
<p>[Durrett] Probability Theory &amp; Examples (or PTE)</p></li>
</ol>
<h2 id="chapter-1-background-in-probability">Chapter 1 Background in
Probability</h2>
<h3 id="probability-space">1.1 Probability Space</h3>
<ol type="1">
<li><p>Probability Space</p>
<ol type="1">
<li><p>Def : <span class="math inline">\((\Omega,\mathcal
F,P)\)</span></p>
<p><span class="math inline">\(\Omega\)</span> : set of "outcomes"</p>
<p><span class="math inline">\(\mathcal F\)</span> : set of "events" ,
like subset of <span class="math inline">\(\Omega\)</span></p>
<p><span class="math inline">\(P\)</span> : function : <span
class="math inline">\(\mathcal F\to [0,1]\)</span></p></li>
<li><p><span class="math inline">\(\mathcal F\)</span> should be a <span
class="math inline">\(\sigma\)</span>-field</p>
<ol type="1">
<li><p>Def : [<span class="math inline">\(\sigma\)</span>-field] A
nonempty collection of subsets of <span
class="math inline">\(\Omega\)</span> that</p>
<ul>
<li>补封闭：If <span class="math inline">\(A\in \mathcal F\)</span> ,
then <span class="math inline">\(A^c\in \mathcal F\)</span></li>
<li>可数无穷并封闭：If <span class="math inline">\(A_i\in \mathcal
F\)</span> , <span class="math inline">\(A_i\)</span> is a countable
sequence , then <span class="math inline">\(\cup_i A_i\in \mathcal
F\)</span></li>
</ul></li>
<li><p>Prop :</p>
<ul>
<li><span class="math inline">\(\varnothing \in \mathcal F,\Omega\in
\mathcal F\)</span></li>
</ul>
<blockquote>
<p>Proof : <span class="math inline">\(A\in\mathcal F\)</span> $$ <span
class="math inline">\(A^c\in \mathcal F\)</span> <span
class="math inline">\(\to\)</span> <span class="math inline">\(A\cup
A^c\in \mathcal F\)</span> <span class="math inline">\(\to\)</span>
<span class="math inline">\(\Omega\in \mathcal F\)</span> <span
class="math inline">\(\to\)</span> <span
class="math inline">\(\varnothing\in \mathcal F\)</span></p>
</blockquote>
<ul>
<li>可数无穷交封闭：If <span class="math inline">\(A_i\in \mathcal
F\)</span> , , <span class="math inline">\(A_i\)</span> is a countable
sequence , then <span class="math inline">\(\cap_i A_i\in \mathcal
F\)</span></li>
</ul>
<blockquote>
<p>Proof : <span class="math inline">\(A\cap B=(A^c\cup
B^c)^c\)</span></p>
</blockquote></li>
</ol></li>
</ol></li>
<li><p>Measurable Space</p>
<ol type="1">
<li><p>Def : [measure] : non-negative , countably additive , set
function</p>
<p>A function <span class="math inline">\(\mu:\mathcal F\to \mathbb
R\)</span> with :</p>
<ul>
<li><p><span class="math inline">\(\forall A\in \mathcal F\)</span> ,
<span class="math inline">\(\mu(A)\ge
\mu(\varnothing)=0\)</span></p></li>
<li><p>If <span class="math inline">\(A_i\in \mathcal F\)</span> , <span
class="math inline">\(A_i\)</span> countable <strong>disjoint</strong>
sequence , then <span class="math display">\[
\mu(\cup_i A_i)=\sum_{i}\mu(A_i)
\]</span></p></li>
</ul></li>
<li><p>Def : [probability measure] : a measure <span
class="math inline">\(\mu\)</span> with <span
class="math inline">\(\mu(\Omega)=1\)</span></p></li>
<li><p>Thm : a measure <span class="math inline">\(\mu\)</span> on <span
class="math inline">\((\Omega,\mathcal F)\)</span> satisfies</p>
<ul>
<li><p>monotonicity : <span class="math inline">\(A\subset B\Rightarrow
\mu(A)\le \mu(B)\)</span></p></li>
<li><p>subadditivity : <span class="math inline">\(A\subset
\cup_{i=1}^{\infty} A_i\Rightarrow \mu(A)\le
\sum_{i=1}^{\infty}A_i\)</span></p></li>
<li><p>continuity :</p>
<blockquote>
<p>Def : [<span class="math inline">\(A_i\uparrow A\)</span> ]</p>
<p>For set <span class="math inline">\(A\)</span> : <span
class="math inline">\(A_1\subset A_2\subset\cdots , \cup_i
A_i=A\)</span></p>
<p>For real number <span class="math inline">\(A\)</span> : <span
class="math inline">\(A_1\le A_2\le
\cdots,\lim_{n\to\infty}A_n=A\)</span></p>
</blockquote>
<p>If <span class="math inline">\(A_i\uparrow A\)</span> , then <span
class="math inline">\(\mu(A_i)\uparrow \mu(A)\)</span></p>
<p>If <span class="math inline">\(A_i\downarrow A\)</span> , then <span
class="math inline">\(\mu(A_i)\downarrow \mu(A)\)</span></p></li>
</ul>
<blockquote>
<p>Proof :</p>
<ol type="i">
<li>: Let <span class="math inline">\(B-A=B\cap A^c\)</span> , so if
<span class="math inline">\(A\subset B\)</span> , then <span
class="math inline">\(B=A+(B-A)\)</span> , and <span
class="math inline">\(A,B-A\)</span> are disjoint <span
class="math display">\[
\mu(B)=\mu(A+(B-A))=\mu(A)+\mu(B-A)\ge \mu(A)
\]</span></li>
<li>: Let <span class="math inline">\(A_n&#39;:=A_n\cap A\)</span> , so
<span class="math inline">\(A=\cup_{i=1}^{\infty} A&#39;_i\)</span> .
Let <span
class="math inline">\(B_n=\begin{cases}A_1&#39;&amp;n=1\\A_n&#39;-\cup_{i=1}^{n-1}
A_i&#39;&amp;n\ge 2\end{cases}\)</span></li>
</ol>
Therefore , <span class="math inline">\(B_n\)</span> are disjoint , and
<span class="math inline">\(\cup_{i=1}^{\infty} B_i=\cup_{i=1}^{\infty}
A_i&#39;=A\)</span> <span class="math display">\[
\mu(A)=\mu(\cup_{i} B_i)=\sum_{i}\mu(B_i)\le \sum_{i} \mu(A_i)
\]</span>
<ol start="3" type="i">
<li>: Let <span class="math inline">\(B_n=A_n-A_{n-1}\)</span> , so
<span class="math inline">\(B_n\)</span> are disjoint , <span
class="math inline">\(\cup_{i=1}^{n} B_i=A_n\)</span> , <span
class="math inline">\(\cup_{i=1}^{\infty}B_i=A\)</span> <span
class="math display">\[
\mu(A)=\sum_{i=1}^{\infty} \mu(B_i)=\lim_{n\to\infty}\sum_{i=1}^n
\mu(B_i)=\lim_{n\to \infty}\mu(A_n)
\]</span></li>
</ol>
</blockquote></li>
<li><p>E.g.1 Discrete Probability Space</p>
<p><span class="math inline">\(\Omega\)</span> : countable set , <span
class="math inline">\(\mathcal F\)</span> : the set of all subsets of
<span class="math inline">\(\Omega\)</span> , <span
class="math inline">\(p: \Omega\to[0,1]\)</span> , where <span
class="math inline">\(\sum_{\omega\in \Omega}p(\omega)=1\)</span> .
<span class="math display">\[
P(A):=\sum_{\omega\in A}p(\omega)
\]</span></p></li>
</ol></li>
<li><p>Measure on real line</p>
<ol type="1">
<li><p>Def : [generate] <span class="math inline">\(\mathcal A\)</span>
is a set of some subsets of <span class="math inline">\(\Omega\)</span>.
A <span class="math inline">\(\sigma\)</span>-field is generated by
<span class="math inline">\(\mathcal A\)</span> if it is the smallest
<span class="math inline">\(\sigma\)</span>-field containing <span
class="math inline">\(\mathcal A\)</span> : <span
class="math display">\[
\sigma(\mathcal A):=\bigcap_{\mathcal A\subset\mathcal F,\mathcal
F\text{ is }\sigma\text{-field}}\mathcal F
\]</span></p></li>
<li><p>Def : [Borel Set]</p>
<p>Let <span class="math inline">\(\mathcal A\)</span> be the open
subsets of <span class="math inline">\(\mathbb R^d\)</span> , Borel set
is <span class="math inline">\(\sigma(\mathcal A)\)</span> , denoted as
<span class="math inline">\(\mathcal R^d\)</span> .</p></li>
<li><p>measure for <span class="math inline">\(d=1\)</span></p>
<ol type="1">
<li><p>Def : [Stieltjes measure function] <span
class="math inline">\(F:\mathbb R\to\mathbb R\)</span> satisfies :</p>
<ul>
<li>non-decreasing : <span class="math inline">\(\forall x\ge y ,
F(x)\ge F(y)\)</span></li>
<li>right-continuous : <span class="math inline">\(\lim_{y\downarrow
x}F(y)=\lim_{y\to x^+}F(y)=F(x)\)</span></li>
</ul></li>
<li><p>Thm : For all Stieltjes measure function <span
class="math inline">\(F\)</span> , there is a unique measure <span
class="math inline">\(\mu\)</span> on <span
class="math inline">\((\mathbb R,\mathcal R)\)</span> , with <span
class="math display">\[
\mu((a,b])=F(b)-F(a)
\]</span></p></li>
<li><blockquote>
<p>When <span class="math inline">\(F(x)=x\)</span> , <span
class="math inline">\(\mu\)</span> is Lebesgue measure</p>
</blockquote>
<blockquote>
<p>right-continuous : If <span class="math inline">\(b_n\downarrow
b\)</span> , then <span
class="math inline">\(\cup_{n}(a,b_n]=(a,b_n]\)</span>
（可以保持右闭）</p>
</blockquote></li>
<li><p>Def [CDF] : For probability measure : <span
class="math inline">\(\lim\limits_{x\to
-\infty}F(x)=0,\lim\limits_{x\to+\infty}F(x)=1\)</span></p>
<p><span class="math inline">\(F\)</span> : Cumulative Distribution
Function [CDF] .</p></li>
</ol></li>
</ol></li>
<li><p>(*) semi-algebra , algebra , <span
class="math inline">\(\sigma\)</span>-algebra</p>
<ol type="1">
<li>Def : [semi-algebra , algebra , <span
class="math inline">\(\sigma\)</span>-algebra]</li>
</ol></li>
</ol>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 43%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">structure</th>
<th style="text-align: center;">complement</th>
<th style="text-align: center;">intersection/union</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">semi-algebra</td>
<td style="text-align: center;"><span class="math inline">\(S^c\)</span>
is a finite , disjoint union of sets in <span
class="math inline">\(\mathcal S\)</span></td>
<td style="text-align: center;"><span class="math inline">\(S,T\in
\mathcal S\)</span> , then <span class="math inline">\(S\cap
T\in\mathcal S\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">algebra</td>
<td style="text-align: center;"><span class="math inline">\(A\in
\mathcal A\)</span> , then <span class="math inline">\(A^c\in \mathcal
A\)</span></td>
<td style="text-align: center;"><span class="math inline">\(S,T\in
\mathcal A\)</span> , then <span class="math inline">\(S\cap T,S\cup
T\in \mathcal A\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\sigma\)</span>-algebra</td>
<td style="text-align: center;"><span class="math inline">\(A\in
\mathcal F\)</span> , then <span class="math inline">\(A^c\in \mathcal
F\)</span></td>
<td style="text-align: center;"><span class="math inline">\(A_i\in
\mathcal F\)</span> , countable sequence , then <span
class="math inline">\(\cup_i A_i\in \mathcal F\)</span></td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li><p>E.g. [algebra but not <span
class="math inline">\(\sigma\)</span>-algebra]</p>
<p><span class="math inline">\(\Omega=\mathbb Z\)</span> , <span
class="math inline">\(\mathcal A=\{A\subset \Omega | A\text{ or
}A^c\text{ is finite}\}\)</span></p>
<p><span class="math inline">\(\mathcal A\)</span> is obviously algebra
but not <span class="math inline">\(\sigma\)</span>-algebra</p></li>
<li><p>Lemma</p>
<p>If <span class="math inline">\(\mathcal S\)</span> is a semi-algebra
, then <span class="math inline">\(\bar{\mathcal S}=\{\text{finite
disjoint union of sets in }\mathcal S\}\)</span> is algebra .</p>
<p><span class="math inline">\(\bar{\mathcal S}\)</span> is called the
algebra generated by <span class="math inline">\(\mathcal S\)</span>
.</p>
<blockquote>
<p>Proof : easy to check two properties of algebra</p>
</blockquote>
<blockquote>
<p>Question : Is this generation the smallest generation ?</p>
</blockquote></li>
<li><p>Def : [measure for algebra] a measure <span
class="math inline">\(\mu\)</span> on an algebra <span
class="math inline">\(\mathcal A\)</span> satisfies :</p>
<ul>
<li><p><span class="math inline">\(\forall A\in \mathcal A , \mu(A)\ge
\mu(\varnothing)=0\)</span></p></li>
<li><p>If <span class="math inline">\(A_i\in \mathcal A\)</span> is a
disjoint sequence , and <span class="math inline">\(\cup_i A_i\in
\mathcal A\)</span> , then <span class="math display">\[
\mu(\cup_i A_i)=\sum_{i}\mu(A_i)
\]</span></p></li>
</ul>
<p>Def : [<span class="math inline">\(\sigma\)</span>-finite] If there
exists a sequence of sets $A_nA $ , $(A_n)&lt;$ , <span
class="math inline">\(\cup_n A_n=\Omega\)</span> .</p>
<blockquote>
<p>We can let <span class="math inline">\(A_n&#39;=\cup_{i=1}^n
A_i\)</span> , then <span class="math inline">\(A_n&#39;\uparrow
\Omega\)</span> .</p>
<p>We can let <span
class="math inline">\(A_n&#39;=A_n\cap(\cap_{i=1}^{n-1}A_i^c)\)</span> ,
then <span class="math inline">\(A_n&#39;\)</span> are disjoint .</p>
<p>即，在构造这样的 <span class="math inline">\(A_n\)</span>
的时候，我们可以直接考虑 <span class="math inline">\(A_n\uparrow
\Omega\)</span> 或 <span class="math inline">\(A_n\)</span> 不交</p>
</blockquote></li>
<li><p>Thm : <span class="math inline">\(\mathcal S\)</span> is a
semi-algebra , <span class="math inline">\(\mu\)</span> defined on <span
class="math inline">\(\mathcal S\)</span> with <span
class="math inline">\(\mu(\varnothing)=0\)</span></p>
<ol type="i">
<li>. If <span class="math inline">\(\mu\)</span> satisfies :</li>
</ol>
<ul>
<li>If <span class="math inline">\(S\in \mathcal S\)</span> is a finite
disjoint union of sets <span class="math inline">\(S_i\in \mathcal
S\)</span> , then <span
class="math inline">\(\mu(S)=\sum_{i}\mu(S_i)\)</span></li>
<li>If <span class="math inline">\(S_i,S\in \mathcal S\)</span> , <span
class="math inline">\(S=+_{i\ge 1} S_i\)</span> , then <span
class="math inline">\(\mu(S)\le \sum_{i\ge 1} \mu(S_i)\)</span></li>
</ul>
<p>Then <span class="math inline">\(\mu\)</span> has a unique extension
<span class="math inline">\(\bar \mu\)</span> that is a measure on <span
class="math inline">\(\bar{\mathcal S}\)</span> .</p>
<ol start="2" type="i">
<li>. If <span class="math inline">\(\bar\mu\)</span> is <span
class="math inline">\(\sigma\)</span>-finite , then there is a unique
extension <span class="math inline">\(\hat \mu\)</span> that is a
measure on <span class="math inline">\(\sigma(\mathcal S)\)</span>
.</li>
</ol></li>
<li><p>Lemma : If <span class="math inline">\(\mathcal S\)</span> is a
semi-algebra , <span class="math inline">\(\mu\)</span> defined on <span
class="math inline">\(\mathcal S\)</span> with <span
class="math inline">\(\mu(\varnothing)=0\)</span> . If <span
class="math inline">\(S\in \mathcal S\)</span> is a finite disjoint
union of sets <span class="math inline">\(S_i\in \mathcal S\)</span> ,
then <span class="math inline">\(\mu(S)=\sum_{i}\mu(S_i)\)</span> . Then
,</p>
<ul>
<li>If <span class="math inline">\(A,B_i\in \bar{\mathcal S}\)</span> ,
<span class="math inline">\(A=+_{i=1}^n B_i\)</span> , then <span
class="math inline">\(\bar \mu(A)=\sum_{i=1}^n
\bar\mu(B_i)\)</span></li>
<li>If <span class="math inline">\(A,B_i\in \bar{\mathcal S}\)</span> ,
<span class="math inline">\(A\subset \cup_{i=1}^n B_i\)</span> , then
<span class="math inline">\(\bar \mu(A)\le \sum_{i=1}^n
\bar\mu(B_i)\)</span></li>
</ul>
<blockquote>
<p>相当于，上面 (i) 中如果第一个条件成立，对于有限情况下的 第二个条件
一定成立，并可以直接扩展到 <span class="math inline">\(\bar{\mathcal
S}\)</span> 和 <span class="math inline">\(\bar \mu\)</span> 上 。</p>
</blockquote></li>
<li><p>可以借助 Thm , 证明 Stieltjes measure function 对应的 measure
存在，且证明过程需要左开。</p></li>
<li><p>(*) measure on <span class="math inline">\(\mathbb
R^d\)</span></p>
<ol type="1">
<li><p>直接采用类似 Stieltjes measure function 的条件构造 measure
是不够的</p>
<p>Restrictions :</p>
<ul>
<li>non-decreasing : If <span class="math inline">\(\vec x\le \vec
y\)</span> ( <span class="math inline">\(\forall i\in [d] , x_i\le
y_i\)</span>) , then <span class="math inline">\(F(\vec x)\le F(\vec
y)\)</span></li>
<li>right-continuous : Define <span class="math inline">\(\vec
y\downarrow \vec x\)</span> as <span class="math inline">\(\forall i\in
[d] , y_i\downarrow x_i\)</span> , then <span
class="math inline">\(\lim_{\vec y\downarrow \vec x}F(\vec y)=F(\vec
x)\)</span></li>
<li>(probability measure) <span class="math inline">\(\lim\limits_{\vec
x\downarrow -\infty}F(\vec x)=0\)</span> , <span
class="math inline">\(\lim_{\vec x\uparrow +\infty}F(\vec
x)=1\)</span></li>
</ul>
<p>Problem : <span class="math display">\[
F(x_1,x_2)=\begin{cases}
1&amp;x_1\ge 1,x_2\ge 1\\
\frac{2}{3}&amp;x_1\ge 1,x_2\in [0,1)\\
\frac{2}{3}&amp;x_1\in [0,1),x_2\ge 1\\
0&amp;\text{otherwise}
\end{cases}
\]</span></p>
<p><span class="math display">\[
\mu((a_1,b_1]\times(a_2,b_2])=F(b_1,b_2)-F(a_1,b_2)-F(b_1,a_2)+F(a_1,a_2)
\]</span></p>
<p>Let $a_1,a_2=1-$ , <span class="math inline">\(b_1,b_2=1\)</span> ,
<span class="math inline">\(\epsilon \to 0\)</span> , then <span
class="math display">\[
\mu(\{1\}\times\{1\})=-\frac{1}{3}&lt;0
\]</span></p></li>
<li><p>Def : [ <span class="math inline">\(\mathbb R^d\)</span> measure
]</p>
<p>Consider finite rectangles <span
class="math inline">\(A=(a_1,b_1]\times\cdots\times(a_d,b_d]\)</span> ,
<span
class="math inline">\(V=\{a_1,b_1\}\times\cdots\times\{a_d,b_d\}\)</span></p>
<p>If <span class="math inline">\(v\in V\)</span> , define <span
class="math display">\[
sgn(v)=(-1)^{|\{i\in [d]|v_i=a_i\}|}\\
\Delta_A F:=\sum_{v\in V}sgn(v)F(v)
\]</span> let <span class="math inline">\(\mu(A)=\Delta_A F\)</span>
.</p>
<blockquote>
<p>此处相当于 <span class="math inline">\(d\)</span>
维前缀和与差分，<span class="math inline">\(V\)</span> 相当于 <span
class="math inline">\(d\)</span> 维矩形 <span
class="math inline">\(A\)</span> 的所有顶点，<span
class="math inline">\(sgn(v)\)</span> 相当于顶点 <span
class="math inline">\(v\)</span> 有多少维是左顶点，然后容斥求差分。</p>
</blockquote></li>
<li><p>Thm : [<span class="math inline">\(\mathbb R^d\)</span> measure ]
If <span class="math inline">\(F:\mathbb R^d\to [0,1]\)</span> ,
satisfies the <span class="math inline">\(3\)</span> restrictions above
, and for all rectangles <span class="math inline">\(A\)</span> , <span
class="math inline">\(\Delta_A F\ge 0\)</span> . Then there is a unique
probability measure <span class="math inline">\(\mu\)</span> on <span
class="math inline">\((\mathbb R^d,\mathcal R^d)\)</span> that <span
class="math inline">\(\mu(A)=\Delta_A F\)</span> for all finite
rectangles .</p></li>
<li><blockquote>
<p>If <span class="math inline">\(F(\vec x)=\prod_{i=1}^d
F_i(x_i)\)</span> , <span class="math inline">\(F_i\)</span> are all
Stieltjes measure function , then <span class="math display">\[
\Delta_A F=\prod_{i=1}^d (F_i(b_i)-F_i(a_i))
\]</span> When <span class="math inline">\(F_i(x)=x\)</span> for all
<span class="math inline">\(i\in [d]\)</span> , <span
class="math inline">\(F\)</span> is Lebesgue measure on <span
class="math inline">\(\mathbb R^d\)</span> .</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="random-variables">1.2 Random Variables</h3>
<ol type="1">
<li><p>measurable map</p>
<ol type="1">
<li><p>Def : [measurable map] <span class="math inline">\(X:\Omega\to
S\)</span> is a measurable map from <span
class="math inline">\((\Omega,\mathcal F)\)</span> to <span
class="math inline">\((S,\mathcal S)\)</span> if <span
class="math display">\[
\forall B\in \mathcal S , X^{-1}(B):=\{w\in \Omega|X(w)\in B\}\in
\mathcal F
\]</span> Def : [random vector] When <span
class="math inline">\((S,\mathcal S)=(\mathbb R^d,\mathcal R^d)\)</span>
, <span class="math inline">\(X\)</span> is random vector .</p>
<p>Def : [random variable] When <span class="math inline">\((S,\mathcal
S)=(\mathbb R,\mathcal R)\)</span> , <span
class="math inline">\(X\)</span> is a random variable .</p></li>
<li><blockquote>
<p>虽然 measurable map 写作 from <span
class="math inline">\((\Omega,\mathcal F)\)</span> to <span
class="math inline">\((S,\mathcal S)\)</span> ，但 <span
class="math inline">\(X\)</span> 本身并不实现 <span
class="math inline">\(\mathcal F\to\mathcal S\)</span> 的映射，只有
<span class="math inline">\(\Omega\to S\)</span> 的映射。 <span
class="math inline">\(\mathcal F,\mathcal S\)</span> 是表明 measurable
的"范围"</p>
</blockquote>
<blockquote>
<p>Random variable is not a variable but a (measurable) map</p>
<p>这也很好解释了 <span class="math inline">\(E(X^2)\)</span>
这种类型的记号的实际含义</p>
</blockquote></li>
<li><p>Thm [a sufficient condition for measurable map]</p>
<p><span class="math inline">\(X:\Omega\to S\)</span> , $A $ : a
collection of some subsets of <span class="math inline">\(S\)</span> ,
If</p>
<ul>
<li><span class="math inline">\(\forall A\in \mathcal A , X^{-1}(A)\in
\mathcal F\)</span></li>
<li><span class="math inline">\(\mathcal A\)</span> generates <span
class="math inline">\(\mathcal S\)</span></li>
</ul>
<p>Then <span class="math inline">\(X\)</span> is a measurable map from
<span class="math inline">\((\Omega,\mathcal F)\)</span> to <span
class="math inline">\((S,\mathcal S)\)</span> .</p>
<blockquote>
<p>Proof : Prove <span class="math inline">\(\mathcal B=\{B\subset
S|X^{-1}(B)\in \mathcal F\}\)</span> is a <span
class="math inline">\(\sigma\)</span>-field , and obviously <span
class="math inline">\(\mathcal A\subset \mathcal B\)</span> . Consider
generation is the smallest , <span class="math inline">\(\mathcal
S\subset \mathcal B\)</span> .</p>
</blockquote></li>
<li><p>E.g. <span class="math inline">\(f:\mathbb R^d\to \mathbb
R\)</span> : <span class="math inline">\(f(x_1,\cdots,x_d)=\sum_{i=1}^d
x_i\)</span> is a measurable map from <span
class="math inline">\((\mathbb R^d,\mathcal R^d)\)</span> to <span
class="math inline">\((\mathbb R,\mathcal R)\)</span> .</p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>概率与统计</category>
      </categories>
      <tags>
        <tag>概率论-概率空间</tag>
        <tag>实分析-测度</tag>
        <tag>实分析-代数空间</tag>
        <tag>实分析-测度-可测映射</tag>
        <tag>概率论-随机变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Probability and Statistics 2</title>
    <url>/2023/10/08/Probability-and-Statistics-2/</url>
    <content><![CDATA[<h2 id="chapter-1-background-in-probability">Chapter 1 Background in
Probability</h2>
<h3 id="random-variables">1.2 Random Variables</h3>
<ol type="1">
<li><p>measurable map</p>
<ol type="1">
<li><p>Remark of Thm [a sufficient condition for measurable map]</p>
<blockquote>
<p>If <span class="math inline">\(\mathcal S\)</span> is a <span
class="math inline">\(\sigma\)</span>-field , then <span
class="math inline">\(\{X^{-1}(B)|B\in \mathcal S\}\)</span> is a <span
class="math inline">\(\sigma\)</span>-field</p>
</blockquote>
<blockquote>
<p>Def : [generation of measurable map] <span
class="math inline">\(\sigma(X)\)</span> is the <span
class="math inline">\(\sigma\)</span>-field generated by <span
class="math inline">\(X\)</span> <span class="math display">\[
\sigma(X)=\{X^{-1}(B)|B\in \mathcal S\}
\]</span></p>
</blockquote>
<blockquote>
<p><span class="math inline">\(\sigma(X)\)</span> is the smallest <span
class="math inline">\(\sigma\)</span>-field on <span
class="math inline">\(\Omega\)</span> that makes <span
class="math inline">\(X\)</span> a measurable map to <span
class="math inline">\((S,\mathcal S)\)</span> .</p>
</blockquote></li>
<li><p>Thm [measurable map composition] : If <span
class="math inline">\(X:(\Omega,\mathcal F)\to(S,\mathcal S)\)</span> ,
<span class="math inline">\(f:(S,\mathcal S)\to (T,\mathcal T)\)</span>
are both measurable maps , then <span class="math inline">\(f\circ
X\)</span> is a measurable map <span
class="math inline">\((\Omega,\mathcal S)\to(T,\mathcal T)\)</span>
.</p>
<blockquote>
<p>Proof : <span class="math inline">\((f\circ
X)^{-1}(B)=X^{-1}(f^{-1}(B))\)</span> , <span
class="math inline">\(C:=f^{-1}(B)\in \mathcal S\)</span> , <span
class="math inline">\(X^{-1}(C)\in \mathcal F\)</span></p>
</blockquote></li>
<li><p>Cor : If <span class="math inline">\(X_1,\cdots,X_n\)</span> are
random variables , <span class="math inline">\(f:(\mathbb R^n,\mathcal
R^n)\to(\mathbb R,\mathcal R)\)</span> is measurable , then <span
class="math inline">\(f(X_1,\cdots,X_n)\)</span> is a random variable
.</p></li>
<li><p>(*) Cor : <span class="math inline">\(X_1,\cdots,X_n\)</span> are
random variables , then <span
class="math inline">\(X_1+\cdots+X_n\)</span> is a random variable
.</p></li>
<li><p>(*) Thm : <span class="math inline">\(X_1,\cdots\)</span> are
random variables , then <span class="math inline">\(\inf_n X_n\)</span>
, <span class="math inline">\(\sup_n X_n\)</span> , <span
class="math inline">\(\liminf_n X_n\)</span> , <span
class="math inline">\(\limsup_n X_n\)</span> are random variables</p>
<blockquote>
<p>Proof : <span class="math inline">\(\{\inf_n
X_n&lt;a\}=\cup_n\{X_n&lt;a\}\in\mathcal F\)</span> . <span
class="math display">\[
\liminf_{n\to \infty}X_n=\sup_n\left(\inf_{m\ge n}X_m\right)
\]</span> <span class="math inline">\(Y_n=\inf_{m\ge n}X_m\)</span> is a
random variable .</p>
</blockquote></li>
</ol></li>
<li><p>(*) Generalization of random variable</p>
<ol type="1">
<li><p>Def : [Converges almost surely]</p>
<p>From Thm above , the following set is a measurable set <span
class="math display">\[
\Omega_o:=\{w:\lim_{n\to\infty}X_n\text{
exists}\}=\{w:\limsup_{n\to\infty}X_n-\liminf_{n\to\infty}X_n=0\}
\]</span> If <span class="math inline">\(P(\Omega_o)=1\)</span> , then
<span class="math inline">\(X_n\)</span> converges almost surely ( a.s.
) .</p>
<blockquote>
<p>即一列 <span class="math inline">\(X_n\)</span> 是几乎处处收敛的
当且仅当 <span class="math inline">\(X_n\)</span> 不收敛的点集测度为
<span class="math inline">\(0\)</span></p>
</blockquote>
<p>Def : <span class="math inline">\(X_\infty:=\limsup_{n\to \infty}
X_n\)</span></p>
<p>Problem : <span class="math inline">\(X_{\infty}\)</span> can have
value <span class="math inline">\(\pm\infty\)</span> .</p></li>
<li><p>Def : [Generalized random variable]</p>
<p>A function whose domain is <span class="math inline">\(D\in \mathcal
F\)</span> and range is <span class="math inline">\(\mathbb
R^*:=[-\infty,+\infty]\)</span> is a random variable if <span
class="math inline">\(\forall B\in \mathcal R^* , X^{-1}(B)\in \mathcal
F\)</span> .</p>
<p>Def : [Extended Borel set ] : <span class="math inline">\(\mathcal
R^*\)</span> is generated by intervals of form <span
class="math inline">\([-\infty,a),(a,b),(b,+\infty]\)</span> , <span
class="math inline">\(a,b\in \mathbb R\)</span> .</p>
<blockquote>
<p>extended real line <span class="math inline">\((\mathbb R^*,\mathcal
R^*)\)</span> is a measurable space</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="distribution">1.3 Distribution</h3>
<ol type="1">
<li><p>Definition of Distribution</p>
<ol type="1">
<li><p>Def : [distribution] <span class="math inline">\(X\)</span> is a
random variable , then let <span class="math inline">\(\mu=P\circ
X^{-1}\)</span> ( <span class="math inline">\(\mu(A)=P(X\in A)\)</span>
) , <span class="math inline">\(\mu\)</span> is a probability measure
called distribution .</p></li>
<li><p>Check <span class="math inline">\(\mu\)</span> is a probability
measure <span class="math inline">\((\mathbb R,\mathcal R)\to (\mathbb
R,\mathcal R)\)</span> .</p>
<ul>
<li><p><span class="math inline">\(\mu(A)=P(\{w\in \Omega:X(w)\in
A\})\ge 0\)</span></p></li>
<li><p>If <span class="math inline">\(A_i\in \mathcal R\)</span> are
disjoint countable sequence , then <span
class="math inline">\(X^{-1}(A_i)\)</span> are also disjoint <span
class="math display">\[
\begin{aligned}
\mu(\cup_i A_i)&amp;=P(X^{-1}(\cup_i A_i))\\
&amp;=P(\cup_i X^{-1}(A_i))\\
&amp;=\sum_{i} P(X^{-1}(A_i))\\
&amp;=\sum_{i} \mu(A_i)
\end{aligned}
\]</span></p></li>
</ul></li>
</ol></li>
<li><p>distribution function</p>
<ol type="1">
<li><p>Def : [distribution function] Let <span
class="math inline">\(F(x)=P(X\le x)\)</span> , <span
class="math inline">\(F(x)\)</span> is the distribution function .</p>
<blockquote>
<p><span class="math inline">\(F(x)=P(X\le x)\)</span> : Let <span
class="math inline">\(A_x=(-\infty,x]\)</span> , <span
class="math inline">\(F(x)=P(X^{-1}(A_x))=\mu(A_x)\)</span></p>
</blockquote>
<blockquote>
<p><span class="math inline">\(F(x)\)</span> can be viewed as the CDF of
<span class="math inline">\(\mu\)</span> / the Stieltjes measure
function</p>
</blockquote></li>
<li><p>Thm [Props of distribution function] : Let <span
class="math inline">\(F\)</span> be a distribution function</p>
<ul>
<li><p><span class="math inline">\(F\)</span> : non-decreasing</p></li>
<li><p><span class="math inline">\(\lim\limits_{x\to -\infty
}F(x)=0\)</span> , <span
class="math inline">\(\lim\limits_{x\to+\infty}F(x)=1\)</span></p></li>
</ul>
<blockquote>
<p><span class="math inline">\(x\to -\infty , \{X\le x\}\downarrow
\varnothing\)</span> , <span class="math inline">\(x\to+\infty , \{X\le
x\}\uparrow \Omega\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(F\)</span> : right continuous , <span
class="math inline">\(F(x^+)=\lim_{y\downarrow x}F(y)=F(x)\)</span></li>
</ul>
<blockquote>
<p><span class="math inline">\(y=x+\epsilon\)</span> , <span
class="math inline">\(\{X\le y\}=\{X\le x+\epsilon\}\downarrow \{X\le
x\}\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(F(x^-)=P(X&lt;x)\)</span></li>
</ul>
<blockquote>
<p><span class="math inline">\(y=x-\epsilon\)</span> , <span
class="math inline">\(\{X\le y\}=\{X\le x-\epsilon\}\uparrow
\{X&lt;x\}\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(P(X=x)=F(x)-F(x^-)\)</span></li>
</ul></li>
<li><p>Thm [Judgement of distribution function] : <span
class="math inline">\(F\)</span> satisfies (i) , (ii) , (iii) is a
distribution function</p>
<blockquote>
<p>Proof : [construction]</p>
<p>Let <span class="math inline">\(\Omega=(0,1)\)</span> , <span
class="math inline">\(\mathcal F\)</span> is the corresponding Borel set
, <span class="math inline">\(P\)</span> is Lebesgue measure , so <span
class="math inline">\(P((a,b])=b-a\)</span> .</p>
<p>Let <span class="math inline">\(X(w)=\sup\{y:F(y)&lt;w\}\)</span> ,
we want to prove that <span class="math inline">\(P(X\le
x)=F(x)\)</span> .</p>
<p>Since <span class="math inline">\(F(x)=P(\{w:w\le F(x)\})\)</span> ,
we want to prove that : <span class="math display">\[
\{w:X(w)\le x\}=\{w:w\le F(x)\} \quad\quad \quad (*)
\]</span> <span class="math inline">\(R\subset L\)</span> : <span
class="math inline">\(\forall w,w\le F(x)\)</span> , and <span
class="math inline">\(X(w)=\sup\{y:F(y)&lt;w\}\)</span> , so <span
class="math inline">\(F(X(w))\le w\le F(x)\)</span> , so <span
class="math inline">\(X(w)\le x\)</span> .</p>
<p><span class="math inline">\(R^c\subset L^c\)</span> : <span
class="math inline">\(\forall w,w&gt;F(x)\)</span> , and <span
class="math inline">\(X(w)=\sup\{y:F(y)&lt;w\}\)</span> .</p>
<p><span class="math inline">\(F\)</span> : right continuous , so <span
class="math inline">\(\exists \epsilon&gt;0\)</span> , <span
class="math inline">\(F(x+\epsilon)&lt;w\)</span> , so <span
class="math inline">\(X(w)\ge x+\epsilon&gt;x\)</span> .</p>
</blockquote>
<p>Equation (*) means :</p>
<p><img src="/images/posts/PS2_fig1.png" /></p></li>
<li><p>Remark</p>
<p>Each distribution function <span class="math inline">\(F\)</span>
corresponds to a unique distribution measure <span
class="math inline">\(\mu\)</span></p>
<p>One distribution function <span class="math inline">\(F\)</span> can
correspond to many different random variables</p>
<p>Def [equal in distribution] : If <span
class="math inline">\(X,Y\)</span> have same distribution
measure/function , then <span class="math inline">\(X\)</span> and <span
class="math inline">\(Y\)</span> are equal in distribution , denote as
<span class="math inline">\(X\overset{d}{=}Y\)</span> or <span
class="math inline">\(X=_d Y\)</span> .</p></li>
</ol></li>
<li><p>Density function</p>
<ol type="1">
<li><p>Def [density function] : when a distribution function <span
class="math inline">\(F(x)=P(X\le x)\)</span> has the form <span
class="math display">\[
F(x)=\int_{-\infty}^x f(y)\ dy
\]</span> then <span class="math inline">\(X\)</span> has the density
function <span class="math inline">\(f\)</span> , denote as <span
class="math inline">\(f_X(x)\)</span> .</p>
<blockquote>
<p><span class="math display">\[
P(X=x)=\lim_{\epsilon\to0}\int_{x-\epsilon}^{x+\epsilon} f(y)dy=0
\]</span></p>
</blockquote></li>
<li><p>Prop : (necessary and sufficient)</p>
<ul>
<li><span class="math inline">\(f(x)\ge 0\)</span></li>
<li><span
class="math inline">\(\int_{-\infty}^{+\infty}f(x)dx=1\)</span></li>
</ul></li>
</ol></li>
<li><p>Discrete / Continuous</p>
<p>A probability measure <span class="math inline">\(P\)</span> is
discrete if there exists a countable set <span
class="math inline">\(S\)</span> that <span
class="math inline">\(P(S^c)=0\)</span> ( only non-zero on countable
set) .</p>
<p>Discrete : usually <span class="math inline">\([a_i,b_i)\)</span>
segments like .</p></li>
</ol>
<h3 id="integration">1.4 Integration</h3>
<p>Intuition : Expectation needs Integration .</p>
<ol type="1">
<li><p>Notations</p>
<ol type="1">
<li><p>Def : <span class="math inline">\((\Omega,\mathcal F)\)</span> ,
with measure <span class="math inline">\(\mu\)</span> , <span
class="math inline">\(f:(\Omega,\mathcal F)\to(\mathbb R,\mathcal
R)\)</span> . Denote the integration as <span class="math inline">\(\int
fd\mu\)</span> .</p></li>
<li><p>Restriction for <span class="math inline">\(\mu\)</span> : should
be <span class="math inline">\(\sigma\)</span>-finite measure</p>
<p>e.g. Lebesgue measure is <span
class="math inline">\(\sigma\)</span>-finite : <span
class="math inline">\(A_i=[-i,i]\)</span> , so <span
class="math inline">\(\mu(A_i)&lt;\infty\)</span> and <span
class="math inline">\(\cup_i{A_i}=\mathbb R\)</span> .</p></li>
<li><p>Restriction for <span class="math inline">\(\int fd\mu\)</span>
:</p>
<ol type="i">
<li><span class="math inline">\(\varphi\ge 0\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int\varphi d\mu\ge 0\)</span></li>
</ol>
<p>Def [almost everywhere] : <span
class="math inline">\(\mu\)</span>-a.e. : <span
class="math inline">\(\mu(\{w:\varphi(w)&lt;0\})=0\)</span> .</p>
<ol start="2" type="i">
<li><p><span class="math inline">\(\int a\varphi d\mu=a\int \varphi
d\mu\)</span></p></li>
<li><p><span class="math inline">\(\int (\varphi+\psi)d\mu=\int \varphi
d\mu+\int \psi d\mu\)</span></p></li>
<li><p><span class="math inline">\(\varphi\le \psi\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int \varphi d\mu\le \int \psi
d\mu\)</span></p></li>
<li><p><span class="math inline">\(\varphi=\psi\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , then <span
class="math inline">\(\int \varphi d\mu=\int \psi d\mu\)</span></p></li>
<li><p><span class="math inline">\(\left|\int \varphi d\mu\right|\le
\int |\varphi|d\mu\)</span></p></li>
</ol></li>
<li><p>Thm : (i),(ii),(iii) can derive (iv),(v),(vi)</p></li>
</ol></li>
<li><p>Simple Function</p>
<ol type="1">
<li><p>Def [simple function] : If <span
class="math inline">\(\varphi(\omega)=\sum_{i=1}^n a_i \mathbb
1_{A_i}\)</span> , and <span class="math inline">\(A_i\)</span> are
disjoint sets , <span
class="math inline">\(\mu(A_i)&lt;\infty\)</span></p></li>
<li><p>Def [simple function integration] : If <span
class="math inline">\(\varphi(\omega)=\sum_{i=1}^n a_i \mathbb
1_{A_i}\)</span> , define <span class="math display">\[
\int \varphi d\mu=\sum_{i=1}^n a_i \mu(A_i)
\]</span></p></li>
<li><p>Check Props</p>
<blockquote>
<ol type="i">
<li><p>: <span class="math inline">\(\varphi\ge 0\)</span> <span
class="math inline">\(\mu\)</span>-a.e. , so for all <span
class="math inline">\(A_i\)</span> with <span
class="math inline">\(\mu(A_i)&gt;0\)</span> , <span
class="math inline">\(a_i\ge 0\)</span> .</p></li>
<li><p>: trivial</p></li>
</ol>
</blockquote>
<blockquote>
<ol start="3" type="i">
<li>: Suppose <span class="math inline">\(\varphi=\sum_{i=1}^m a_i
\mathbb 1_{A_i}\)</span> , <span class="math inline">\(\psi=\sum_{j=1}^n
b_j \mathbb 1_{B_j}\)</span></li>
</ol>
<p>Define <span class="math inline">\(A_0=\cup_{j} B_j-\cup_i
A_i\)</span> , <span class="math inline">\(B_0=\cup_i A_i-\cup_j
B_j\)</span> . Let <span class="math inline">\(a_0=b_0=0\)</span> .</p>
<p>Therefore <span class="math inline">\(\cup_{j=1}^n B_j\subset
\cup_{i=0}^n A_i\)</span> and <span class="math inline">\(\cup_{i=1}^m
A_i\subset \cup_{j=1}^n B_j\)</span> . <span class="math display">\[
\begin{aligned}
\int(\varphi+\psi)d\mu&amp;=\sum_{i=0}^m \sum_{j=0}^n
(a_i+b_j)\mu(A_i\cap B_j)\\
&amp;=\sum_{i=0}^m a_i\sum_{j=0}^n \mu(A_i\cap
B_j)+\sum_{j=0}^nb_j\sum_{i=0}^m \mu(A_i\cup B_j)\\
&amp;=\sum_{i=0}^m a_i\mu(A_i)+\sum_{j=0}^n b_j\mu(B_j)\\
&amp;=\int \varphi d\mu +\int \psi d\mu
\end{aligned}
\]</span></p>
</blockquote></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>概率与统计</category>
      </categories>
      <tags>
        <tag>实分析-测度-可测映射</tag>
        <tag>概率论-随机变量</tag>
        <tag>概率论-分布函数</tag>
        <tag>概率论-概率密度函数</tag>
        <tag>实分析-Lebesgue积分</tag>
      </tags>
  </entry>
  <entry>
    <title>Zero-Knowledge Proof and Secure Multi-Party Computation 1</title>
    <url>/2023/10/06/Zero-Knowledge-Proof-and-Secure-Multi-Party-Computation-1/</url>
    <content><![CDATA[<h2 id="lec01-basic-definitions-and-examples-of-zkp">Lec01 Basic
Definitions and Examples of ZKP</h2>
<h3 id="basic-notations">1 Basic Notations</h3>
<ol type="1">
<li><p>Complexity</p>
<ol type="1">
<li><p>Efficient Algorithm : poly-time algorithm .</p></li>
<li><p>NP class : class of problems that are easy to verify a solution
(but may be hard to solve it)</p>
<p>Formal def : <span class="math inline">\(\forall L\in NP ,\exists
\text{efficient algorithm } \mathcal A_L , \mathcal
A(x)=\begin{cases}1&amp;x\in L\\0&amp;x\notin
L\end{cases}\)</span></p></li>
</ol></li>
<li><p>Proof</p>
<ol type="1">
<li><p>Def : a static sequence of rules</p></li>
<li><p>E.g.1 : Prove that <span
class="math inline">\(f(x,y)=x^2y^3-5xy+4=0\)</span> has a solution
.</p>
<p>Proof 1 [Explicit Proof] : <span
class="math inline">\(f(1,1)=0\)</span></p>
<p>Proof 2 [Implicit Proof] : <span
class="math inline">\(f(2,1)&lt;0,f(2,2)&gt;0\)</span> .</p>
<p>( <span class="math inline">\(f(2,x)\)</span> is continuous , so
<span class="math inline">\(\exists x_0\in (1,2) , f(2,x_0)=0\)</span>
)</p></li>
</ol></li>
</ol>
<h3 id="interactive-proof">2 Interactive Proof</h3>
<ol type="1">
<li><p>Interactive Proof</p>
<ol type="1">
<li><p>A Prover and a Verifier , Prover needs to convince Verifier some
proposition .</p>
<p>Usually , Prover needs to convince Verifier that some proposition is
<strong>true</strong> . <span class="math inline">\((x\in
L)\)</span></p></li>
<li><p>Prover : with unbounded computation sources</p>
<p>Verifier : Only efficient algorithm</p></li>
<li><p>Complexity Class : IP : class of problems that are easy to
determine with an interactive proof</p>
<ul>
<li><span class="math inline">\(NP\subsetneq IP\)</span></li>
</ul></li>
<li><p>Transcript</p>
<p>Prover sends <span class="math inline">\(m_1\)</span> to Verifier ,
Verifier receives <span class="math inline">\(m_1\)</span> and sends
<span class="math inline">\(m_2\)</span> to Prover , ... <span
class="math display">\[
\begin{aligned}
P(x,r_p)\to m_1\quad \quad &amp;\\
V(x,r_v,m_1,\cdots,m_{i-1})\to m_i\quad&amp; \text{for odd }i\\
P(x,r_p,m_1,\cdots,m_{i-1})\to m_i\quad&amp; \text{for even }i\\
V(x,r_v,m_1,\cdots,m_k)\to y\in \{0,1\}&amp;
\end{aligned}
\]</span></p>
<ol type="1">
<li>Def : transcript : <span
class="math inline">\(\tau=\{m_1,\cdots,m_k\}\)</span></li>
<li>Def : <span class="math inline">\(\braket{P,V}(x):=y\)</span></li>
</ol></li>
</ol></li>
<li><p>IP Criteria</p>
<ol type="1">
<li><p>Completeness : If Prover is honest , Verifier accepts the proof
.</p>
<p><span class="math inline">\(\forall x\in L ,
\Pr\{\left&lt;P,V\right&gt;(x)=1\}=1\)</span></p></li>
<li><p>Soundness : If Prover is dishonest , Verifier rejects the proof
(with high probability) .</p></li>
<li><p>Zero-Knowledge : If Prover is honest , Verifier cannot know more
than "knowing the proposition is true"</p></li>
</ol></li>
<li><p>Definition (somewhat formal (?) )</p>
<p>A pair of randomized algorithms <span
class="math inline">\((P,V)\)</span> is an interactive proof for <span
class="math inline">\(L\)</span></p>
<ol type="1">
<li><p><span class="math inline">\(V\)</span> runs in poly-time</p></li>
<li><p>Completeness : <span class="math inline">\(\forall x\in L ,
\Pr\{\braket{P,V}(x)=1\}=1\)</span></p></li>
<li><p>Soundness : <span class="math inline">\(\forall x\notin L,\forall
P^*,\Pr\{\braket{P^*,V}(x)=1\}&lt; \epsilon\)</span></p></li>
<li><p>Zero-Knowledge (Optimal)</p>
<p><span class="math inline">\(\forall x\in L\)</span> , <span
class="math inline">\(V\)</span> can generate everything itself with
bounded computation time without interaction</p>
<p><strong>gain sth. cannot gain by PPT <span
class="math inline">\(\Rightarrow\)</span> gain
knowledge</strong></p></li>
</ol></li>
</ol>
<h3 id="ip-examples">3 IP Examples</h3>
<ol type="1">
<li><p>Graph non-Isomorphism</p>
<ol type="1">
<li><p>Description</p>
<p>Prover and Verifier know graphs <span
class="math inline">\(G_0,G_1\)</span> .</p>
<p>Prover wants to convince verifier that <span
class="math inline">\(G_0\)</span> is not isomorphic with <span
class="math inline">\(G_1\)</span> . <span class="math display">\[
\begin{aligned}
&amp;G_0=(V,E_0) , G_1=(V,E_1)\\
\not\exists \pi\in S_{|V|}&amp;\ ,\ \{(\pi(u),\pi(v)):(u,v)\in E_0\}=E_1
\end{aligned}
\]</span></p></li>
<li><p>Protocol</p>
<p>Global : Prover and Verifier already know <span
class="math inline">\(G_0,G_1\)</span> .</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 13%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th>Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(b\leftarrow \{0,1\}\)</span> , <span
class="math inline">\(\pi\leftarrow S_{|V|}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;- <span class="math inline">\(\tilde
G\)</span> --</td>
<td><span class="math inline">\(\tilde G:=\pi(G_b)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Find $b $ , <span
class="math inline">\(G_{\tilde b}\sim \tilde G\)</span></td>
<td style="text-align: center;">-- <span class="math inline">\(\tilde
b\)</span> -&gt;</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(y=\begin{cases}1&amp; \text{if }b=\tilde
b\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Analysis</p>
<ol type="1">
<li><p>Completeness : When <span class="math inline">\(G_0\not\sim
G_1\)</span> , <span class="math inline">\(G_{\tilde b}\sim \tilde G\sim
G_b\)</span> , so <span class="math inline">\(b=\tilde b\)</span> .
Always accept .</p></li>
<li><p>Soundness : When <span class="math inline">\(G_0\sim G_1\)</span>
, any prover can only guess <span class="math inline">\(\tilde
b\)</span> randomly since <span class="math inline">\(G_0\sim G_1\sim
\tilde G\)</span> . <span class="math inline">\(\Pr\{V\text{
accept}\}\le \frac{1}{2}\)</span> .</p>
<p>Proof : <span class="math inline">\(P^*\)</span> knows <span
class="math inline">\(\tilde G\)</span> and wants to guess <span
class="math inline">\(b\)</span> , we need to prove that <span
class="math display">\[
\forall P^* , \Pr\{P^*(\tilde G)=b\}\le \frac{1}{2}
\]</span> Since <span class="math inline">\(\forall \tilde G\sim G_0\sim
G_1\)</span> , <span class="math display">\[
\begin{aligned}
\Pr\{\pi(G_0)=\tilde G\}&amp;=\Pr\{\pi(G_1)=\tilde G\}\\
\Rightarrow \Pr\{\pi(G_b)=\tilde G|b=0\}&amp;=\Pr\{\pi(G_b)=\tilde
G|b=1\}\\
\Rightarrow \Pr\{b=0|\pi(G_b)=\tilde G\}&amp;=\Pr\{b=1|\pi(G_b)=\tilde
G\}\\
\end{aligned}
\]</span> Therefore , <span class="math display">\[
\forall P^* , \Pr\{P^*(\tilde G)=b|\pi(G_b)=\tilde G\}\le\frac{1}{2}
\]</span> Therefore , <span class="math display">\[
\begin{aligned}
\Pr\{P^*(\tilde G)=b\}&amp;=\sum_{\tilde G}\Pr\{P^*(\tilde
G)=b|\pi(G_b)=\tilde G\}\Pr\{\pi(G_b)=\tilde G\}\\
&amp;\le \frac{1}{2}\sum_{\tilde G}\Pr\{\pi(G_b)=\tilde G\}\\
&amp;=\frac{1}{2}
\end{aligned}
\]</span> <span class="math inline">\(k\)</span> rounds : <span
class="math inline">\(\Pr\{V\text{ accepts}\}\le \frac{1}{2^k}\)</span>
.</p></li>
<li><p>Zero-Knowledge</p>
<p>Verifier itself knows <span class="math inline">\(b,\pi,\tilde
G\)</span> . Prover tells Verifier <span class="math inline">\(\tilde
b\)</span> .</p>
<p>Only consider <span class="math inline">\(G_0\not\sim G_1\)</span> ,
then <span class="math inline">\(\tilde b\)</span> must be <span
class="math inline">\(b\)</span> . Verifier itself can generate the
transcript .</p>
<blockquote>
<p>注意：因为 zero-knowledge 是对 Prover 的保护，我们只需要保护诚实
Prover 的隐私，因此只要考虑命题成立的情况（即 <span
class="math inline">\(G_0\not\sim G_1\)</span>）。</p>
</blockquote></li>
</ol></li>
<li><p>Notes</p>
<blockquote>
<p>Given <span class="math inline">\(G_0\not\sim G_1\)</span> , Verifier
can generate the proof itself</p>
<p>Due to Verifier's randomness , Prover cannot generate the proof
itself</p>
</blockquote>
<blockquote>
<p>Graph non-isomorphism Problem is not <span
class="math inline">\(NP\)</span> , but can be solved by <span
class="math inline">\(IP\)</span> .</p>
</blockquote></li>
</ol></li>
<li><p>Collision Problem</p>
<ol type="1">
<li><p>Definition</p>
<ol type="1">
<li>Given <span class="math inline">\(h:\{0,1\}^n\to\{0,1\}^n\)</span> ,
either <span class="math inline">\(h\)</span> is a permutation or <span
class="math inline">\(|Im(h)|\le 2^{n-1}\)</span> .</li>
<li>Prover wants to convince Verifier that <span
class="math inline">\(h\)</span> is a permutation .</li>
</ol></li>
<li><p>Protocol 1</p>
<p>Global : Prover and Verifier already know <span
class="math inline">\(h\)</span> . <span class="math inline">\(\forall
x\in \{0,1\}^n\)</span> , Verifier can get <span
class="math inline">\(h(x)\)</span> in poly-time .</p>
<table style="width:100%;">
<colgroup>
<col style="width: 30%" />
<col style="width: 14%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(x\leftarrow
\{0,1\}^n\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;- <span
class="math inline">\(y\)</span> --</td>
<td style="text-align: center;"><span
class="math inline">\(y:=h(x)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Find <span class="math inline">\(\tilde
x\)</span> , <span class="math inline">\(h(\tilde x)=y\)</span></td>
<td style="text-align: center;">-- <span class="math inline">\(\tilde
x\)</span> -&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;x=\tilde
x\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Analysis 1</p>
<ol type="1">
<li><p>Completeness : When <span class="math inline">\(h\)</span> is a
permutation , <span class="math inline">\(h\)</span> is a injection ,
<span class="math inline">\(x=\tilde x\)</span> .</p></li>
<li><p>Soundness : When <span class="math inline">\(h\)</span> is not a
permutation , then <span class="math inline">\(|Im(h)|\le
2^{n-1}\)</span> . <span class="math display">\[
\forall x , P^*\ ,\ \Pr\{P^*(h(x))=x\}=\frac{1}{|h^{-1}(h(x))|}
\]</span> Therefore , <span class="math display">\[
\begin{aligned}
\Pr\{V\text{ accepts}\}&amp;=\sum_{y\in Im(h)}\Pr\{y=f(x)|x\in
\{0,1\}^n\}\Pr\{P^*(h(x))=x\}\\
&amp;=\sum_{y\in Im(h)}\frac{|h^{-1}(y)|}{2^n}\frac{1}{|h^{-1}(y)|}\\
&amp;=\frac{|Im(h)|}{2^n}\\
&amp;\le \frac{1}{2}
\end{aligned}
\]</span> <span class="math inline">\(k\)</span> rounds : <span
class="math inline">\(\Pr\{V \text{ accepts}\}\le\frac{1}{2^k}\)</span>
.</p></li>
<li><p>Zero-knowledge :</p>
<p>Verifier itself knows <span class="math inline">\(x,y\)</span> .
Prover tells Verifier <span class="math inline">\(\tilde x\)</span>
.</p>
<p>When <span class="math inline">\(h\)</span> is a permutation , <span
class="math inline">\(\tilde x=x\)</span> , so Verifier can generate
<span class="math inline">\(\tilde x\)</span> itself .</p></li>
</ol></li>
<li><p>Protocol 2</p>
<p>Global : Prover and Verifier already know <span
class="math inline">\(h\)</span> . <span class="math inline">\(\forall
x\in \{0,1\}^n\)</span> , Verifier can get <span
class="math inline">\(h(x)\)</span> in poly-time .</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 10%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;- <span
class="math inline">\(y\)</span> --</td>
<td style="text-align: center;"><span class="math inline">\(y\leftarrow
\{0,1\}^n\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">Find <span
class="math inline">\(x\)</span> , <span
class="math inline">\(h(x)=y\)</span></td>
<td style="text-align: center;">-- <span
class="math inline">\(x\)</span> -&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;h(x)=y\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Analysis 2</p>
<ol type="1">
<li><p>Completeness : When <span class="math inline">\(h\)</span> is a
permutation , <span class="math inline">\(h\)</span> is a bijection ,
<span class="math inline">\(x\)</span> always exists and unique . Always
accept .</p></li>
<li><p>Soundness : When <span class="math inline">\(h\)</span> is not a
permutation , <span class="math inline">\(|Im(h)|\le 2^{n-1}\)</span> .
<span class="math display">\[
\Pr\{h^{-1}(y)=\varnothing|y\leftarrow
\{0,1\}^n\}=1-\frac{|Im(h)|}{2^n}\ge \frac{1}{2}
\]</span> When <span
class="math inline">\(h^{-1}(y)=\varnothing\)</span> , any Prover cannot
convince verifier , so <span class="math display">\[
\Pr\{V\text{ accepts}\}\le 1-\Pr\{h^{-1}(y)=\varnothing|y\leftarrow
\{0,1\}^n\}\le \frac{1}{2}
\]</span> <span class="math inline">\(k\)</span> rounds : <span
class="math inline">\(\Pr\{V \text{ accepts}\}\le\frac{1}{2^k}\)</span>
.</p></li>
<li><p>Zero-knowledge : NOT zero-knowledge</p>
<p><span class="math inline">\(V\)</span> knows <span
class="math inline">\(h^{-1}(y)\)</span> , which cannot be computed in
poly-time by itself .</p></li>
</ol></li>
<li><p>Notes</p>
<blockquote>
<p>In Protocol 1 , when <span class="math inline">\(h\)</span> is a
permutation , Verifier can always generate a valid proof</p>
</blockquote>
<blockquote>
<p>In both Protocols , Prover must have the ability to solve <span
class="math inline">\(h^{-1}\)</span> . This may lead Verifier knowing
something more .</p>
</blockquote></li>
</ol></li>
</ol>
<h3 id="formularize-zero-knowledge-ip">4 Formularize zero-knowledge
IP</h3>
<ol type="1">
<li><p>Security Parameter : <span
class="math inline">\(\kappa\)</span></p>
<ol type="1">
<li>For efficiency : usually <span
class="math inline">\(|x|=poly(\kappa)\)</span> , PPT should run in
<span class="math inline">\(poly(\kappa)\)</span> .</li>
<li>For security : negligible function</li>
</ol></li>
<li><p>Negligible function : <span
class="math inline">\(\epsilon\)</span></p>
<ol type="1">
<li><p>Def : negligible function <span
class="math inline">\(\epsilon:\mathbb Z^*\to \mathbb R^*\)</span></p>
<p>For all polynomial <span class="math inline">\(p\)</span> , <span
class="math inline">\(\exists c\in \mathbb Z^* , \forall
k&gt;c,\epsilon(k)&lt;\frac{1}{p(k)}\)</span> .</p></li>
<li><p>Propositions :</p>
<ol type="1">
<li><span class="math inline">\(\epsilon , \delta\)</span> negligible
<span class="math inline">\(\to\)</span> <span
class="math inline">\(\epsilon+\delta , \epsilon\delta\)</span>
negligible</li>
<li><span class="math inline">\(\epsilon\)</span> negligible <span
class="math inline">\(\to\)</span> For all polynomial <span
class="math inline">\(p\)</span> , <span
class="math inline">\(p\epsilon\)</span> negligible</li>
</ol></li>
<li><p>Conventions :</p>
<ol type="1">
<li><p><span class="math inline">\(\epsilon\)</span> noticeable : <span
class="math inline">\(\exists\)</span> polynomial <span
class="math inline">\(p\)</span> , <span class="math inline">\(\exists
c\in \mathbb Z^*,\forall k&gt;c,\epsilon(k)\ge
\frac{1}{p(k)}\)</span></p></li>
<li><p><span class="math inline">\(A\)</span> happens with overwhelming
probability : <span class="math display">\[
\Pr\{A\}\ge 1-\epsilon \quad\quad \epsilon \text{ is negligible}
\]</span></p></li>
</ol></li>
</ol>
<blockquote>
<p>There exists function that is neither negligible nor noticeable</p>
</blockquote></li>
<li><p>View of Verifier <span class="math display">\[
View_V^P(x):=(x,r,\tau)
\]</span></p></li>
<li><p>Honest-Verifier Zero-knowledge</p>
<ol type="1">
<li><p>Perfect honest-verifier zero-knowledge <span
class="math display">\[
\exists M\in PPT\ ,\ \forall x\in L\ ,\ View_V^P(x)\equiv M(x)
\]</span></p></li>
<li><p>Statistical honest-verifier zero-knowledge</p>
<p>The statistical distance between <span
class="math inline">\(View_V^P(x)\)</span> and <span
class="math inline">\(M(x)\)</span> is negligible</p>
<p><span class="math inline">\(\exists M\in PPT\ ,\ \forall x\in
L\)</span> , <span class="math display">\[
SD(View_V^P(x),M(x))=\frac{1}{2}\sum_{s}\left|\Pr\{View_V^P(x)=s\}-\Pr\{M(x)=s\}\right|&lt;\epsilon
\]</span></p></li>
<li><p>Computational honest-verifier zero-knowledge</p>
<p><span class="math inline">\(\exists M\in PPT\ ,\ \forall x\in L\ , \
\forall\)</span> distinguisher <span class="math inline">\(D\in
PPT\)</span> , <span class="math display">\[
\left|\Pr\{D(View_V^P(x))=1\}-\Pr\{D(M(x))=1\}\right|&lt;\epsilon
\]</span></p></li>
</ol></li>
<li><p>Dishonest Verifier</p>
<p><span class="math inline">\(\braket{P,V}\)</span> achieves
perfect/statistical/computational dishonest-verifier zero-knowledge if
:</p>
<p><span class="math inline">\(\forall V^*\in PPT\ , \ \exists\)</span>
expected poly-time randomized algorithm <span
class="math inline">\(M^*\)</span> , <span class="math inline">\(\forall
x\in L\)</span> , <span class="math inline">\(View_{V^*}^P(x)\)</span>
and <span class="math inline">\(M^*(x)\)</span> are
perfectly/statistically/computationally indistinguishable .</p></li>
<li><p>Graph Isomorphism IP with dishonest-verifier zero-knowledge</p>
<ol type="1">
<li><p>Definition</p>
<p>Prover and Verifier know graph <span
class="math inline">\(G_0,G_1\)</span> .</p>
<p>Prover wants to convince Verifier that <span
class="math inline">\(G_0\sim G_1\)</span> , i.e. <span
class="math inline">\(\exists \pi,\pi(G_0)=G_1\)</span> .</p></li>
<li><p>Protocol</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 12%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Prover</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">Verifier</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\pi_r\leftarrow S_n\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\tilde
G:=\pi_r(G_0)\)</span></td>
<td style="text-align: center;">--<span class="math inline">\(\tilde
G\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;-<span
class="math inline">\(b\)</span>--</td>
<td style="text-align: center;"><span class="math inline">\(b\leftarrow
\{0,1\}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">find <span
class="math inline">\(\pi_b\)</span> , s.t. <span
class="math inline">\(\tilde G=\pi_b(G_b)\)</span></td>
<td style="text-align: center;">--<span
class="math inline">\(\pi_b\)</span>-&gt;</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span
class="math inline">\(\begin{cases}1&amp;\tilde
G=\pi_b(G_b)\\0&amp;\text{otherwise}\end{cases}\)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note : If Prover knows <span class="math inline">\(\pi\)</span> that
<span class="math inline">\(\pi(G_0)=G_1\)</span> , then <span
class="math inline">\(\pi_b\)</span> can be constructed : <span
class="math display">\[
\pi_b=\begin{cases}\pi_r&amp;b=0\\\pi_r\circ\pi^{-1}&amp;b=1\end{cases}
\]</span></p>
</blockquote></li>
<li><p>Analysis</p>
<ol type="1">
<li><p>Completeness : If <span class="math inline">\(G_0\sim
G_1\)</span> , <span class="math inline">\(\pi_b\)</span> can be
constructed as above . Always Accept .</p></li>
<li><p>Soundness : If <span class="math inline">\(G_0\not\sim
G_1\)</span> , <span class="math inline">\(\exists b^*\in
\{0,1\},G_{b^*}\not\sim\tilde G\)</span></p>
<p><span class="math inline">\(\Pr\{V \text{ rejects}\}\ge \Pr\{V\text{
chooses }b^*\}=\frac{1}{2}\)</span></p>
<blockquote>
<p>Note : we cannot let Verifier just choose <span
class="math inline">\(b=1\)</span> , since a malicious Prover can
violate the protocol , <span class="math inline">\(\pi_r\)</span> may
not be a permutation , and <span class="math inline">\(\tilde G\)</span>
may not isomorphic to <span class="math inline">\(G_0\)</span> .</p>
</blockquote></li>
<li><p>honest-verifier zero-knowledge :</p>
<p>Verifier itself knows : <span
class="math inline">\(G_0,G_1,b\)</span> , <span
class="math inline">\(r\)</span> : randomness generating <span
class="math inline">\(b\)</span> . Prover tells verifier <span
class="math inline">\(\tilde G,\pi_b\)</span> .</p>
<p><span class="math inline">\(View_V^P=(G_0,G_1,r,b,\tilde
G,\pi_b)\)</span> .</p>
<p><span class="math inline">\(M_V\)</span> :</p>
<ol type="1">
<li>sample <span class="math inline">\(b\leftarrow \{0,1\}\)</span></li>
<li>choose <span class="math inline">\(\pi_b\leftarrow S_n\)</span></li>
<li><span class="math inline">\(\tilde G:=\pi_b(G_b)\)</span></li>
</ol>
<p>Since Prover and Verifier are honest , <span
class="math inline">\(b\)</span> is independent of $G $ , and <span
class="math inline">\(\pi_b\)</span> is generated by a uniformly random
<span class="math inline">\(\pi_r\)</span> hence is also uniformly
random .</p></li>
<li><p>dishonest-verifier zero-knowledge :</p>
<p>Malicious Verifier can choose <span class="math inline">\(b\)</span>
based on <span class="math inline">\(\tilde G\)</span> to gain more
knowledge .</p>
<p><span class="math inline">\(M^*\)</span> : should perform as Prover
:</p>
<ol type="1">
<li>guess <span class="math inline">\(b^*\in \{0,1\}\)</span></li>
<li>compute <span class="math inline">\(\pi_r\leftarrow S_n\)</span> ,
<span class="math inline">\(\tilde G:=\pi_r(G_{b^*})\)</span></li>
<li>use Verifier to receive <span class="math inline">\(b\)</span></li>
<li>If <span class="math inline">\(b\neq b^*\)</span> , go back to
1.</li>
<li>If <span class="math inline">\(b=b^*\)</span> , then let <span
class="math inline">\(\pi_b=\pi_r\)</span> , get the view</li>
</ol></li>
</ol></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>课程笔记</category>
        <category>零知识证明和多方安全计算</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>密码学-零知识证明</tag>
        <tag>密码学-交互式证明</tag>
      </tags>
  </entry>
  <entry>
    <title>答疑坊 微积分 趣题若干</title>
    <url>/2023/10/07/%E7%AD%94%E7%96%91%E5%9D%8A-%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%B6%A3%E9%A2%98%E8%8B%A5%E5%B9%B2/</url>
    <content><![CDATA[<h3 id="p1">P1</h3>
<p>类型：极限存在性</p>
<h4 id="题目">题目</h4>
<p>证明下面的极限存在： <span class="math display">\[
\lim_{n\to
+\infty}(1+\frac{1}{2^2})(1+\frac{1}{3^2})\cdots(1+\frac{1}{n^2})
\]</span></p>
<h4 id="解答">解答</h4>
<p>显然上述数列单调增，因此只需要证明有上界 <span
class="math display">\[
\begin{aligned}
&amp;\quad \prod_{k=2}^n (1+\frac{1}{k^2})\\
&amp;=\exp\left(\sum_{k=2}^n \ln (1+\frac{1}{k^2})\right)\\
&amp;\le \exp\left(\sum_{k=2}^n \frac{1}{k^2}\right)\\
&amp;\le \exp\left(\sum_{k=2}^n \frac{1}{k(k-1)}\right)\\
&amp;=\exp\left(\sum_{k=1}^n \frac{1}{k-1}-\frac{1}{k}\right)\\
&amp;=\exp(1-\frac{1}{n})\\
&amp;\le e
\end{aligned}
\]</span> 其中第 <span class="math inline">\(3\)</span> 行使用常见不等式
<span class="math inline">\(\ln(1+x)\le x\)</span> ，第 <span
class="math inline">\(4\sim 6\)</span> 行为裂项。</p>
<hr />
<h3 id="p2">P2</h3>
<p>类型：<span class="math inline">\(e\)</span> 相关极限不等式</p>
<h4 id="题目-1">题目</h4>
<p>证明，对任意正整数 <span class="math inline">\(n\ge 2\)</span> ，
<span class="math display">\[
\sum_{k=0}^n
\frac{1}{k!}-\frac{3}{2n}&lt;(1+\frac{1}{n})^n&lt;\sum_{k=0}^n
\frac{1}{k!}
\]</span></p>
<h4 id="解答-1">解答</h4>
<p>使用二项式定理 <span class="math display">\[
\begin{aligned}
(1+\frac{1}{n})^n&amp;=\sum_{k=0}^n \frac{n!}{k!(n-k)!}\frac{1}{n^k}\\
&amp;=\sum_{k=0}^n \frac{1}{k!}\prod_{j=0}^{k-1}(1-\frac{j}{n})
\end{aligned}
\]</span> 显然对 <span class="math inline">\(n\ge 2\)</span> , <span
class="math inline">\(\prod_{j=0}^{k-1}(1-\frac{j}{n})&lt; 1\)</span>
，故右侧不等式成立。</p>
<p>考虑 Bernoulli 不等式： <span class="math display">\[
\forall a_1,\cdots,a_n&gt;-1,且a_i 同号，则\prod_{k=1}^n
(1+a_k)&gt;1+\sum_{k=1}^n a_k
\]</span> 故 <span class="math display">\[
\begin{aligned}
(1+\frac{1}{n})^n&amp;&gt;\sum_{k=0}^n\left(
\frac{1}{k!}-\frac{1}{k!}\sum_{j=1}^{k-1}\frac{j}{n}\right)\\
&amp;=\sum_{k=0}^n \frac{1}{k!}-\sum_{k=0}^n
\frac{1}{k!}\frac{k(k-1)}{2n}\\
&amp;=\sum_{k=0}^n \frac{1}{k!}-\sum_{k=2}^n
\frac{1}{(k-2)!}\frac{1}{2n}\\
&amp;\ge \sum_{k=0}^n \frac{1}{k!}-\frac{1}{2n}\left(2+\sum_{k=2}^{n-2}
\frac{1}{k(k-1)}\right)\\
&amp;=\sum_{k=0}^n \frac{1}{k!}-\frac{1}{2n}(3-\frac{1}{n-2})\\
&amp;&gt;\sum_{k=0}^n \frac{1}{k!}-\frac{3}{2n}
\end{aligned}
\]</span></p>
<hr />
]]></content>
      <categories>
        <category>答疑坊</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>答疑坊</tag>
        <tag>微积分</tag>
        <tag>多元微积分</tag>
        <tag>级数</tag>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>测试文档</tag>
      </tags>
  </entry>
  <entry>
    <title>答疑坊 程设/离散/DSA 趣题若干</title>
    <url>/2023/10/07/%E7%AD%94%E7%96%91%E5%9D%8A-%E7%A8%8B%E8%AE%BE-DSA-%E8%B6%A3%E9%A2%98%E8%8B%A5%E5%B9%B2/</url>
    <content><![CDATA[<h3 id="p1">P1</h3>
<h4 id="问题描述">问题描述</h4>
<p>输入 <span class="math inline">\(3n-1\)</span> 个数，其中 <span
class="math inline">\(n-1\)</span> 个数出现恰好 <span
class="math inline">\(3\)</span> 次，<span
class="math inline">\(1\)</span> 个数恰好出现 <span
class="math inline">\(2\)</span> 次。求这个出现 <span
class="math inline">\(2\)</span> 次的数。</p>
<p>要求，时间复杂度 <span class="math inline">\(\tilde {\mathcal
O}(n)\)</span> , 空间复杂度 <span class="math inline">\(\mathcal
O(1)\)</span> .</p>
<h4 id="算法分析">算法分析</h4>
<p>考虑使用三进制不进位加法，显然满足交换律、结合律，且 <span
class="math inline">\(a\oplus a\oplus a=0\)</span> ，出现 <span
class="math inline">\(3\)</span> 次的数都抵消掉，只剩下恰好出现 <span
class="math inline">\(2\)</span> 次的那个数 <span
class="math inline">\(a\)</span> 的 "2倍"。</p>
<p>对最后结果 <span class="math inline">\(sum\)</span> 求 <span
class="math inline">\(sum\oplus sum\)</span> 。因 <span
class="math inline">\(sum=a\oplus a\)</span> , 故 <span
class="math inline">\(sum\oplus sum=a\oplus a\oplus a\oplus a=a\)</span>
。</p>
]]></content>
      <categories>
        <category>答疑坊</category>
        <category>程设/离散/DSA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>答疑坊</tag>
        <tag>程序设计</tag>
        <tag>离散数学</tag>
      </tags>
  </entry>
</search>
